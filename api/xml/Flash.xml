<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<class path="Array" params="T" file="/usr/local/lib/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is 
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<map public="1" params="S" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<resize public="1" set="method">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Class" params="T" file="/usr/local/lib/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/usr/local/lib/haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from timestamp (in milliseconds) `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formatted string `s`, with the following accepted
		formats:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of the date. It might
		only have a per-second precision depending on the platforms.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range) where `0` is Sunday.</haxe_doc>
		</getDay>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.utils.RegExp" params="" file="/usr/local/lib/haxe/std/flash/utils/RegExp.hx" extern="1">
		<dotall public="1" set="null"><x path="Bool"/></dotall>
		<extended public="1" set="null"><x path="Bool"/></extended>
		<global public="1" set="null"><x path="Bool"/></global>
		<ignoreCase public="1" set="null"><x path="Bool"/></ignoreCase>
		<lastIndex public="1"><x path="Int"/></lastIndex>
		<multiline public="1" set="null"><x path="Bool"/></multiline>
		<source public="1" set="null"><c path="String"/></source>
		<exec public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":ns"><e>"http://adobe.com/AS3/2006/builtin"</e></m></meta>
		</exec>
		<test public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":ns"><e>"http://adobe.com/AS3/2006/builtin"</e></m></meta>
		</test>
		<new public="1" set="method"><f a="?pattern:?options">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"RegExp"</e></m>
		</meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="EReg" params="" file="/usr/local/lib/haxe/std/flash/_std/EReg.hx">
		<r><c path="flash.utils.RegExp"/></r>
		<result><d/></result>
		<match public="1" set="method" line="31">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="37">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, an exception is thrown.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<new public="1" set="method" line="27">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/local/lib/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/local/lib/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<typedef path="List" params="T" file="/usr/local/lib/haxe/std/List.hx"><c path="haxe.ds.List"><c path="List.T"/></c></typedef>
	<typedef path="Map" params="K:V" file="/usr/local/lib/haxe/std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="/usr/local/lib/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="/usr/local/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, Ï€. `PI` is approximately 3.141592653589793.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.

		If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is
		`POSITIVE_INFINITY`.

		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		exp(1.0) is approximately 2.718281828459.

		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</ffloor>
		<fceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fceil>
		<fround public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value, as a Float.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Reflect" params="" file="/usr/local/lib/haxe/std/flash/_std/Reflect.hx">
		<hasField public="1" set="method" line="24" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<getProperty public="1" set="method" line="36" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<fields public="1" set="method" line="58" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="81" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compareMethods public="1" set="method" line="91" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.
		
		If `f1` or `f2` are null, the result is false.
		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.

		If `f1` or `f2` are member method closures, the result is true if they
		are closures of the same method on the same object value, false otherwise.</haxe_doc>
		</compareMethods>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/local/lib/haxe/std/flash/_std/Std.hx">
		<is public="1" set="method" line="26" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.</haxe_doc>
		</is>
		<string public="1" set="method" line="34" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<parseFloat public="1" set="method" line="49" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accept or can return a `null` value, or for the Flash compiler and AS3
	generator to distinguish between base values that can be `null` and others that
	can't.

	@see https://haxe.org/manual/types-nullability.html</haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/local/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="/usr/local/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.
	
	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="StringBuf" params="" file="/usr/local/lib/haxe/std/StringBuf.hx">
		<b><c path="String"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<new public="1" get="inline" set="null" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/usr/local/lib/haxe/std/StringTools.hx">
		<startsWith public="1" set="method" line="183" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is `null`, the result is unspecified.

		If `start` is the empty String `""`, the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="213" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is `null`, the result is unspecified.

		If `end` is the empty String `""`, the result is true.</haxe_doc>
		</endsWith>
		<replace public="1" set="method" line="378" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurrences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s`. If `by` is also the empty String `""`, `s` remains unchanged.

		This is a convenience function for `s.split(sub).join(by)`.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="400" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its `length` equals `digits`.</haxe_doc>
		</hex>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="ValueType" params="" file="/usr/local/lib/haxe/std/flash/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="Type" params="" file="/usr/local/lib/haxe/std/flash/_std/Type.hx">
		<getClassName public="1" set="method" line="70" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="92" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="96" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="120" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="137" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="158" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="171" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<getEnumConstructs public="1" set="method" line="217" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="222" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="/usr/local/lib/haxe/std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned `Int` type is only defined for Flash and C#.
	Simulate it for other platforms.

	@see https://haxe.org/manual/types-basic-types.html</haxe_doc>
		<impl><class path="_UInt.UInt_Impl_" params="" file="/usr/local/lib/haxe/std/UInt.hx" private="1" module="UInt"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="flash.events.IEventDispatcher" params="" file="/usr/local/lib/haxe/std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<addEventListener public="1" set="method">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useCapture : false }</e></m></meta>
		</removeEventListener>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="/usr/local/lib/haxe/std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<addEventListener public="1" set="method">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useCapture : false }</e></m></meta>
		</removeEventListener>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="/usr/local/lib/haxe/std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="/usr/local/lib/haxe/std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
		<alpha public="1"><x path="Float"/></alpha>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<blendShader public="1" get="null">
			<c path="flash.display.Shader"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</blendShader>
		<cacheAsBitmap public="1"><x path="Bool"/></cacheAsBitmap>
		<filters public="1"><c path="Array"><c path="flash.filters.BitmapFilter"/></c></filters>
		<height public="1"><x path="Float"/></height>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<mouseX public="1" set="null"><x path="Float"/></mouseX>
		<mouseY public="1" set="null"><x path="Float"/></mouseY>
		<name public="1"><c path="String"/></name>
		<opaqueBackground public="1"><x path="Null"><x path="UInt"/></x></opaqueBackground>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<rotation public="1"><x path="Float"/></rotation>
		<rotationX public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationX>
		<rotationY public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationY>
		<rotationZ public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationZ>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<scaleZ public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</scaleZ>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<visible public="1"><x path="Bool"/></visible>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</z>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<globalToLocal3D public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Vector3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</globalToLocal3D>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method">
			<f a="x:y:?shapeFlag" v="::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ shapeFlag : false }</e></m></meta>
		</hitTestPoint>
		<local3DToGlobal public="1" set="method">
			<f a="point3d">
				<c path="flash.geom.Vector3D"/>
				<c path="flash.geom.Point"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</local3DToGlobal>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="/usr/local/lib/haxe/std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<doubleClickEnabled public="1"><x path="Bool"/></doubleClickEnabled>
		<focusRect public="1"><d/></focusRect>
		<mouseEnabled public="1"><x path="Bool"/></mouseEnabled>
		<needsSoftKeyboard public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</needsSoftKeyboard>
		<softKeyboardInputAreaOfInterest public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardInputAreaOfInterest>
		<tabEnabled public="1"><x path="Bool"/></tabEnabled>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<requestSoftKeyboard public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestSoftKeyboard>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="/usr/local/lib/haxe/std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<mouseChildren public="1"><x path="Bool"/></mouseChildren>
		<numChildren public="1" set="null"><x path="Int"/></numChildren>
		<tabChildren public="1"><x path="Bool"/></tabChildren>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></contains>
		<getChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<removeChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChildren public="1" set="method">
			<f a="?beginIndex:?endIndex" v="0:2147483647">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ endIndex : 2147483647, beginIndex : 0 }</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</removeChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<stopAllMovieClips public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash11_8</e></m></meta>
		</stopAllMovieClips>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="/usr/local/lib/haxe/std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<buttonMode public="1"><x path="Bool"/></buttonMode>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<startDrag public="1" set="method">
			<f a="?lockCenter:?bounds" v="false:">
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ lockCenter : false }</e></m></meta>
		</startDrag>
		<startTouchDrag public="1" set="method">
			<f a="touchPointID:?lockCenter:?bounds" v=":false:">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ lockCenter : false }</e></m>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</startTouchDrag>
		<stopDrag public="1" set="method"><f a=""><x path="Void"/></f></stopDrag>
		<stopTouchDrag public="1" set="method">
			<f a="touchPointID">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</stopTouchDrag>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.display.MovieClip" params="" file="/usr/local/lib/haxe/std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<currentFrame public="1" set="null"><x path="Int"/></currentFrame>
		<currentFrameLabel public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</currentFrameLabel>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<enabled public="1"><x path="Bool"/></enabled>
		<framesLoaded public="1" set="null"><x path="Int"/></framesLoaded>
		<isPlaying public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</isPlaying>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<totalFrames public="1" set="null"><x path="Int"/></totalFrames>
		<trackAsMenu public="1"><x path="Bool"/></trackAsMenu>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></addFrameScript>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<t path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndPlay>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<t path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndStop>
		<nextFrame public="1" set="method"><f a=""><x path="Void"/></f></nextFrame>
		<nextScene public="1" set="method"><f a=""><x path="Void"/></f></nextScene>
		<play public="1" set="method"><f a=""><x path="Void"/></f></play>
		<prevFrame public="1" set="method"><f a=""><x path="Void"/></f></prevFrame>
		<prevScene public="1" set="method"><f a=""><x path="Void"/></f></prevScene>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Boot" params="" file="/usr/local/lib/haxe/std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" expr="false" line="52" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skip_constructor>
		<IN_E expr="0" line="83" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</IN_E>
		<enum_to_string public="1" set="method" line="84" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="99" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__instanceof>
		<__clear_trace public="1" set="method" line="109" static="1"><f a=""><x path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="117" static="1"><f a="rgb">
	<x path="UInt"/>
	<x path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="123" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="151" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="170" static="1">
			<f a="v:str">
				<d/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__string_rec>
		<__unprotect__ set="method" line="215" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<mapDynamic public="1" set="method" line="219" static="1">
			<f a="d:f">
				<d/>
				<d/>
				<unknown/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</mapDynamic>
		<filterDynamic public="1" set="method" line="227" static="1">
			<f a="d:f">
				<d/>
				<d/>
				<unknown/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</filterDynamic>
		<start set="method" line="54">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</start>
		<doInitDelay set="method" line="74"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></doInitDelay>
		<init set="method" line="79"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="46"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="/usr/local/lib/haxe/std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Lib" params="" file="/usr/local/lib/haxe/std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getURL public="1" set="method" line="56" static="1">
			<f a="url:?target">
				<c path="flash.net.URLRequest"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getURL>
		<haxe_doc>Platform-specific Flash Library. Provides some platform-specific 
	functions for the Flash target.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="flash.Vector" params="T" file="/usr/local/lib/haxe/std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="47" static="1">
			<f a="v">
				<c path="Array"><c path="ofArray.T"/></c>
				<c path="flash.Vector"><c path="ofArray.T"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="51" static="1">
			<f a="v">
				<c path="flash.Vector"><c path="convert.T"/></c>
				<c path="flash.Vector"><c path="convert.U"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</convert>
		<length public="1"><x path="Int"/></length>
		<fixed public="1"><x path="Bool"/></fixed>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<pop public="1" set="method"><f a=""><x path="Null"><c path="flash.Vector.T"/></x></f></pop>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
</f></push>
		<reverse public="1" set="method"><f a=""><x path="Void"/></f></reverse>
		<shift public="1" set="method"><f a=""><x path="Null"><c path="flash.Vector.T"/></x></f></shift>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Void"/>
</f></unshift>
		<slice public="1" set="method"><f a="?pos:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<splice public="1" set="method"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></indexOf>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lastIndexOf>
		<new public="1" set="method"><f a="?length:?fixed">
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>flash10</e></m>
		</meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="/usr/local/lib/haxe/std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<errno public="1"><x path="UInt"/></errno>
		<stub public="1"><x path="Bool"/></stub>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="Void"/>
</f></accDoDefaultAction>
		<accLocation public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<d/>
</f></accLocation>
		<accSelect public="1" set="method"><f a="operation:childID">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></accSelect>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<get_accFocus public="1" set="method"><f a=""><x path="UInt"/></f></get_accFocus>
		<get_accName public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accRole public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accRole>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accState public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accState>
		<get_accValue public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></isLabeledBy>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="/usr/local/lib/haxe/std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<description public="1"><c path="String"/></description>
		<forceSimple public="1"><x path="Bool"/></forceSimple>
		<name public="1"><c path="String"/></name>
		<noAutoLabeling public="1"><x path="Bool"/></noAutoLabeling>
		<shortcut public="1"><c path="String"/></shortcut>
		<silent public="1"><x path="Bool"/></silent>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.desktop.Clipboard" params="" file="/usr/local/lib/haxe/std/flash/desktop/Clipboard.hx" extern="1">
		<generalClipboard public="1" set="null" static="1"><c path="flash.desktop.Clipboard"/></generalClipboard>
		<formats public="1" set="null"><c path="Array"><e path="flash.desktop.ClipboardFormats"/></c></formats>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<clearData public="1" set="method"><f a="format">
	<e path="flash.desktop.ClipboardFormats"/>
	<x path="Void"/>
</f></clearData>
		<getData public="1" set="method"><f a="format:?transferMode">
	<e path="flash.desktop.ClipboardFormats"/>
	<e path="flash.desktop.ClipboardTransferMode"/>
	<t path="flash.utils.Object"/>
</f></getData>
		<hasFormat public="1" set="method"><f a="format">
	<e path="flash.desktop.ClipboardFormats"/>
	<x path="Bool"/>
</f></hasFormat>
		<setData public="1" set="method">
			<f a="format:data:?serializable" v="::true">
				<e path="flash.desktop.ClipboardFormats"/>
				<t path="flash.utils.Object"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ serializable : true }</e></m></meta>
		</setData>
		<setDataHandler public="1" set="method">
			<f a="format:handler:?serializable" v="::true">
				<e path="flash.desktop.ClipboardFormats"/>
				<t path="flash.utils.Function"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ serializable : true }</e></m></meta>
		</setDataHandler>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>flash10</e></m>
		</meta>
	</class>
	<enum path="flash.desktop.ClipboardFormats" params="" file="/usr/local/lib/haxe/std/flash/desktop/ClipboardFormats.hx">
		<AIR_PREFIX/>
		<BITMAP_FORMAT/>
		<FILE_LIST_FORMAT/>
		<FILE_PROMISE_LIST_FORMAT/>
		<FLASH_PREFIX/>
		<HTML_FORMAT/>
		<REFERENCE_PREFIX/>
		<RICH_TEXT_FORMAT/>
		<SERIALIZATION_PREFIX/>
		<TEXT_FORMAT/>
		<URL_FORMAT/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10</e></m>
		</meta>
	</enum>
	<enum path="flash.desktop.ClipboardTransferMode" params="" file="/usr/local/lib/haxe/std/flash/desktop/ClipboardTransferMode.hx">
		<CLONE_ONLY/>
		<CLONE_PREFERRED/>
		<ORIGINAL_ONLY/>
		<ORIGINAL_PREFERRED/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ActionScriptVersion" params="" file="/usr/local/lib/haxe/std/flash/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT2/>
		<ACTIONSCRIPT3/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>UInt</e></m>
		</meta>
	</enum>
	<class path="flash.display.Bitmap" params="" file="/usr/local/lib/haxe/std/flash/display/Bitmap.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<bitmapData public="1"><c path="flash.display.BitmapData"/></bitmapData>
		<pixelSnapping public="1"><e path="flash.display.PixelSnapping"/></pixelSnapping>
		<smoothing public="1"><x path="Bool"/></smoothing>
		<new public="1" set="method">
			<f a="?bitmapData:?pixelSnapping:?smoothing" v="::false">
				<c path="flash.display.BitmapData"/>
				<e path="flash.display.PixelSnapping"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.display.BitmapData" params="" file="/usr/local/lib/haxe/std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<height public="1" set="null"><x path="Int"/></height>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<transparent public="1" set="null"><x path="Bool"/></transparent>
		<width public="1" set="null"><x path="Int"/></width>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<x path="Void"/>
</f></applyFilter>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></colorTransform>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<t path="flash.utils.Object"/>
</f></compare>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha" v=":::::false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Point"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false }</e></m></meta>
		</copyPixels>
		<copyPixelsToByteArray public="1" set="method">
			<f a="rect:data">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyPixelsToByteArray>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<draw public="1" set="method">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing" v=":::::false">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<e path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false }</e></m></meta>
		</draw>
		<drawWithQuality public="1" set="method">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing:?quality" v=":::::false:">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<e path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<e path="flash.display.StageQuality"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ smoothing : false }</e></m>
				<m n=":require"><e>flash11_3</e></m>
			</meta>
		</drawWithQuality>
		<encode public="1" set="method">
			<f a="rect:compressor:?byteArray">
				<c path="flash.geom.Rectangle"/>
				<t path="flash.utils.Object"/>
				<c path="flash.utils.ByteArray"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</encode>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></floodFill>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<getColorBoundsRect public="1" set="method">
			<f a="mask:color:?findColor" v="::true">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ findColor : true }</e></m></meta>
		</getColorBoundsRect>
		<getPixel public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel>
		<getPixel32 public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel32>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getVector>
		<histogram public="1" set="method">
			<f a="?hRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><c path="flash.Vector"><x path="Float"/></c></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</histogram>
		<hitTest public="1" set="method">
			<f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold" v="::::1">
				<c path="flash.geom.Point"/>
				<x path="UInt"/>
				<t path="flash.utils.Object"/>
				<c path="flash.geom.Point"/>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ secondAlphaThreshold : 1 }</e></m></meta>
		</hitTest>
		<lock public="1" set="method"><f a=""><x path="Void"/></f></lock>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></merge>
		<noise public="1" set="method">
			<f a="randomSeed:?low:?high:?channelOptions:?grayScale" v=":0:255:7:false">
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ grayScale : false, channelOptions : 7, high : 255, low : 0 }</e></m></meta>
		</noise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></paletteMap>
		<perlinNoise public="1" set="method">
			<f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets" v="::::::7:false:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<c path="Array"><c path="flash.geom.Point"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ grayScale : false, channelOptions : 7 }</e></m></meta>
		</perlinNoise>
		<pixelDissolve public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor" v=":::0:0:0">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ fillColor : 0, numPixels : 0, randomSeed : 0 }</e></m></meta>
		</pixelDissolve>
		<scroll public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<setPixel public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</setVector>
		<threshold public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource" v=":::::0:0xFFFFFFFF:false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="String"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":value"><e>{ copySource : false, mask : 0xFFFFFFFF, color : 0 }</e></m></meta>
		</threshold>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></unlock>
		<new public="1" set="method">
			<f a="width:height:?transparent:?fillColor" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillColor : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flash.display.BlendMode" params="" file="/usr/local/lib/haxe/std/flash/display/BlendMode.hx">
		<ADD/>
		<ALPHA/>
		<DARKEN/>
		<DIFFERENCE/>
		<ERASE/>
		<HARDLIGHT/>
		<INVERT/>
		<LAYER/>
		<LIGHTEN/>
		<MULTIPLY/>
		<NORMAL/>
		<OVERLAY/>
		<SCREEN/>
		<SHADER/>
		<SUBTRACT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="/usr/local/lib/haxe/std/flash/display/CapsStyle.hx">
		<NONE/>
		<ROUND/>
		<SQUARE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrection" params="" file="/usr/local/lib/haxe/std/flash/display/ColorCorrection.hx">
		<DEFAULT/>
		<OFF/>
		<ON/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="/usr/local/lib/haxe/std/flash/display/ColorCorrectionSupport.hx">
		<DEFAULT_OFF/>
		<DEFAULT_ON/>
		<UNSUPPORTED/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="/usr/local/lib/haxe/std/flash/display/FrameLabel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<frame public="1" set="null"><x path="Int"/></frame>
		<name public="1" set="null"><c path="String"/></name>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GradientType" params="" file="/usr/local/lib/haxe/std/flash/display/GradientType.hx">
		<LINEAR/>
		<RADIAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="/usr/local/lib/haxe/std/flash/display/Graphics.hx" extern="1">
		<beginBitmapFill public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth" v="::true:false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smooth : false, repeat : true }</e></m></meta>
		</beginBitmapFill>
		<beginFill public="1" set="method">
			<f a="color:?alpha" v=":1">
				<x path="UInt"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1 }</e></m></meta>
		</beginFill>
		<beginGradientFill public="1" set="method">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v=":::::::0">
				<e path="flash.display.GradientType"/>
				<c path="Array"><x path="UInt"/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="flash.geom.Matrix"/>
				<e path="flash.display.SpreadMethod"/>
				<e path="flash.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ focalPointRatio : 0 }</e></m></meta>
		</beginGradientFill>
		<beginShaderFill public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</beginShaderFill>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<copyFrom public="1" set="method">
			<f a="sourceGraphics">
				<c path="flash.display.Graphics"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</copyFrom>
		<cubicCurveTo public="1" set="method">
			<f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</cubicCurveTo>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawEllipse>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawGraphicsData>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<e path="flash.display.GraphicsPathWinding"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawPath>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method">
			<f a="x:y:width:height:ellipseWidth:?ellipseHeight" v=":::::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ellipseHeight : 0 }</e></m></meta>
		</drawRoundRect>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRectComplex>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><x path="Float"/></c>
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<e path="flash.display.TriangleCulling"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawTriangles>
		<endFill public="1" set="method"><f a=""><x path="Void"/></f></endFill>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth" v="::true:false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ smooth : false, repeat : true }</e></m>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</lineBitmapStyle>
		<lineGradientStyle public="1" set="method">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v=":::::::0">
				<e path="flash.display.GradientType"/>
				<c path="Array"><x path="UInt"/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="flash.geom.Matrix"/>
				<e path="flash.display.SpreadMethod"/>
				<e path="flash.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ focalPointRatio : 0 }</e></m></meta>
		</lineGradientStyle>
		<lineShaderStyle public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineShaderStyle>
		<lineStyle public="1" set="method">
			<f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit" v="0:0:1:false::::3">
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Float"/>
				<x path="Bool"/>
				<e path="flash.display.LineScaleMode"/>
				<e path="flash.display.CapsStyle"/>
				<e path="flash.display.JointStyle"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miterLimit : 3, pixelHinting : false, alpha : 1, color : 0, thickness : 0 }</e></m></meta>
		</lineStyle>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<readGraphicsData public="1" set="method">
			<f a="?recurse" v="true">
				<x path="Bool"/>
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
			</f>
			<meta>
				<m n=":value"><e>{ recurse : true }</e></m>
				<m n=":require"><e>flash11_6</e></m>
			</meta>
		</readGraphicsData>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="/usr/local/lib/haxe/std/flash/display/GraphicsPathWinding.hx">
		<EVEN_ODD/>
		<NON_ZERO/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="/usr/local/lib/haxe/std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<enum path="flash.display.InterpolationMethod" params="" file="/usr/local/lib/haxe/std/flash/display/InterpolationMethod.hx">
		<LINEAR_RGB/>
		<RGB/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="/usr/local/lib/haxe/std/flash/display/JointStyle.hx">
		<BEVEL/>
		<MITER/>
		<ROUND/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="/usr/local/lib/haxe/std/flash/display/LineScaleMode.hx">
		<HORIZONTAL/>
		<NONE/>
		<NORMAL/>
		<VERTICAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Loader" params="" file="/usr/local/lib/haxe/std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<uncaughtErrorEvents public="1" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></load>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></loadBytes>
		<unload public="1" set="method"><f a=""><x path="Void"/></f></unload>
		<unloadAndStop public="1" set="method">
			<f a="?gc" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ gc : true }</e></m>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</unloadAndStop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="/usr/local/lib/haxe/std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="UInt"/></bytesTotal>
		<childAllowsParent public="1" set="null"><x path="Bool"/></childAllowsParent>
		<childSandboxBridge public="1">
			<d/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</childSandboxBridge>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<frameRate public="1" set="null"><x path="Float"/></frameRate>
		<height public="1" set="null"><x path="Int"/></height>
		<isURLInaccessible public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<parentAllowsChild public="1" set="null"><x path="Bool"/></parentAllowsChild>
		<parentSandboxBridge public="1">
			<d/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</parentSandboxBridge>
		<sameDomain public="1" set="null"><x path="Bool"/></sameDomain>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<swfVersion public="1" set="null"><x path="UInt"/></swfVersion>
		<uncaughtErrorEvents public="1" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<url public="1" set="null"><c path="String"/></url>
		<width public="1" set="null"><x path="Int"/></width>
	</class>
	<class path="flash.display.NativeMenu" params="" file="/usr/local/lib/haxe/std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<enum path="flash.display.PixelSnapping" params="" file="/usr/local/lib/haxe/std/flash/display/PixelSnapping.hx">
		<ALWAYS/>
		<AUTO/>
		<NEVER/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Scene" params="" file="/usr/local/lib/haxe/std/flash/display/Scene.hx" extern="1">
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<name public="1" set="null"><c path="String"/></name>
		<numFrames public="1" set="null"><x path="Int"/></numFrames>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display.Shader" params="" file="/usr/local/lib/haxe/std/flash/display/Shader.hx" extern="1">
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="/usr/local/lib/haxe/std/flash/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="/usr/local/lib/haxe/std/flash/display/ShaderPrecision.hx">
		<FAST/>
		<FULL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.SpreadMethod" params="" file="/usr/local/lib/haxe/std/flash/display/SpreadMethod.hx">
		<PAD/>
		<REFLECT/>
		<REPEAT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Stage" params="" file="/usr/local/lib/haxe/std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<align public="1"><e path="flash.display.StageAlign"/></align>
		<allowsFullScreen public="1" set="null"><x path="Bool"/></allowsFullScreen>
		<allowsFullScreenInteractive public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</allowsFullScreenInteractive>
		<browserZoomFactor public="1" set="null"><x path="Float"/></browserZoomFactor>
		<color public="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</color>
		<colorCorrection public="1">
			<e path="flash.display.ColorCorrection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrection>
		<colorCorrectionSupport public="1" set="null">
			<e path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrectionSupport>
		<contentsScaleFactor public="1" set="null">
			<x path="Float"/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</contentsScaleFactor>
		<displayContextInfo public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</displayContextInfo>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<frameRate public="1"><x path="Float"/></frameRate>
		<fullScreenHeight public="1" set="null"><x path="UInt"/></fullScreenHeight>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenWidth public="1" set="null"><x path="UInt"/></fullScreenWidth>
		<mouseLock public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</mouseLock>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<showDefaultContextMenu public="1"><x path="Bool"/></showDefaultContextMenu>
		<softKeyboardRect public="1" set="null">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardRect>
		<stage3Ds public="1" set="null">
			<c path="flash.Vector"><c path="flash.display.Stage3D"/></c>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</stage3Ds>
		<stageFocusRect public="1"><x path="Bool"/></stageFocusRect>
		<stageHeight public="1"><x path="Int"/></stageHeight>
		<stageVideos public="1" set="null">
			<c path="flash.Vector"><c path="flash.media.StageVideo"/></c>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</stageVideos>
		<stageWidth public="1"><x path="Int"/></stageWidth>
		<wmodeGPU public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</wmodeGPU>
		<invalidate public="1" set="method"><f a=""><x path="Void"/></f></invalidate>
		<isFocusInaccessible public="1" set="method"><f a=""><x path="Bool"/></f></isFocusInaccessible>
	</class>
	<class path="flash.display.Stage3D" params="" file="/usr/local/lib/haxe/std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<visible public="1"><x path="Bool"/></visible>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode:?profile">
	<c path="String"/>
	<e path="flash.display3D.Context3DProfile"/>
	<x path="Void"/>
</f></requestContext3D>
		<requestContext3DMatchingProfiles public="1" set="method">
			<f a="profiles">
				<c path="flash.Vector"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash12</e></m></meta>
		</requestContext3DMatchingProfiles>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<enum path="flash.display.StageAlign" params="" file="/usr/local/lib/haxe/std/flash/display/StageAlign.hx">
		<BOTTOM/>
		<BOTTOM_LEFT/>
		<BOTTOM_RIGHT/>
		<LEFT/>
		<RIGHT/>
		<TOP/>
		<TOP_LEFT/>
		<TOP_RIGHT/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="/usr/local/lib/haxe/std/flash/display/StageDisplayState.hx">
		<FULL_SCREEN/>
		<FULL_SCREEN_INTERACTIVE/>
		<NORMAL/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="/usr/local/lib/haxe/std/flash/display/StageQuality.hx">
		<BEST/>
		<HIGH/>
		<HIGH_16X16/>
		<HIGH_16X16_LINEAR/>
		<HIGH_8X8/>
		<HIGH_8X8_LINEAR/>
		<LOW/>
		<MEDIUM/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="/usr/local/lib/haxe/std/flash/display/StageScaleMode.hx">
		<EXACT_FIT/>
		<NO_BORDER/>
		<NO_SCALE/>
		<SHOW_ALL/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="/usr/local/lib/haxe/std/flash/display/TriangleCulling.hx">
		<NEGATIVE/>
		<NONE/>
		<POSITIVE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display3D.Context3D" params="" file="/usr/local/lib/haxe/std/flash/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<supportsVideoTexture public="1" set="null" static="1"><x path="Bool"/></supportsVideoTexture>
		<backBufferHeight public="1" set="null"><x path="Int"/></backBufferHeight>
		<backBufferWidth public="1" set="null"><x path="Int"/></backBufferWidth>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<enableErrorChecking public="1"><x path="Bool"/></enableErrorChecking>
		<maxBackBufferHeight public="1"><x path="Int"/></maxBackBufferHeight>
		<maxBackBufferWidth public="1"><x path="Int"/></maxBackBufferWidth>
		<profile public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash12</e></m></meta>
		</profile>
		<totalGPUMemory public="1" set="null"><x path="Float"/></totalGPUMemory>
		<clear public="1" set="method">
			<f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask" v="0:0:0:1:1:0:0xFFFFFFFF">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mask : 0xFFFFFFFF, stencil : 0, depth : 1, alpha : 1, blue : 0, green : 0, red : 0 }</e></m></meta>
		</clear>
		<configureBackBuffer public="1" set="method">
			<f a="width:height:antiAlias:?enableDepthAndStencil:?wantsBestResolution:?wantsBestResolutionOnBrowserZoom" v=":::true:false:false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ wantsBestResolutionOnBrowserZoom : false, wantsBestResolution : false, enableDepthAndStencil : true }</e></m></meta>
		</configureBackBuffer>
		<createCubeTexture public="1" set="method">
			<f a="size:format:optimizeForRenderToTexture:?streamingLevels" v=":::0">
				<x path="Int"/>
				<e path="flash.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="flash.display3D.textures.CubeTexture"/>
			</f>
			<meta><m n=":value"><e>{ streamingLevels : 0 }</e></m></meta>
		</createCubeTexture>
		<createIndexBuffer public="1" set="method"><f a="numIndices:?bufferUsage">
	<x path="Int"/>
	<e path="flash.display3D.Context3DBufferUsage"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createRectangleTexture public="1" set="method">
			<f a="width:height:format:optimizeForRenderToTexture">
				<x path="Int"/>
				<x path="Int"/>
				<e path="flash.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<c path="flash.display3D.textures.RectangleTexture"/>
			</f>
			<meta><m n=":require"><e>flash11_8</e></m></meta>
		</createRectangleTexture>
		<createTexture public="1" set="method">
			<f a="width:height:format:optimizeForRenderToTexture:?streamingLevels" v="::::0">
				<x path="Int"/>
				<x path="Int"/>
				<e path="flash.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="flash.display3D.textures.Texture"/>
			</f>
			<meta><m n=":value"><e>{ streamingLevels : 0 }</e></m></meta>
		</createTexture>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex:?bufferUsage">
	<x path="Int"/>
	<x path="Int"/>
	<e path="flash.display3D.Context3DBufferUsage"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<createVideoTexture public="1" set="method"><f a=""><c path="flash.display3D.textures.VideoTexture"/></f></createVideoTexture>
		<dispose public="1" set="method">
			<f a="?recreate" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recreate : true }</e></m></meta>
		</dispose>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></drawToBitmapData>
		<drawTriangles public="1" set="method">
			<f a="indexBuffer:?firstIndex:?numTriangles" v=":0:-1">
				<c path="flash.display3D.IndexBuffer3D"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ numTriangles : -1, firstIndex : 0 }</e></m></meta>
		</drawTriangles>
		<present public="1" set="method"><f a=""><x path="Void"/></f></present>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<x path="Void"/>
</f></setBlendFactors>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColorMask>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<x path="Void"/>
</f></setCulling>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<x path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<x path="Void"/>
</f></setDepthTest>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<x path="Void"/>
</f></setProgram>
		<setProgramConstantsFromByteArray public="1" set="method">
			<f a="programType:firstRegister:numRegisters:data:byteArrayOffset">
				<e path="flash.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</setProgramConstantsFromByteArray>
		<setProgramConstantsFromMatrix public="1" set="method">
			<f a="programType:firstRegister:matrix:?transposedMatrix" v=":::false">
				<e path="flash.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<c path="flash.geom.Matrix3D"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ transposedMatrix : false }</e></m></meta>
		</setProgramConstantsFromMatrix>
		<setProgramConstantsFromVector public="1" set="method">
			<f a="programType:firstRegister:data:?numRegisters" v=":::-1">
				<e path="flash.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ numRegisters : -1 }</e></m></meta>
		</setProgramConstantsFromVector>
		<setRenderToBackBuffer public="1" set="method"><f a=""><x path="Void"/></f></setRenderToBackBuffer>
		<setRenderToTexture public="1" set="method">
			<f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector:?colorOutputIndex" v=":false:0:0:0">
				<c path="flash.display3D.textures.TextureBase"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ colorOutputIndex : 0, surfaceSelector : 0, antiAlias : 0, enableDepthAndStencil : false }</e></m></meta>
		</setRenderToTexture>
		<setSamplerStateAt public="1" set="method">
			<f a="sampler:wrap:filter:mipfilter">
				<x path="Int"/>
				<e path="flash.display3D.Context3DWrapMode"/>
				<e path="flash.display3D.Context3DTextureFilter"/>
				<e path="flash.display3D.Context3DMipFilter"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_6</e></m></meta>
		</setSamplerStateAt>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></setScissorRectangle>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<x path="Void"/>
</f></setStencilActions>
		<setStencilReferenceValue public="1" set="method">
			<f a="referenceValue:?readMask:?writeMask" v=":255:255">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ writeMask : 255, readMask : 255 }</e></m></meta>
		</setStencilReferenceValue>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<x path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<x path="Void"/>
</f></setTextureAt>
		<setVertexBufferAt public="1" set="method">
			<f a="index:buffer:?bufferOffset:?format" v="::0:">
				<x path="Int"/>
				<c path="flash.display3D.VertexBuffer3D"/>
				<x path="Int"/>
				<e path="flash.display3D.Context3DVertexBufferFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bufferOffset : 0 }</e></m></meta>
		</setVertexBufferAt>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="/usr/local/lib/haxe/std/flash/display3D/Context3DBlendFactor.hx">
		<DESTINATION_ALPHA/>
		<DESTINATION_COLOR/>
		<ONE/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<SOURCE_COLOR/>
		<ZERO/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DBufferUsage" params="" file="/usr/local/lib/haxe/std/flash/display3D/Context3DBufferUsage.hx">
		<DYNAMIC_DRAW/>
		<STATIC_DRAW/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash12</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="/usr/local/lib/haxe/std/flash/display3D/Context3DCompareMode.hx">
		<ALWAYS/>
		<EQUAL/>
		<GREATER/>
		<GREATER_EQUAL/>
		<LESS/>
		<LESS_EQUAL/>
		<NEVER/>
		<NOT_EQUAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DMipFilter" params="" file="/usr/local/lib/haxe/std/flash/display3D/Context3DMipFilter.hx">
		<MIPLINEAR/>
		<MIPNEAREST/>
		<MIPNONE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DProfile" params="" file="/usr/local/lib/haxe/std/flash/display3D/Context3DProfile.hx">
		<BASELINE/>
		<BASELINE_CONSTRAINED/>
		<BASELINE_EXTENDED/>
		<STANDARD/>
		<STANDARD_CONSTRAINED/>
		<STANDARD_EXTENDED/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DProgramType" params="" file="/usr/local/lib/haxe/std/flash/display3D/Context3DProgramType.hx">
		<FRAGMENT/>
		<VERTEX/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="/usr/local/lib/haxe/std/flash/display3D/Context3DStencilAction.hx">
		<DECREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<INCREMENT_WRAP/>
		<INVERT/>
		<KEEP/>
		<SET/>
		<ZERO/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFilter" params="" file="/usr/local/lib/haxe/std/flash/display3D/Context3DTextureFilter.hx">
		<ANISOTROPIC16X/>
		<ANISOTROPIC2X/>
		<ANISOTROPIC4X/>
		<ANISOTROPIC8X/>
		<LINEAR/>
		<NEAREST/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="/usr/local/lib/haxe/std/flash/display3D/Context3DTextureFormat.hx">
		<BGRA/>
		<BGRA_PACKED/>
		<BGR_PACKED/>
		<COMPRESSED/>
		<COMPRESSED_ALPHA/>
		<RGBA_HALF_FLOAT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="/usr/local/lib/haxe/std/flash/display3D/Context3DTriangleFace.hx">
		<BACK/>
		<FRONT/>
		<FRONT_AND_BACK/>
		<NONE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="/usr/local/lib/haxe/std/flash/display3D/Context3DVertexBufferFormat.hx">
		<BYTES_4/>
		<FLOAT_1/>
		<FLOAT_2/>
		<FLOAT_3/>
		<FLOAT_4/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DWrapMode" params="" file="/usr/local/lib/haxe/std/flash/display3D/Context3DWrapMode.hx">
		<CLAMP/>
		<CLAMP_U_REPEAT_V/>
		<REPEAT/>
		<REPEAT_U_CLAMP_V/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display3D.IndexBuffer3D" params="" file="/usr/local/lib/haxe/std/flash/display3D/IndexBuffer3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><x path="UInt"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.Program3D" params="" file="/usr/local/lib/haxe/std/flash/display3D/Program3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></upload>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="/usr/local/lib/haxe/std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="/usr/local/lib/haxe/std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="/usr/local/lib/haxe/std/flash/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:?async" v="::false">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ async : false }</e></m></meta>
		</uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method">
			<f a="source:side:?miplevel" v="::0">
				<c path="flash.display.BitmapData"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:side:?miplevel" v=":::0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.RectangleTexture" params="" file="/usr/local/lib/haxe/std/flash/display3D/textures/RectangleTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromBitmapData public="1" set="method"><f a="source">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="/usr/local/lib/haxe/std/flash/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:?async" v="::false">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ async : false }</e></m></meta>
		</uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method">
			<f a="source:?miplevel" v=":0">
				<c path="flash.display.BitmapData"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:?miplevel" v="::0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.VideoTexture" params="" file="/usr/local/lib/haxe/std/flash/display3D/textures/VideoTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<videoHeight public="1" set="null"><x path="Int"/></videoHeight>
		<videoWidth public="1" set="null"><x path="Int"/></videoWidth>
		<attachCamera public="1" set="method"><f a="theCamera">
	<c path="flash.media.Camera"/>
	<x path="Void"/>
</f></attachCamera>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<x path="Void"/>
</f></attachNetStream>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.errors.Error" params="" file="/usr/local/lib/haxe/std/flash/errors/Error.hx" extern="1">
		<length public="1" set="null" static="1"><x path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<x path="Class"><d/></x>
	<x path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<errorID public="1" set="null"><x path="Int"/></errorID>
		<message public="1"><d/></message>
		<name public="1"><d/></name>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<new public="1" set="method">
			<f a="?message:?id" v=":0">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0 }</e></m></meta>
		</new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.events.Event" params="" file="/usr/local/lib/haxe/std/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" set="null" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" set="null" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" set="null" static="1"><c path="String"/></ADDED_TO_STAGE>
		<BROWSER_ZOOM_CHANGE public="1" set="null" static="1"><c path="String"/></BROWSER_ZOOM_CHANGE>
		<CANCEL public="1" set="null" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" set="null" static="1"><c path="String"/></CHANGE>
		<CHANNEL_MESSAGE public="1" set="null" static="1"><c path="String"/></CHANNEL_MESSAGE>
		<CHANNEL_STATE public="1" set="null" static="1"><c path="String"/></CHANNEL_STATE>
		<CLEAR public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CLEAR>
		<CLOSE public="1" set="null" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" set="null" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" set="null" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</CONTEXT3D_CREATE>
		<COPY public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</COPY>
		<CUT public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CUT>
		<DEACTIVATE public="1" set="null" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" set="null" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</FRAME_CONSTRUCTED>
		<FRAME_LABEL public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</FRAME_LABEL>
		<FULLSCREEN public="1" set="null" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" set="null" static="1"><c path="String"/></ID3>
		<INIT public="1" set="null" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" set="null" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" set="null" static="1"><c path="String"/></OPEN>
		<PASTE public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</PASTE>
		<REMOVED public="1" set="null" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" set="null" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" set="null" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" set="null" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" set="null" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" set="null" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</SELECT_ALL>
		<SOUND_COMPLETE public="1" set="null" static="1"><c path="String"/></SOUND_COMPLETE>
		<SUSPEND public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</SUSPEND>
		<TAB_CHILDREN_CHANGE public="1" set="null" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" set="null" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" set="null" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXTURE_READY public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</TEXTURE_READY>
		<TEXT_INTERACTION_MODE_CHANGE public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD public="1" set="null" static="1"><c path="String"/></UNLOAD>
		<VIDEO_FRAME public="1" set="null" static="1"><c path="String"/></VIDEO_FRAME>
		<WORKER_STATE public="1" set="null" static="1"><c path="String"/></WORKER_STATE>
		<bubbles public="1" set="null"><x path="Bool"/></bubbles>
		<cancelable public="1" set="null"><x path="Bool"/></cancelable>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<target public="1" set="null"><d/></target>
		<type public="1" set="null"><c path="String"/></type>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<isDefaultPrevented public="1" set="method"><f a=""><x path="Bool"/></f></isDefaultPrevented>
		<preventDefault public="1" set="method"><f a=""><x path="Void"/></f></preventDefault>
		<stopImmediatePropagation public="1" set="method"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1" set="method"><f a=""><x path="Void"/></f></stopPropagation>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable" v=":false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.TextEvent" params="" file="/usr/local/lib/haxe/std/flash/events/TextEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<LINK public="1" set="null" static="1"><c path="String"/></LINK>
		<TEXT_INPUT public="1" set="null" static="1"><c path="String"/></TEXT_INPUT>
		<text public="1"><c path="String"/></text>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?text" v=":false:false:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cancelable : false, bubbles : false }</e></m></meta>
		</new>
	</class>
	<class path="flash.events.ErrorEvent" params="" file="/usr/local/lib/haxe/std/flash/events/ErrorEvent.hx" extern="1">
		<extends path="flash.events.TextEvent"/>
		<ERROR public="1" set="null" static="1"><c path="String"/></ERROR>
		<errorID public="1" set="null">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</errorID>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?text:?id" v=":false:false::0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
	</class>
	<enum path="flash.events.EventPhase" params="" file="/usr/local/lib/haxe/std/flash/events/EventPhase.hx">
		<AT_TARGET/>
		<BUBBLING_PHASE/>
		<CAPTURING_PHASE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>UInt</e></m>
		</meta>
	</enum>
	<class path="flash.events.FocusEvent" params="" file="/usr/local/lib/haxe/std/flash/events/FocusEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<FOCUS_IN public="1" set="null" static="1"><c path="String"/></FOCUS_IN>
		<FOCUS_OUT public="1" set="null" static="1"><c path="String"/></FOCUS_OUT>
		<KEY_FOCUS_CHANGE public="1" set="null" static="1"><c path="String"/></KEY_FOCUS_CHANGE>
		<MOUSE_FOCUS_CHANGE public="1" set="null" static="1"><c path="String"/></MOUSE_FOCUS_CHANGE>
		<isRelatedObjectInaccessible public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isRelatedObjectInaccessible>
		<keyCode public="1"><x path="UInt"/></keyCode>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?relatedObject:?shiftKey:?keyCode" v=":true:false::false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flash.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ keyCode : 0, shiftKey : false, cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.IOErrorEvent" params="" file="/usr/local/lib/haxe/std/flash/events/IOErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<DISK_ERROR public="1" set="null" static="1"><c path="String"/></DISK_ERROR>
		<IO_ERROR public="1" set="null" static="1"><c path="String"/></IO_ERROR>
		<NETWORK_ERROR public="1" set="null" static="1"><c path="String"/></NETWORK_ERROR>
		<VERIFY_ERROR public="1" set="null" static="1"><c path="String"/></VERIFY_ERROR>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?text:?id" v=":false:false::0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.KeyboardEvent" params="" file="/usr/local/lib/haxe/std/flash/events/KeyboardEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<KEY_DOWN public="1" set="null" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" set="null" static="1"><c path="String"/></KEY_UP>
		<altKey public="1"><x path="Bool"/></altKey>
		<charCode public="1"><x path="UInt"/></charCode>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<keyCode public="1"><x path="UInt"/></keyCode>
		<keyLocation public="1"><e path="flash.ui.KeyLocation"/></keyLocation>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<updateAfterEvent public="1" set="method"><f a=""><x path="Void"/></f></updateAfterEvent>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue" v=":true:false:0:0:0:false:false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<e path="flash.ui.KeyLocation"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shiftKeyValue : false, altKeyValue : false, ctrlKeyValue : false, keyLocationValue : 0, keyCodeValue : 0, charCodeValue : 0, cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.MouseEvent" params="" file="/usr/local/lib/haxe/std/flash/events/MouseEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<CLICK public="1" set="null" static="1"><c path="String"/></CLICK>
		<CONTEXT_MENU public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</CONTEXT_MENU>
		<DOUBLE_CLICK public="1" set="null" static="1"><c path="String"/></DOUBLE_CLICK>
		<MIDDLE_CLICK public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_UP>
		<MOUSE_DOWN public="1" set="null" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" set="null" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" set="null" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" set="null" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" set="null" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" set="null" static="1"><c path="String"/></MOUSE_WHEEL>
		<RELEASE_OUTSIDE public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</RELEASE_OUTSIDE>
		<RIGHT_CLICK public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_UP>
		<ROLL_OUT public="1" set="null" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" set="null" static="1"><c path="String"/></ROLL_OVER>
		<altKey public="1"><x path="Bool"/></altKey>
		<buttonDown public="1"><x path="Bool"/></buttonDown>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<delta public="1"><x path="Int"/></delta>
		<isRelatedObjectInaccessible public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isRelatedObjectInaccessible>
		<localX public="1"><x path="Float"/></localX>
		<localY public="1"><x path="Float"/></localY>
		<movementX public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementX>
		<movementY public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementY>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<stageX public="1" set="null"><x path="Float"/></stageX>
		<stageY public="1" set="null"><x path="Float"/></stageY>
		<updateAfterEvent public="1" set="method"><f a=""><x path="Void"/></f></updateAfterEvent>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta" v=":true:false:0:0::false:false:false:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flash.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ delta : 0, buttonDown : false, shiftKey : false, altKey : false, ctrlKey : false, localY : 0, localX : 0, cancelable : false, bubbles : true }</e></m></meta>
		</new>
	</class>
	<class path="flash.events.ProgressEvent" params="" file="/usr/local/lib/haxe/std/flash/events/ProgressEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<PROGRESS public="1" set="null" static="1"><c path="String"/></PROGRESS>
		<SOCKET_DATA public="1" set="null" static="1"><c path="String"/></SOCKET_DATA>
		<bytesLoaded public="1"><x path="Float"/></bytesLoaded>
		<bytesTotal public="1"><x path="Float"/></bytesTotal>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?bytesLoaded:?bytesTotal" v=":false:false:0:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bytesTotal : 0, bytesLoaded : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.TouchEvent" params="" file="/usr/local/lib/haxe/std/flash/events/TouchEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<PROXIMITY_BEGIN public="1" set="null" static="1"><c path="String"/></PROXIMITY_BEGIN>
		<PROXIMITY_END public="1" set="null" static="1"><c path="String"/></PROXIMITY_END>
		<PROXIMITY_MOVE public="1" set="null" static="1"><c path="String"/></PROXIMITY_MOVE>
		<PROXIMITY_OUT public="1" set="null" static="1"><c path="String"/></PROXIMITY_OUT>
		<PROXIMITY_OVER public="1" set="null" static="1"><c path="String"/></PROXIMITY_OVER>
		<PROXIMITY_ROLL_OUT public="1" set="null" static="1"><c path="String"/></PROXIMITY_ROLL_OUT>
		<PROXIMITY_ROLL_OVER public="1" set="null" static="1"><c path="String"/></PROXIMITY_ROLL_OVER>
		<TOUCH_BEGIN public="1" set="null" static="1"><c path="String"/></TOUCH_BEGIN>
		<TOUCH_END public="1" set="null" static="1"><c path="String"/></TOUCH_END>
		<TOUCH_MOVE public="1" set="null" static="1"><c path="String"/></TOUCH_MOVE>
		<TOUCH_OUT public="1" set="null" static="1"><c path="String"/></TOUCH_OUT>
		<TOUCH_OVER public="1" set="null" static="1"><c path="String"/></TOUCH_OVER>
		<TOUCH_ROLL_OUT public="1" set="null" static="1"><c path="String"/></TOUCH_ROLL_OUT>
		<TOUCH_ROLL_OVER public="1" set="null" static="1"><c path="String"/></TOUCH_ROLL_OVER>
		<TOUCH_TAP public="1" set="null" static="1"><c path="String"/></TOUCH_TAP>
		<altKey public="1"><x path="Bool"/></altKey>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<isPrimaryTouchPoint public="1"><x path="Bool"/></isPrimaryTouchPoint>
		<isRelatedObjectInaccessible public="1"><x path="Bool"/></isRelatedObjectInaccessible>
		<localX public="1"><x path="Float"/></localX>
		<localY public="1"><x path="Float"/></localY>
		<pressure public="1"><x path="Float"/></pressure>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<sizeX public="1"><x path="Float"/></sizeX>
		<sizeY public="1"><x path="Float"/></sizeY>
		<stageX public="1" set="null"><x path="Float"/></stageX>
		<stageY public="1" set="null"><x path="Float"/></stageY>
		<touchPointID public="1"><x path="Int"/></touchPointID>
		<updateAfterEvent public="1" set="method"><f a=""><x path="Void"/></f></updateAfterEvent>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?touchPointID:?isPrimaryTouchPoint:?localX:?localY:?sizeX:?sizeY:?pressure:?relatedObject:?ctrlKey:?altKey:?shiftKey" v=":true:false:0:false:0.:0.:0.:0.:0.::false:false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flash.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shiftKey : false, altKey : false, ctrlKey : false, pressure : 0., sizeY : 0., sizeX : 0., localY : 0., localX : 0., isPrimaryTouchPoint : false, touchPointID : 0, cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="/usr/local/lib/haxe/std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.external.ExternalInterface" params="" file="/usr/local/lib/haxe/std/flash/external/ExternalInterface.hx" extern="1">
		<available public="1" set="null" static="1"><x path="Bool"/></available>
		<marshallExceptions public="1" static="1"><x path="Bool"/></marshallExceptions>
		<objectID public="1" set="null" static="1"><c path="String"/></objectID>
		<addCallback public="1" set="method" static="1"><f a="functionName:closure">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></addCallback>
		<call public="1" set="method" static="1"><f a="functionName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></call>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="/usr/local/lib/haxe/std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.filters.GlowFilter" params="" file="/usr/local/lib/haxe/std/flash/filters/GlowFilter.hx" extern="1">
		<extends path="flash.filters.BitmapFilter"/>
		<alpha public="1"><x path="Float"/></alpha>
		<blurX public="1"><x path="Float"/></blurX>
		<blurY public="1"><x path="Float"/></blurY>
		<color public="1"><x path="UInt"/></color>
		<inner public="1"><x path="Bool"/></inner>
		<knockout public="1"><x path="Bool"/></knockout>
		<quality public="1"><x path="Int"/></quality>
		<strength public="1"><x path="Float"/></strength>
		<new public="1" set="method">
			<f a="?color:?alpha:?blurX:?blurY:?strength:?quality:?inner:?knockout" v="16711680:1:6:6:2:1:false:false">
				<x path="UInt"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ knockout : false, inner : false, quality : 1, strength : 2, blurY : 6, blurX : 6, alpha : 1, color : 16711680 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="/usr/local/lib/haxe/std/flash/geom/ColorTransform.hx" extern="1">
		<alphaMultiplier public="1"><x path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><x path="Float"/></alphaOffset>
		<blueMultiplier public="1"><x path="Float"/></blueMultiplier>
		<blueOffset public="1"><x path="Float"/></blueOffset>
		<color public="1"><x path="UInt"/></color>
		<greenMultiplier public="1"><x path="Float"/></greenMultiplier>
		<greenOffset public="1"><x path="Float"/></greenOffset>
		<redMultiplier public="1"><x path="Float"/></redMultiplier>
		<redOffset public="1"><x path="Float"/></redOffset>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></concat>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset" v="1:1:1:1:0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alphaOffset : 0, blueOffset : 0, greenOffset : 0, redOffset : 0, alphaMultiplier : 1, blueMultiplier : 1, greenMultiplier : 1, redMultiplier : 1 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.geom.Matrix" params="" file="/usr/local/lib/haxe/std/flash/geom/Matrix.hx" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></concat>
		<copyColumnFrom public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<copyColumnTo public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyFrom public="1" set="method">
			<f a="sourceMatrix">
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyRowFrom public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRowTo public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<createBox public="1" set="method">
			<f a="scaleX:scaleY:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
		</createBox>
		<createGradientBox public="1" set="method">
			<f a="width:height:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
		</createGradientBox>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<invert public="1" set="method"><f a=""><x path="Void"/></f></invert>
		<rotate public="1" set="method"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<scale public="1" set="method"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<setTo public="1" set="method">
			<f a="aa:ba:ca:da:txa:tya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<translate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<new public="1" set="method">
			<f a="?a:?b:?c:?d:?tx:?ty" v="1:0:0:1:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, d : 1, c : 0, b : 0, a : 1 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="/usr/local/lib/haxe/std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<determinant public="1" set="null"><x path="Float"/></determinant>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<rawData public="1"><c path="flash.Vector"><x path="Float"/></c></rawData>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></appendRotation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<copyColumnFrom public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<copyColumnTo public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyFrom public="1" set="method">
			<f a="sourceMatrix3D">
				<c path="flash.geom.Matrix3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyRawDataFrom public="1" set="method">
			<f a="vector:?index:?transpose" v=":0:false">
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ transpose : false, index : 0 }</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</copyRawDataFrom>
		<copyRawDataTo public="1" set="method">
			<f a="vector:?index:?transpose" v=":0:false">
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ transpose : false, index : 0 }</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</copyRawDataTo>
		<copyRowFrom public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRowTo public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyToMatrix3D public="1" set="method">
			<f a="dest">
				<c path="flash.geom.Matrix3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyToMatrix3D>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<invert public="1" set="method"><f a=""><x path="Bool"/></f></invert>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></pointAt>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></prependRotation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<x path="Bool"/>
</f></recompose>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><x path="Float"/></c>
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></transformVectors>
		<transpose public="1" set="method"><f a=""><x path="Void"/></f></transpose>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="/usr/local/lib/haxe/std/flash/geom/Orientation3D.hx">
		<AXIS_ANGLE/>
		<EULER_ANGLES/>
		<QUATERNION/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.geom.PerspectiveProjection" params="" file="/usr/local/lib/haxe/std/flash/geom/PerspectiveProjection.hx" extern="1">
		<fieldOfView public="1"><x path="Float"/></fieldOfView>
		<focalLength public="1"><x path="Float"/></focalLength>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Point" params="" file="/usr/local/lib/haxe/std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<length public="1" set="null"><x path="Float"/></length>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<copyFrom public="1" set="method">
			<f a="sourcePoint">
				<c path="flash.geom.Point"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></equals>
		<normalize public="1" set="method"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<setTo public="1" set="method">
			<f a="xa:ya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.geom.Rectangle" params="" file="/usr/local/lib/haxe/std/flash/geom/Rectangle.hx" extern="1">
		<bottom public="1"><x path="Float"/></bottom>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<height public="1"><x path="Float"/></height>
		<left public="1"><x path="Float"/></left>
		<right public="1"><x path="Float"/></right>
		<size public="1"><c path="flash.geom.Point"/></size>
		<top public="1"><x path="Float"/></top>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<contains public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<copyFrom public="1" set="method">
			<f a="sourceRect">
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<inflate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method"><f a=""><x path="Bool"/></f></isEmpty>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method"><f a=""><x path="Void"/></f></setEmpty>
		<setTo public="1" set="method">
			<f a="xa:ya:widtha:heighta">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<new public="1" set="method">
			<f a="?x:?y:?width:?height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 0, width : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.geom.Transform" params="" file="/usr/local/lib/haxe/std/flash/geom/Transform.hx" extern="1">
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<matrix3D public="1">
			<c path="flash.geom.Matrix3D"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</matrix3D>
		<perspectiveProjection public="1">
			<c path="flash.geom.PerspectiveProjection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</perspectiveProjection>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<getRelativeMatrix3D public="1" set="method">
			<f a="relativeTo">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Matrix3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getRelativeMatrix3D>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="/usr/local/lib/haxe/std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" set="null" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" set="null" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" set="null" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></distance>
		<length public="1" set="null"><x path="Float"/></length>
		<lengthSquared public="1" set="null"><x path="Float"/></lengthSquared>
		<w public="1"><x path="Float"/></w>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<copyFrom public="1" set="method">
			<f a="sourceVector3D">
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<equals public="1" set="method">
			<f a="toCompare:?allFour" v=":false">
				<c path="flash.geom.Vector3D"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
		</equals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<nearEquals public="1" set="method">
			<f a="toCompare:tolerance:?allFour" v="::false">
				<c path="flash.geom.Vector3D"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
		</nearEquals>
		<negate public="1" set="method"><f a=""><x path="Void"/></f></negate>
		<normalize public="1" set="method"><f a=""><x path="Float"/></f></normalize>
		<project public="1" set="method"><f a=""><x path="Void"/></f></project>
		<scaleBy public="1" set="method"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<setTo public="1" set="method">
			<f a="xa:ya:za">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="?x:?y:?z:?w" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 0, z : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.AVCaptionStyle" params="" file="/usr/local/lib/haxe/std/flash/media/AVCaptionStyle.hx" extern="1">
		<BLACK public="1" set="null" static="1"><c path="String"/></BLACK>
		<BLUE public="1" set="null" static="1"><c path="String"/></BLUE>
		<BRIGHT_BLUE public="1" set="null" static="1"><c path="String"/></BRIGHT_BLUE>
		<BRIGHT_CYAN public="1" set="null" static="1"><c path="String"/></BRIGHT_CYAN>
		<BRIGHT_GREEN public="1" set="null" static="1"><c path="String"/></BRIGHT_GREEN>
		<BRIGHT_MAGENTA public="1" set="null" static="1"><c path="String"/></BRIGHT_MAGENTA>
		<BRIGHT_RED public="1" set="null" static="1"><c path="String"/></BRIGHT_RED>
		<BRIGHT_WHITE public="1" set="null" static="1"><c path="String"/></BRIGHT_WHITE>
		<BRIGHT_YELLOW public="1" set="null" static="1"><c path="String"/></BRIGHT_YELLOW>
		<CASUAL public="1" set="null" static="1"><c path="String"/></CASUAL>
		<CURSIVE public="1" set="null" static="1"><c path="String"/></CURSIVE>
		<CYAN public="1" set="null" static="1"><c path="String"/></CYAN>
		<DARK_BLUE public="1" set="null" static="1"><c path="String"/></DARK_BLUE>
		<DARK_CYAN public="1" set="null" static="1"><c path="String"/></DARK_CYAN>
		<DARK_GREEN public="1" set="null" static="1"><c path="String"/></DARK_GREEN>
		<DARK_MAGENTA public="1" set="null" static="1"><c path="String"/></DARK_MAGENTA>
		<DARK_RED public="1" set="null" static="1"><c path="String"/></DARK_RED>
		<DARK_YELLOW public="1" set="null" static="1"><c path="String"/></DARK_YELLOW>
		<DEFAULT public="1" set="null" static="1"><c path="String"/></DEFAULT>
		<DEPRESSED public="1" set="null" static="1"><c path="String"/></DEPRESSED>
		<GRAY public="1" set="null" static="1"><c path="String"/></GRAY>
		<GREEN public="1" set="null" static="1"><c path="String"/></GREEN>
		<LARGE public="1" set="null" static="1"><c path="String"/></LARGE>
		<LEFT_DROP_SHADOW public="1" set="null" static="1"><c path="String"/></LEFT_DROP_SHADOW>
		<MAGENTA public="1" set="null" static="1"><c path="String"/></MAGENTA>
		<MEDIUM public="1" set="null" static="1"><c path="String"/></MEDIUM>
		<MONOSPACED_WITHOUT_SERIFS public="1" set="null" static="1"><c path="String"/></MONOSPACED_WITHOUT_SERIFS>
		<MONOSPACE_WITH_SERIFS public="1" set="null" static="1"><c path="String"/></MONOSPACE_WITH_SERIFS>
		<NONE public="1" set="null" static="1"><c path="String"/></NONE>
		<PROPORTIONAL_WITHOUT_SERIFS public="1" set="null" static="1"><c path="String"/></PROPORTIONAL_WITHOUT_SERIFS>
		<PROPORTIONAL_WITH_SERIFS public="1" set="null" static="1"><c path="String"/></PROPORTIONAL_WITH_SERIFS>
		<RAISED public="1" set="null" static="1"><c path="String"/></RAISED>
		<RED public="1" set="null" static="1"><c path="String"/></RED>
		<RIGHT_DROP_SHADOW public="1" set="null" static="1"><c path="String"/></RIGHT_DROP_SHADOW>
		<SMALL public="1" set="null" static="1"><c path="String"/></SMALL>
		<SMALL_CAPITALS public="1" set="null" static="1"><c path="String"/></SMALL_CAPITALS>
		<UNIFORM public="1" set="null" static="1"><c path="String"/></UNIFORM>
		<WHITE public="1" set="null" static="1"><c path="String"/></WHITE>
		<YELLOW public="1" set="null" static="1"><c path="String"/></YELLOW>
		<backgroundColor public="1"><c path="String"/></backgroundColor>
		<backgroundOpacity public="1"><c path="String"/></backgroundOpacity>
		<bottomInset public="1"><c path="String"/></bottomInset>
		<edgeColor public="1"><c path="String"/></edgeColor>
		<fillColor public="1"><c path="String"/></fillColor>
		<fillOpacity public="1"><c path="String"/></fillOpacity>
		<font public="1"><c path="String"/></font>
		<fontColor public="1"><c path="String"/></fontColor>
		<fontEdge public="1"><c path="String"/></fontEdge>
		<fontOpacity public="1"><c path="String"/></fontOpacity>
		<size public="1"><c path="String"/></size>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVPlayState" params="" file="/usr/local/lib/haxe/std/flash/media/AVPlayState.hx" extern="1">
		<BUFFERING public="1" set="null" static="1"><x path="Int"/></BUFFERING>
		<EOF public="1" set="null" static="1"><x path="Int"/></EOF>
		<PAUSED public="1" set="null" static="1"><x path="Int"/></PAUSED>
		<PLAYING public="1" set="null" static="1"><x path="Int"/></PLAYING>
		<READY public="1" set="null" static="1"><x path="Int"/></READY>
		<SUSPENDED public="1" set="null" static="1"><x path="Int"/></SUSPENDED>
		<TRICK_PLAY public="1" set="null" static="1"><x path="Int"/></TRICK_PLAY>
		<UNINITIALIZED public="1" set="null" static="1"><x path="Int"/></UNINITIALIZED>
		<UNRECOVERABLE_ERROR public="1" set="null" static="1"><x path="Int"/></UNRECOVERABLE_ERROR>
		<state public="1" set="null"><x path="Int"/></state>
		<new public="1" set="method"><f a="state">
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVResult" params="" file="/usr/local/lib/haxe/std/flash/media/AVResult.hx" extern="1">
		<ASYNC_OPERATION_IN_PROGRESS public="1" set="null" static="1"><x path="Int"/></ASYNC_OPERATION_IN_PROGRESS>
		<AUDIO_ONLY_STREAM_END public="1" set="null" static="1"><x path="Int"/></AUDIO_ONLY_STREAM_END>
		<AUDIO_ONLY_STREAM_START public="1" set="null" static="1"><x path="Int"/></AUDIO_ONLY_STREAM_START>
		<AUDIO_START_ERROR public="1" set="null" static="1"><x path="Int"/></AUDIO_START_ERROR>
		<BAD_MANIFEST_SIGNATURE public="1" set="null" static="1"><x path="Int"/></BAD_MANIFEST_SIGNATURE>
		<BAD_MEDIASAMPLE_FOUND public="1" set="null" static="1"><x path="Int"/></BAD_MEDIASAMPLE_FOUND>
		<BAD_MEDIA_INTERLEAVING public="1" set="null" static="1"><x path="Int"/></BAD_MEDIA_INTERLEAVING>
		<CALLED_FROM_WRONG_THREAD public="1" set="null" static="1"><x path="Int"/></CALLED_FROM_WRONG_THREAD>
		<CANNOT_ERASE_TIMELINE public="1" set="null" static="1"><x path="Int"/></CANNOT_ERASE_TIMELINE>
		<CANNOT_FAIL_OVER public="1" set="null" static="1"><x path="Int"/></CANNOT_FAIL_OVER>
		<CANNOT_HANDLE_MAIN_MANIFEST_UPDATE public="1" set="null" static="1"><x path="Int"/></CANNOT_HANDLE_MAIN_MANIFEST_UPDATE>
		<CANNOT_LOAD_PLAY_LIST public="1" set="null" static="1"><x path="Int"/></CANNOT_LOAD_PLAY_LIST>
		<CANNOT_SPLIT_TIMELINE public="1" set="null" static="1"><x path="Int"/></CANNOT_SPLIT_TIMELINE>
		<CODEC_NOT_SUPPORTED public="1" set="null" static="1"><x path="Int"/></CODEC_NOT_SUPPORTED>
		<COMPONENT_CREATION_FAILURE public="1" set="null" static="1"><x path="Int"/></COMPONENT_CREATION_FAILURE>
		<CONTAINER_NOT_SUPPORTED public="1" set="null" static="1"><x path="Int"/></CONTAINER_NOT_SUPPORTED>
		<CONTENT_LENGTH_MISMATCH public="1" set="null" static="1"><x path="Int"/></CONTENT_LENGTH_MISMATCH>
		<CRYPTO_ALGORITHM_NOT_SUPPORTED public="1" set="null" static="1"><x path="Int"/></CRYPTO_ALGORITHM_NOT_SUPPORTED>
		<CRYPTO_ERROR_BAD_CERTIFICATE public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_BAD_CERTIFICATE>
		<CRYPTO_ERROR_BAD_PARAMETER public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_BAD_PARAMETER>
		<CRYPTO_ERROR_BUFFER_TOO_SMALL public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_BUFFER_TOO_SMALL>
		<CRYPTO_ERROR_CORRUPTED_DATA public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_CORRUPTED_DATA>
		<CRYPTO_ERROR_DIGEST_FINISH public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_DIGEST_FINISH>
		<CRYPTO_ERROR_DIGEST_UPDATE public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_DIGEST_UPDATE>
		<CRYPTO_ERROR_UNKNOWN public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_UNKNOWN>
		<CURRENT_PERIOD_EXPIRED public="1" set="null" static="1"><x path="Int"/></CURRENT_PERIOD_EXPIRED>
		<DECODER_FAILED public="1" set="null" static="1"><x path="Int"/></DECODER_FAILED>
		<DEVICE_OPEN_ERROR public="1" set="null" static="1"><x path="Int"/></DEVICE_OPEN_ERROR>
		<DID_NOT_GET_NEXT_FRAGMENT public="1" set="null" static="1"><x path="Int"/></DID_NOT_GET_NEXT_FRAGMENT>
		<DRM_INIT_ERROR public="1" set="null" static="1"><x path="Int"/></DRM_INIT_ERROR>
		<DRM_NOT_AVAILABLE public="1" set="null" static="1"><x path="Int"/></DRM_NOT_AVAILABLE>
		<END_OF_PERIOD public="1" set="null" static="1"><x path="Int"/></END_OF_PERIOD>
		<EOF public="1" set="null" static="1"><x path="Int"/></EOF>
		<FILE_NOT_FOUND public="1" set="null" static="1"><x path="Int"/></FILE_NOT_FOUND>
		<FILE_OPEN_ERROR public="1" set="null" static="1"><x path="Int"/></FILE_OPEN_ERROR>
		<FILE_READ_ERROR public="1" set="null" static="1"><x path="Int"/></FILE_READ_ERROR>
		<FILE_STRUCTURE_INVALID public="1" set="null" static="1"><x path="Int"/></FILE_STRUCTURE_INVALID>
		<FILE_WRITE_ERROR public="1" set="null" static="1"><x path="Int"/></FILE_WRITE_ERROR>
		<FRAGMENT_READ_ERROR public="1" set="null" static="1"><x path="Int"/></FRAGMENT_READ_ERROR>
		<GENERIC_ERROR public="1" set="null" static="1"><x path="Int"/></GENERIC_ERROR>
		<HTTP_TIME_OUT public="1" set="null" static="1"><x path="Int"/></HTTP_TIME_OUT>
		<ID3_PARSE_ERROR public="1" set="null" static="1"><x path="Int"/></ID3_PARSE_ERROR>
		<INCOMPATIBLE_RENDER_MODE public="1" set="null" static="1"><x path="Int"/></INCOMPATIBLE_RENDER_MODE>
		<INCOMPATIBLE_VERSION public="1" set="null" static="1"><x path="Int"/></INCOMPATIBLE_VERSION>
		<INTERNAL_ERROR public="1" set="null" static="1"><x path="Int"/></INTERNAL_ERROR>
		<INVALID_KEY public="1" set="null" static="1"><x path="Int"/></INVALID_KEY>
		<INVALID_OPERATION public="1" set="null" static="1"><x path="Int"/></INVALID_OPERATION>
		<INVALID_PARAMETER public="1" set="null" static="1"><x path="Int"/></INVALID_PARAMETER>
		<INVALID_REPLACE_DURATION public="1" set="null" static="1"><x path="Int"/></INVALID_REPLACE_DURATION>
		<INVALID_SEEK_TIME public="1" set="null" static="1"><x path="Int"/></INVALID_SEEK_TIME>
		<INVALID_WITH_AUDIO_ONLY_FILE public="1" set="null" static="1"><x path="Int"/></INVALID_WITH_AUDIO_ONLY_FILE>
		<IRRECOVERABLE_ERROR public="1" set="null" static="1"><x path="Int"/></IRRECOVERABLE_ERROR>
		<KEY_NOT_FOUND public="1" set="null" static="1"><x path="Int"/></KEY_NOT_FOUND>
		<KEY_SERVER_NOT_FOUND public="1" set="null" static="1"><x path="Int"/></KEY_SERVER_NOT_FOUND>
		<LISTENER_NOT_FOUND public="1" set="null" static="1"><x path="Int"/></LISTENER_NOT_FOUND>
		<LIVE_HOLD public="1" set="null" static="1"><x path="Int"/></LIVE_HOLD>
		<LIVE_WINDOW_MOVED_BACKWARD public="1" set="null" static="1"><x path="Int"/></LIVE_WINDOW_MOVED_BACKWARD>
		<LOST_CONNECTION_RECOVERABLE public="1" set="null" static="1"><x path="Int"/></LOST_CONNECTION_RECOVERABLE>
		<MAIN_MANIFEST_UPDATE_TO_BE_HANDLED public="1" set="null" static="1"><x path="Int"/></MAIN_MANIFEST_UPDATE_TO_BE_HANDLED>
		<MANIFEST_FILE_UNEXPECTEDLY_CHANGED public="1" set="null" static="1"><x path="Int"/></MANIFEST_FILE_UNEXPECTEDLY_CHANGED>
		<NETWORK_DOWN public="1" set="null" static="1"><x path="Int"/></NETWORK_DOWN>
		<NETWORK_ERROR public="1" set="null" static="1"><x path="Int"/></NETWORK_ERROR>
		<NETWORK_UNAVAILABLE public="1" set="null" static="1"><x path="Int"/></NETWORK_UNAVAILABLE>
		<NOT_IMPLEMENTED public="1" set="null" static="1"><x path="Int"/></NOT_IMPLEMENTED>
		<NO_AUDIO_SINK public="1" set="null" static="1"><x path="Int"/></NO_AUDIO_SINK>
		<NO_FIXED_SIZE public="1" set="null" static="1"><x path="Int"/></NO_FIXED_SIZE>
		<NO_TIMELINE public="1" set="null" static="1"><x path="Int"/></NO_TIMELINE>
		<NO_USEABLE_BITRATE_PROFILE public="1" set="null" static="1"><x path="Int"/></NO_USEABLE_BITRATE_PROFILE>
		<NULL_OPERATION public="1" set="null" static="1"><x path="Int"/></NULL_OPERATION>
		<ONLY_ALLOWED_IN_PAUSED_STATE public="1" set="null" static="1"><x path="Int"/></ONLY_ALLOWED_IN_PAUSED_STATE>
		<OPERATION_ABORTED public="1" set="null" static="1"><x path="Int"/></OPERATION_ABORTED>
		<OUT_OF_MEMORY public="1" set="null" static="1"><x path="Int"/></OUT_OF_MEMORY>
		<OVERFLOW public="1" set="null" static="1"><x path="Int"/></OVERFLOW>
		<PARSE_ERROR public="1" set="null" static="1"><x path="Int"/></PARSE_ERROR>
		<PARTIAL_REPLACEMENT public="1" set="null" static="1"><x path="Int"/></PARTIAL_REPLACEMENT>
		<PERIOD_HOLD public="1" set="null" static="1"><x path="Int"/></PERIOD_HOLD>
		<PERIOD_NOT_LOADED public="1" set="null" static="1"><x path="Int"/></PERIOD_NOT_LOADED>
		<PLAYBACK_NOT_ENABLED public="1" set="null" static="1"><x path="Int"/></PLAYBACK_NOT_ENABLED>
		<POSTROLL_WITH_LIVE_NOT_ALLOWED public="1" set="null" static="1"><x path="Int"/></POSTROLL_WITH_LIVE_NOT_ALLOWED>
		<PREVIOUS_STEP_SEEK_IN_PROGRESS public="1" set="null" static="1"><x path="Int"/></PREVIOUS_STEP_SEEK_IN_PROGRESS>
		<PROTOCOL_NOT_SUPPORTED public="1" set="null" static="1"><x path="Int"/></PROTOCOL_NOT_SUPPORTED>
		<RANGE_ERROR public="1" set="null" static="1"><x path="Int"/></RANGE_ERROR>
		<RANGE_SPANS_READHEAD public="1" set="null" static="1"><x path="Int"/></RANGE_SPANS_READHEAD>
		<RENDITION_M3U8_ERROR public="1" set="null" static="1"><x path="Int"/></RENDITION_M3U8_ERROR>
		<REPLACEMENT_FAILED public="1" set="null" static="1"><x path="Int"/></REPLACEMENT_FAILED>
		<RESOURCE_NOT_SPECIFIED public="1" set="null" static="1"><x path="Int"/></RESOURCE_NOT_SPECIFIED>
		<SECURITY_ERROR public="1" set="null" static="1"><x path="Int"/></SECURITY_ERROR>
		<SEEK_FAILED public="1" set="null" static="1"><x path="Int"/></SEEK_FAILED>
		<SEGMENT_SKIPPED_ON_FAILURE public="1" set="null" static="1"><x path="Int"/></SEGMENT_SKIPPED_ON_FAILURE>
		<SIZE_UNKNOWN public="1" set="null" static="1"><x path="Int"/></SIZE_UNKNOWN>
		<SPS_PPS_FOUND_OUTSIDE_AVCC public="1" set="null" static="1"><x path="Int"/></SPS_PPS_FOUND_OUTSIDE_AVCC>
		<SUCCESS public="1" set="null" static="1"><x path="Int"/></SUCCESS>
		<SWITCH_TO_ASYMMETRIC_PROFILE public="1" set="null" static="1"><x path="Int"/></SWITCH_TO_ASYMMETRIC_PROFILE>
		<TIMELINE_TOO_SHORT public="1" set="null" static="1"><x path="Int"/></TIMELINE_TOO_SHORT>
		<UNDERFLOW public="1" set="null" static="1"><x path="Int"/></UNDERFLOW>
		<UNREPORTED_TIME_DISCONTINUITY_FOUND public="1" set="null" static="1"><x path="Int"/></UNREPORTED_TIME_DISCONTINUITY_FOUND>
		<UNSUPPORTED_CONFIGURATION public="1" set="null" static="1"><x path="Int"/></UNSUPPORTED_CONFIGURATION>
		<UNSUPPORTED_HLS_VERSION public="1" set="null" static="1"><x path="Int"/></UNSUPPORTED_HLS_VERSION>
		<UNSUPPORTED_OPERATION public="1" set="null" static="1"><x path="Int"/></UNSUPPORTED_OPERATION>
		<VIDEO_PROFILE_NOT_SUPPORTED public="1" set="null" static="1"><x path="Int"/></VIDEO_PROFILE_NOT_SUPPORTED>
		<WAITING_FOR_INIT public="1" set="null" static="1"><x path="Int"/></WAITING_FOR_INIT>
		<result public="1" set="null"><x path="Int"/></result>
		<new public="1" set="method"><f a="inResult">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVSource" params="" file="/usr/local/lib/haxe/std/flash/media/AVSource.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVStream" params="" file="/usr/local/lib/haxe/std/flash/media/AVStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<HARDWARE public="1" set="null" static="1"><c path="String"/></HARDWARE>
		<SOFTWARE public="1" set="null" static="1"><c path="String"/></SOFTWARE>
		<UNDEFINED public="1" set="null" static="1"><c path="String"/></UNDEFINED>
		<backBufferLength public="1" set="null"><x path="Float"/></backBufferLength>
		<backBufferTime public="1" get="null"><x path="Float"/></backBufferTime>
		<bufferLength public="1" set="null"><x path="Float"/></bufferLength>
		<bufferTime public="1" get="null"><x path="Float"/></bufferTime>
		<captionStyle public="1" get="null"><c path="flash.media.AVCaptionStyle"/></captionStyle>
		<captionsEnabled public="1"><x path="Bool"/></captionsEnabled>
		<clientLivePoint public="1" set="null"><x path="Float"/></clientLivePoint>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<decoderType public="1" set="null"><c path="String"/></decoderType>
		<droppedFrames public="1" set="null"><x path="Int"/></droppedFrames>
		<frameTime public="1" set="null"><x path="Float"/></frameTime>
		<initialBufferTime public="1" get="null"><x path="Float"/></initialBufferTime>
		<playState public="1" set="null"><c path="flash.media.AVPlayState"/></playState>
		<renderType public="1" set="null"><c path="String"/></renderType>
		<time public="1" set="null"><x path="Float"/></time>
		<useHardwareDecoder public="1"><x path="Bool"/></useHardwareDecoder>
		<volume public="1"><x path="Float"/></volume>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<fastForward public="1" set="method"><f a="rate">
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></fastForward>
		<pause public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></pause>
		<play public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></play>
		<resume public="1" set="method"><f a=""><x path="Bool"/></f></resume>
		<rewind public="1" set="method"><f a="rate">
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></rewind>
		<seek public="1" set="method">
			<f a="offset:?inBufferSeek" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.media.AVResult"/>
			</f>
			<meta><m n=":value"><e>{ inBufferSeek : true }</e></m></meta>
		</seek>
		<seekToKeyFrame public="1" set="method">
			<f a="offset:?inBufferSeek" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.media.AVResult"/>
			</f>
			<meta><m n=":value"><e>{ inBufferSeek : true }</e></m></meta>
		</seekToKeyFrame>
		<seekToLivePoint public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></seekToLivePoint>
		<seekToLocalTime public="1" set="method"><f a="periodIndex:time">
	<x path="Int"/>
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></seekToLocalTime>
		<setPlaySpeed public="1" set="method"><f a="speed:reserved">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPlaySpeed>
		<step public="1" set="method"><f a="frames">
	<x path="Int"/>
	<c path="flash.media.AVResult"/>
</f></step>
		<new public="1" set="method"><f a="source">
	<c path="flash.media.AVSource"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.Camera" params="" file="/usr/local/lib/haxe/std/flash/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<_scanHardware public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<activityLevel public="1" set="null"><x path="Float"/></activityLevel>
		<bandwidth public="1" set="null"><x path="Int"/></bandwidth>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<fps public="1" set="null"><x path="Float"/></fps>
		<height public="1" set="null"><x path="Int"/></height>
		<index public="1" set="null"><x path="Int"/></index>
		<keyFrameInterval public="1" set="null"><x path="Int"/></keyFrameInterval>
		<loopback public="1" set="null"><x path="Bool"/></loopback>
		<motionLevel public="1" set="null"><x path="Int"/></motionLevel>
		<motionTimeout public="1" set="null"><x path="Int"/></motionTimeout>
		<muted public="1" set="null"><x path="Bool"/></muted>
		<name public="1" set="null"><c path="String"/></name>
		<position public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</position>
		<quality public="1" set="null"><x path="Int"/></quality>
		<width public="1" set="null"><x path="Int"/></width>
		<copyToByteArray public="1" set="method">
			<f a="rect:destination">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyToByteArray>
		<copyToVector public="1" set="method">
			<f a="rect:destination">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyToVector>
		<drawToBitmapData public="1" set="method">
			<f a="destination">
				<c path="flash.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</drawToBitmapData>
		<setCursor public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setCursor>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<setLoopback public="1" set="method">
			<f a="?compress" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ compress : false }</e></m></meta>
		</setLoopback>
		<setMode public="1" set="method">
			<f a="width:height:fps:?favorArea" v=":::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ favorArea : true }</e></m></meta>
		</setMode>
		<setMotionLevel public="1" set="method">
			<f a="motionLevel:?timeout" v=":2000">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ timeout : 2000 }</e></m></meta>
		</setMotionLevel>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.ID3Info" params="" file="/usr/local/lib/haxe/std/flash/media/ID3Info.hx" extern="1">
		<album public="1"><c path="String"/></album>
		<artist public="1"><c path="String"/></artist>
		<comment public="1"><c path="String"/></comment>
		<genre public="1"><c path="String"/></genre>
		<songName public="1"><c path="String"/></songName>
		<track public="1"><c path="String"/></track>
		<year public="1"><c path="String"/></year>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.media.Microphone" params="" file="/usr/local/lib/haxe/std/flash/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getEnhancedMicrophone public="1" set="method" static="1">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta>
				<m n=":value"><e>{ index : -1 }</e></m>
				<m n=":require"><e>flash10_2</e></m>
			</meta>
		</getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta><m n=":value"><e>{ index : -1 }</e></m></meta>
		</getMicrophone>
		<activityLevel public="1" set="null"><x path="Float"/></activityLevel>
		<codec public="1">
			<e path="flash.media.SoundCodec"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</codec>
		<enableVAD public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</enableVAD>
		<encodeQuality public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</encodeQuality>
		<enhancedOptions public="1">
			<c path="flash.media.MicrophoneEnhancedOptions"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</enhancedOptions>
		<framesPerPacket public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</framesPerPacket>
		<gain public="1"><x path="Float"/></gain>
		<index public="1" set="null"><x path="Int"/></index>
		<muted public="1" set="null"><x path="Bool"/></muted>
		<name public="1" set="null"><c path="String"/></name>
		<noiseSuppressionLevel public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</noiseSuppressionLevel>
		<rate public="1"><x path="Int"/></rate>
		<silenceLevel public="1" set="null"><x path="Float"/></silenceLevel>
		<silenceTimeout public="1" set="null"><x path="Int"/></silenceTimeout>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useEchoSuppression public="1" set="null"><x path="Bool"/></useEchoSuppression>
		<setLoopBack public="1" set="method">
			<f a="?state" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : true }</e></m></meta>
		</setLoopBack>
		<setSilenceLevel public="1" set="method">
			<f a="silenceLevel:?timeout" v=":-1">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ timeout : -1 }</e></m></meta>
		</setSilenceLevel>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<x path="Bool"/>
	<x path="Void"/>
</f></setUseEchoSuppression>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="/usr/local/lib/haxe/std/flash/media/MicrophoneEnhancedMode.hx">
		<FULL_DUPLEX/>
		<HALF_DUPLEX/>
		<HEADSET/>
		<OFF/>
		<SPEAKER_MUTE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="/usr/local/lib/haxe/std/flash/media/MicrophoneEnhancedOptions.hx" extern="1">
		<autoGain public="1"><x path="Bool"/></autoGain>
		<echoPath public="1"><x path="Int"/></echoPath>
		<isVoiceDetected public="1"><x path="Int"/></isVoiceDetected>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<nonLinearProcessing public="1"><x path="Bool"/></nonLinearProcessing>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<class path="flash.media.Sound" params="" file="/usr/local/lib/haxe/std/flash/media/Sound.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="Int"/></bytesTotal>
		<id3 public="1" set="null"><c path="flash.media.ID3Info"/></id3>
		<isBuffering public="1" set="null"><x path="Bool"/></isBuffering>
		<isURLInaccessible public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<length public="1" set="null"><x path="Float"/></length>
		<url public="1" set="null"><c path="String"/></url>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<extract public="1" set="method">
			<f a="target:length:?startPosition" v="::-1">
				<c path="flash.utils.ByteArray"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":value"><e>{ startPosition : -1 }</e></m>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</extract>
		<load public="1" set="method"><f a="stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<x path="Void"/>
</f></load>
		<loadCompressedDataFromByteArray public="1" set="method">
			<f a="bytes:bytesLength">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</loadCompressedDataFromByteArray>
		<loadPCMFromByteArray public="1" set="method">
			<f a="bytes:samples:?format:?stereo:?sampleRate" v=":::true:44100">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ sampleRate : 44100, stereo : true }</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</loadPCMFromByteArray>
		<play public="1" set="method">
			<f a="?startTime:?loops:?sndTransform" v="0:0:">
				<x path="Float"/>
				<x path="Int"/>
				<c path="flash.media.SoundTransform"/>
				<c path="flash.media.SoundChannel"/>
			</f>
			<meta><m n=":value"><e>{ loops : 0, startTime : 0 }</e></m></meta>
		</play>
		<new public="1" set="method"><f a="?stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.media.SoundChannel" params="" file="/usr/local/lib/haxe/std/flash/media/SoundChannel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<leftPeak public="1" set="null"><x path="Float"/></leftPeak>
		<position public="1" set="null"><x path="Float"/></position>
		<rightPeak public="1" set="null"><x path="Float"/></rightPeak>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="/usr/local/lib/haxe/std/flash/media/SoundCodec.hx">
		<NELLYMOSER/>
		<PCMA/>
		<PCMU/>
		<SPEEX/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.media.SoundLoaderContext" params="" file="/usr/local/lib/haxe/std/flash/media/SoundLoaderContext.hx" extern="1">
		<bufferTime public="1"><x path="Float"/></bufferTime>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<new public="1" set="method">
			<f a="?bufferTime:?checkPolicyFile" v="1000:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkPolicyFile : false, bufferTime : 1000 }</e></m></meta>
		</new>
	</class>
	<class path="flash.media.SoundTransform" params="" file="/usr/local/lib/haxe/std/flash/media/SoundTransform.hx" extern="1">
		<leftToLeft public="1"><x path="Float"/></leftToLeft>
		<leftToRight public="1"><x path="Float"/></leftToRight>
		<pan public="1"><x path="Float"/></pan>
		<rightToLeft public="1"><x path="Float"/></rightToLeft>
		<rightToRight public="1"><x path="Float"/></rightToRight>
		<volume public="1"><x path="Float"/></volume>
		<new public="1" set="method">
			<f a="?vol:?panning" v="1:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ panning : 0, vol : 1 }</e></m></meta>
		</new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.StageVideo" params="" file="/usr/local/lib/haxe/std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<depth public="1"><x path="Int"/></depth>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<videoHeight public="1" set="null"><x path="Int"/></videoHeight>
		<videoWidth public="1" set="null"><x path="Int"/></videoWidth>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<attachAVStream public="1" set="method">
			<f a="avStream">
				<c path="flash.media.AVStream"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_7</e></m></meta>
		</attachAVStream>
		<attachCamera public="1" set="method">
			<f a="theCamera">
				<c path="flash.media.Camera"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</attachCamera>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<x path="Void"/>
</f></attachNetStream>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="/usr/local/lib/haxe/std/flash/media/VideoStreamSettings.hx" extern="1">
		<bandwidth public="1" set="null"><x path="Int"/></bandwidth>
		<codec public="1" set="null"><c path="String"/></codec>
		<fps public="1" set="null"><x path="Float"/></fps>
		<height public="1" set="null"><x path="Int"/></height>
		<keyFrameInterval public="1" set="null"><x path="Int"/></keyFrameInterval>
		<quality public="1" set="null"><x path="Int"/></quality>
		<width public="1" set="null"><x path="Int"/></width>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<setMode public="1" set="method"><f a="width:height:fps">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMode>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="/usr/local/lib/haxe/std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<client public="1"><d/></client>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<maxPeerConnections public="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPeerConnections>
		<nearID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearID>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<protocol public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</protocol>
		<proxyType public="1"><c path="String"/></proxyType>
		<unconnectedPeerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unconnectedPeerStreams>
		<uri public="1" set="null"><c path="String"/></uri>
		<usingTLS public="1" set="null"><x path="Bool"/></usingTLS>
		<addHeader public="1" set="method">
			<f a="operation:?mustUnderstand:?param" v=":false:">
				<c path="String"/>
				<x path="Bool"/>
				<t path="flash.utils.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mustUnderstand : false }</e></m></meta>
		</addHeader>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></call>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></connect>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="/usr/local/lib/haxe/std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</DIRECT_CONNECTIONS>
		<resetDRMVouchers public="1" set="method" static="1"><f a=""><x path="Void"/></f></resetDRMVouchers>
		<audioCodec public="1" set="null"><x path="UInt"/></audioCodec>
		<audioReliable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioReliable>
		<audioSampleAccess public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioSampleAccess>
		<backBufferLength public="1" set="null">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferLength>
		<backBufferTime public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferTime>
		<bufferLength public="1" set="null"><x path="Float"/></bufferLength>
		<bufferTime public="1"><x path="Float"/></bufferTime>
		<bufferTimeMax public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</bufferTimeMax>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="UInt"/></bytesTotal>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<client public="1"><d/></client>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<dataReliable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</dataReliable>
		<decodedFrames public="1" set="null"><x path="UInt"/></decodedFrames>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<inBufferSeek public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</inBufferSeek>
		<info public="1" set="null">
			<c path="flash.net.NetStreamInfo"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</info>
		<liveDelay public="1" set="null"><x path="Float"/></liveDelay>
		<maxPauseBufferTime public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPauseBufferTime>
		<multicastAvailabilitySendToAll public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilitySendToAll>
		<multicastAvailabilityUpdatePeriod public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilityUpdatePeriod>
		<multicastFetchPeriod public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastFetchPeriod>
		<multicastInfo public="1" set="null">
			<c path="flash.net.NetStreamMulticastInfo"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastInfo>
		<multicastPushNeighborLimit public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastPushNeighborLimit>
		<multicastRelayMarginDuration public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastRelayMarginDuration>
		<multicastWindowDuration public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastWindowDuration>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<objectEncoding public="1" set="null"><x path="UInt"/></objectEncoding>
		<peerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</peerStreams>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<time public="1" set="null"><x path="Float"/></time>
		<useHardwareDecoder public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</useHardwareDecoder>
		<useJitterBuffer public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</useJitterBuffer>
		<videoCodec public="1" set="null"><x path="UInt"/></videoCodec>
		<videoReliable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoReliable>
		<videoSampleAccess public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoSampleAccess>
		<videoStreamSettings public="1">
			<c path="flash.media.VideoStreamSettings"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</videoStreamSettings>
		<appendBytes public="1" set="method">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytes>
		<appendBytesAction public="1" set="method">
			<f a="netStreamAppendBytesAction">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytesAction>
		<attach public="1" set="method">
			<f a="connection">
				<c path="flash.net.NetConnection"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</attach>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<x path="Void"/>
</f></attachAudio>
		<attachCamera public="1" set="method">
			<f a="theCamera:?snapshotMilliseconds" v=":-1">
				<c path="flash.media.Camera"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ snapshotMilliseconds : -1 }</e></m></meta>
		</attachCamera>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<dispose public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</dispose>
		<onPeerConnect public="1" set="method">
			<f a="subscriber">
				<c path="flash.net.NetStream"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</onPeerConnect>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></play>
		<play2 public="1" set="method">
			<f a="param">
				<c path="flash.net.NetStreamPlayOptions"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</play2>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></publish>
		<receiveAudio public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveAudio>
		<receiveVideo public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveVideo>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<x path="Float"/>
	<x path="Void"/>
</f></receiveVideoFPS>
		<resume public="1" set="method"><f a=""><x path="Void"/></f></resume>
		<seek public="1" set="method"><f a="offset">
	<x path="Float"/>
	<x path="Void"/>
</f></seek>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></send>
		<step public="1" set="method">
			<f a="frames">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</step>
		<togglePause public="1" set="method"><f a=""><x path="Void"/></f></togglePause>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="/usr/local/lib/haxe/std/flash/net/NetStreamInfo.hx" extern="1">
		<SRTT public="1" set="null"><x path="Float"/></SRTT>
		<audioBufferByteLength public="1" set="null"><x path="Float"/></audioBufferByteLength>
		<audioBufferLength public="1" set="null"><x path="Float"/></audioBufferLength>
		<audioByteCount public="1" set="null"><x path="Float"/></audioByteCount>
		<audioBytesPerSecond public="1" set="null"><x path="Float"/></audioBytesPerSecond>
		<audioLossRate public="1" set="null"><x path="Float"/></audioLossRate>
		<byteCount public="1" set="null"><x path="Float"/></byteCount>
		<currentBytesPerSecond public="1" set="null"><x path="Float"/></currentBytesPerSecond>
		<dataBufferByteLength public="1" set="null"><x path="Float"/></dataBufferByteLength>
		<dataBufferLength public="1" set="null"><x path="Float"/></dataBufferLength>
		<dataByteCount public="1" set="null"><x path="Float"/></dataByteCount>
		<dataBytesPerSecond public="1" set="null"><x path="Float"/></dataBytesPerSecond>
		<droppedFrames public="1" set="null"><x path="Float"/></droppedFrames>
		<isLive public="1" set="null"><x path="Bool"/></isLive>
		<maxBytesPerSecond public="1" set="null"><x path="Float"/></maxBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<playbackBytesPerSecond public="1" set="null"><x path="Float"/></playbackBytesPerSecond>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<uri public="1" set="null"><c path="String"/></uri>
		<videoBufferByteLength public="1" set="null"><x path="Float"/></videoBufferByteLength>
		<videoBufferLength public="1" set="null"><x path="Float"/></videoBufferLength>
		<videoByteCount public="1" set="null"><x path="Float"/></videoByteCount>
		<videoBytesPerSecond public="1" set="null"><x path="Float"/></videoBytesPerSecond>
		<videoLossRate public="1" set="null">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoLossRate>
		<xmpData public="1" set="null"><d/></xmpData>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive" v="::::::::::::::::::::::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<d/>
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isLive : true }</e></m></meta>
		</new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="/usr/local/lib/haxe/std/flash/net/NetStreamMulticastInfo.hx" extern="1">
		<bytesPushedFromPeers public="1" set="null"><x path="Float"/></bytesPushedFromPeers>
		<bytesPushedToPeers public="1" set="null"><x path="Float"/></bytesPushedToPeers>
		<bytesReceivedFromIPMulticast public="1" set="null"><x path="Float"/></bytesReceivedFromIPMulticast>
		<bytesReceivedFromServer public="1" set="null"><x path="Float"/></bytesReceivedFromServer>
		<bytesRequestedByPeers public="1" set="null"><x path="Float"/></bytesRequestedByPeers>
		<bytesRequestedFromPeers public="1" set="null"><x path="Float"/></bytesRequestedFromPeers>
		<fragmentsPushedFromPeers public="1" set="null"><x path="Float"/></fragmentsPushedFromPeers>
		<fragmentsPushedToPeers public="1" set="null"><x path="Float"/></fragmentsPushedToPeers>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><x path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsReceivedFromServer public="1" set="null"><x path="Float"/></fragmentsReceivedFromServer>
		<fragmentsRequestedByPeers public="1" set="null"><x path="Float"/></fragmentsRequestedByPeers>
		<fragmentsRequestedFromPeers public="1" set="null"><x path="Float"/></fragmentsRequestedFromPeers>
		<receiveControlBytesPerSecond public="1" set="null"><x path="Float"/></receiveControlBytesPerSecond>
		<receiveDataBytesPerSecond public="1" set="null"><x path="Float"/></receiveDataBytesPerSecond>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><x path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><x path="Float"/></receiveDataBytesPerSecondFromServer>
		<sendControlBytesPerSecond public="1" set="null"><x path="Float"/></sendControlBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><x path="Float"/></sendControlBytesPerSecondToServer>
		<sendDataBytesPerSecond public="1" set="null"><x path="Float"/></sendDataBytesPerSecond>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="/usr/local/lib/haxe/std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<len public="1"><x path="Float"/></len>
		<offset public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</offset>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<start public="1"><x path="Float"/></start>
		<streamName public="1"><c path="String"/></streamName>
		<transition public="1"><c path="String"/></transition>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.net.Responder" params="" file="/usr/local/lib/haxe/std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<x path="Void"/>
</f></new></class>
	<class path="flash.net.URLRequest" params="" file="/usr/local/lib/haxe/std/flash/net/URLRequest.hx" extern="1">
		<contentType public="1"><c path="String"/></contentType>
		<data public="1"><d/></data>
		<digest public="1"><c path="String"/></digest>
		<method public="1"><c path="String"/></method>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<url public="1"><c path="String"/></url>
		<useRedirectedURL public="1" set="method">
			<f a="sourceRequest:?wholeURL:?pattern:?replace" v=":false::">
				<c path="flash.net.URLRequest"/>
				<x path="Bool"/>
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ wholeURL : false }</e></m></meta>
		</useRedirectedURL>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="/usr/local/lib/haxe/std/flash/net/URLRequestHeader.hx" extern="1">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="/usr/local/lib/haxe/std/flash/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<domainMemory public="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</domainMemory>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<t path="flash.utils.Object"/>
</f></getDefinition>
		<getQualifiedDefinitionNames public="1" set="method">
			<f a=""><c path="flash.Vector"><c path="String"/></c></f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</getQualifiedDefinitionNames>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasDefinition>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.system.Capabilities" params="" file="/usr/local/lib/haxe/std/flash/system/Capabilities.hx" extern="1">
		<_internal public="1" set="null" static="1"><x path="UInt"/></_internal>
		<avHardwareDisable public="1" set="null" static="1"><x path="Bool"/></avHardwareDisable>
		<cpuArchitecture public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</cpuArchitecture>
		<hasAccessibility public="1" set="null" static="1"><x path="Bool"/></hasAccessibility>
		<hasAudio public="1" set="null" static="1"><x path="Bool"/></hasAudio>
		<hasAudioEncoder public="1" set="null" static="1"><x path="Bool"/></hasAudioEncoder>
		<hasEmbeddedVideo public="1" set="null" static="1"><x path="Bool"/></hasEmbeddedVideo>
		<hasIME public="1" set="null" static="1"><x path="Bool"/></hasIME>
		<hasMP3 public="1" set="null" static="1"><x path="Bool"/></hasMP3>
		<hasPrinting public="1" set="null" static="1"><x path="Bool"/></hasPrinting>
		<hasScreenBroadcast public="1" set="null" static="1"><x path="Bool"/></hasScreenBroadcast>
		<hasScreenPlayback public="1" set="null" static="1"><x path="Bool"/></hasScreenPlayback>
		<hasStreamingAudio public="1" set="null" static="1"><x path="Bool"/></hasStreamingAudio>
		<hasStreamingVideo public="1" set="null" static="1"><x path="Bool"/></hasStreamingVideo>
		<hasTLS public="1" set="null" static="1"><x path="Bool"/></hasTLS>
		<hasVideoEncoder public="1" set="null" static="1"><x path="Bool"/></hasVideoEncoder>
		<isDebugger public="1" set="null" static="1"><x path="Bool"/></isDebugger>
		<isEmbeddedInAcrobat public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isEmbeddedInAcrobat>
		<language public="1" set="null" static="1"><c path="String"/></language>
		<localFileReadDisable public="1" set="null" static="1"><x path="Bool"/></localFileReadDisable>
		<manufacturer public="1" set="null" static="1"><c path="String"/></manufacturer>
		<maxLevelIDC public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxLevelIDC>
		<os public="1" set="null" static="1"><c path="String"/></os>
		<pixelAspectRatio public="1" set="null" static="1"><x path="Float"/></pixelAspectRatio>
		<playerType public="1" set="null" static="1"><c path="String"/></playerType>
		<screenColor public="1" set="null" static="1"><c path="String"/></screenColor>
		<screenDPI public="1" set="null" static="1"><x path="Float"/></screenDPI>
		<screenResolutionX public="1" set="null" static="1"><x path="Float"/></screenResolutionX>
		<screenResolutionY public="1" set="null" static="1"><x path="Float"/></screenResolutionY>
		<serverString public="1" set="null" static="1"><c path="String"/></serverString>
		<supports32BitProcesses public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</supports32BitProcesses>
		<supports64BitProcesses public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</supports64BitProcesses>
		<touchscreenType public="1" set="null" static="1">
			<e path="flash.system.TouchscreenType"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</touchscreenType>
		<version public="1" set="null" static="1"><c path="String"/></version>
		<hasMultiChannelAudio public="1" set="method" static="1">
			<f a="type">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</hasMultiChannelAudio>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="/usr/local/lib/haxe/std/flash/system/ImageDecodingPolicy.hx">
		<ON_DEMAND/>
		<ON_LOAD/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="/usr/local/lib/haxe/std/flash/system/LoaderContext.hx" extern="1">
		<allowCodeImport public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowCodeImport>
		<allowLoadBytesCodeExecution public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowLoadBytesCodeExecution>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<imageDecodingPolicy public="1">
			<e path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</imageDecodingPolicy>
		<parameters public="1">
			<d/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</parameters>
		<requestedContentParent public="1">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestedContentParent>
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<new public="1" set="method">
			<f a="?checkPolicyFile:?applicationDomain:?securityDomain" v="false::">
				<x path="Bool"/>
				<c path="flash.system.ApplicationDomain"/>
				<c path="flash.system.SecurityDomain"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkPolicyFile : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="/usr/local/lib/haxe/std/flash/system/SecurityDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain>
		<domainID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</domainID>
	</class>
	<enum path="flash.system.TouchscreenType" params="" file="/usr/local/lib/haxe/std/flash/system/TouchscreenType.hx">
		<FINGER/>
		<NONE/>
		<STYLUS/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.AntiAliasType" params="" file="/usr/local/lib/haxe/std/flash/text/AntiAliasType.hx">
		<ADVANCED/>
		<NORMAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="/usr/local/lib/haxe/std/flash/text/GridFitType.hx">
		<NONE/>
		<PIXEL/>
		<SUBPIXEL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.text.StyleSheet" params="" file="/usr/local/lib/haxe/std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<t path="flash.utils.Object"/>
</f></getStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<x path="Void"/>
</f></parseCSS>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></setStyle>
		<transform public="1" set="method"><f a="formatObject">
	<t path="flash.utils.Object"/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.text.TextField" params="" file="/usr/local/lib/haxe/std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1">
			<f a="fontName:fontStyle">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isFontCompatible>
		<alwaysShowSelection public="1"><x path="Bool"/></alwaysShowSelection>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<background public="1"><x path="Bool"/></background>
		<backgroundColor public="1"><x path="UInt"/></backgroundColor>
		<border public="1"><x path="Bool"/></border>
		<borderColor public="1"><x path="UInt"/></borderColor>
		<bottomScrollV public="1" set="null"><x path="Int"/></bottomScrollV>
		<caretIndex public="1" set="null"><x path="Int"/></caretIndex>
		<condenseWhite public="1"><x path="Bool"/></condenseWhite>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<displayAsPassword public="1"><x path="Bool"/></displayAsPassword>
		<embedFonts public="1"><x path="Bool"/></embedFonts>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<htmlText public="1"><c path="String"/></htmlText>
		<length public="1" set="null"><x path="Int"/></length>
		<maxChars public="1"><x path="Int"/></maxChars>
		<maxScrollH public="1" set="null"><x path="Int"/></maxScrollH>
		<maxScrollV public="1" set="null"><x path="Int"/></maxScrollV>
		<mouseWheelEnabled public="1"><x path="Bool"/></mouseWheelEnabled>
		<multiline public="1"><x path="Bool"/></multiline>
		<numLines public="1" set="null"><x path="Int"/></numLines>
		<restrict public="1"><c path="String"/></restrict>
		<scrollH public="1"><x path="Int"/></scrollH>
		<scrollV public="1"><x path="Int"/></scrollV>
		<selectable public="1"><x path="Bool"/></selectable>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectionBeginIndex public="1" set="null"><x path="Int"/></selectionBeginIndex>
		<selectionEndIndex public="1" set="null"><x path="Int"/></selectionEndIndex>
		<sharpness public="1"><x path="Float"/></sharpness>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<text public="1"><c path="String"/></text>
		<textColor public="1"><x path="UInt"/></textColor>
		<textHeight public="1" set="null"><x path="Float"/></textHeight>
		<textInteractionMode public="1" set="null">
			<e path="flash.text.TextInteractionMode"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</textInteractionMode>
		<textWidth public="1" set="null"><x path="Float"/></textWidth>
		<thickness public="1"><x path="Float"/></thickness>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<useRichTextClipboard public="1"><x path="Bool"/></useRichTextClipboard>
		<wordWrap public="1"><x path="Bool"/></wordWrap>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getCharIndexAtPoint>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getFirstCharInParagraph>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getLineIndexAtPoint>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineIndexOfChar>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineLength>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineOffset>
		<getLineText public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getParagraphLength>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getTextFormat public="1" set="method">
			<f a="?beginIndex:?endIndex" v="-1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.text.TextFormat"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : -1, beginIndex : -1 }</e></m></meta>
		</getTextFormat>
		<getTextRuns public="1" set="method">
			<f a="?beginIndex:?endIndex" v="0:2147483647">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":value"><e>{ endIndex : 2147483647, beginIndex : 0 }</e></m></meta>
		</getTextRuns>
		<getXMLText public="1" set="method">
			<f a="?beginIndex:?endIndex" v="0:2147483647">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : 2147483647, beginIndex : 0 }</e></m></meta>
		</getXMLText>
		<insertXMLText public="1" set="method">
			<f a="beginIndex:endIndex:richText:?pasting" v=":::false">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pasting : false }</e></m></meta>
		</insertXMLText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<x path="Bool"/>
</f></pasteRichText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></replaceSelectedText>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></replaceText>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSelection>
		<setTextFormat public="1" set="method">
			<f a="format:?beginIndex:?endIndex" v=":-1:-1">
				<c path="flash.text.TextFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : -1, beginIndex : -1 }</e></m></meta>
		</setTextFormat>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="/usr/local/lib/haxe/std/flash/text/TextFieldAutoSize.hx">
		<CENTER/>
		<LEFT/>
		<NONE/>
		<RIGHT/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="/usr/local/lib/haxe/std/flash/text/TextFieldType.hx">
		<DYNAMIC/>
		<INPUT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="/usr/local/lib/haxe/std/flash/text/TextFormat.hx" extern="1">
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<blockIndent public="1"><x path="Null"><x path="Float"/></x></blockIndent>
		<bold public="1"><x path="Null"><x path="Bool"/></x></bold>
		<bullet public="1"><x path="Null"><x path="Bool"/></x></bullet>
		<color public="1"><x path="Null"><x path="UInt"/></x></color>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<font public="1"><c path="String"/></font>
		<indent public="1"><x path="Null"><x path="Float"/></x></indent>
		<italic public="1"><x path="Null"><x path="Bool"/></x></italic>
		<kerning public="1"><x path="Null"><x path="Bool"/></x></kerning>
		<leading public="1"><x path="Null"><x path="Float"/></x></leading>
		<leftMargin public="1"><x path="Null"><x path="Float"/></x></leftMargin>
		<letterSpacing public="1"><x path="Null"><x path="Float"/></x></letterSpacing>
		<rightMargin public="1"><x path="Null"><x path="Float"/></x></rightMargin>
		<size public="1"><x path="Null"><x path="Float"/></x></size>
		<tabStops public="1"><c path="Array"><x path="UInt"/></c></tabStops>
		<target public="1"><c path="String"/></target>
		<underline public="1"><x path="Null"><x path="Bool"/></x></underline>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method">
			<f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading" v=":0:0:false:false:false::::0:0:0:0">
				<c path="String"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<e path="flash.text.TextFormatAlign"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ leading : 0, indent : 0, rightMargin : 0, leftMargin : 0, underline : false, italic : false, bold : false, color : 0, size : 0 }</e></m></meta>
		</new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="/usr/local/lib/haxe/std/flash/text/TextFormatAlign.hx">
		<CENTER/>
		<END/>
		<JUSTIFY/>
		<LEFT/>
		<RIGHT/>
		<START/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="/usr/local/lib/haxe/std/flash/text/TextFormatDisplay.hx">
		<BLOCK/>
		<INLINE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.TextInteractionMode" params="" file="/usr/local/lib/haxe/std/flash/text/TextInteractionMode.hx">
		<NORMAL/>
		<SELECTION/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="/usr/local/lib/haxe/std/flash/text/TextLineMetrics.hx" extern="1">
		<ascent public="1"><x path="Float"/></ascent>
		<descent public="1"><x path="Float"/></descent>
		<height public="1"><x path="Float"/></height>
		<leading public="1"><x path="Float"/></leading>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="/usr/local/lib/haxe/std/flash/text/TextSnapshot.hx" extern="1">
		<charCount public="1" set="null"><x path="Int"/></charCount>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></findText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getSelected>
		<getSelectedText public="1" set="method">
			<f a="?includeLineEndings" v="false">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ includeLineEndings : false }</e></m></meta>
		</getSelectedText>
		<getText public="1" set="method">
			<f a="beginIndex:endIndex:?includeLineEndings" v="::false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ includeLineEndings : false }</e></m></meta>
		</getText>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<hitTestTextNearPos public="1" set="method">
			<f a="x:y:?maxDistance" v="::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ maxDistance : 0 }</e></m></meta>
		</hitTestTextNearPos>
		<setSelectColor public="1" set="method">
			<f a="?hexColor" v="16776960">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ hexColor : 16776960 }</e></m></meta>
		</setSelectColor>
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setSelected>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="/usr/local/lib/haxe/std/flash/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<clipboardItems public="1">
			<c path="flash.ui.ContextMenuClipboardItems"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardItems>
		<clipboardMenu public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardMenu>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<link public="1">
			<c path="flash.net.URLRequest"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</link>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<hideBuiltInItems public="1" set="method"><f a=""><x path="Void"/></f></hideBuiltInItems>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="/usr/local/lib/haxe/std/flash/ui/ContextMenuBuiltInItems.hx" extern="1">
		<forwardAndBack public="1"><x path="Bool"/></forwardAndBack>
		<loop public="1"><x path="Bool"/></loop>
		<play public="1"><x path="Bool"/></play>
		<print public="1"><x path="Bool"/></print>
		<quality public="1"><x path="Bool"/></quality>
		<rewind public="1"><x path="Bool"/></rewind>
		<save public="1"><x path="Bool"/></save>
		<zoom public="1"><x path="Bool"/></zoom>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="/usr/local/lib/haxe/std/flash/ui/ContextMenuClipboardItems.hx" extern="1">
		<clear public="1"><x path="Bool"/></clear>
		<copy public="1"><x path="Bool"/></copy>
		<cut public="1"><x path="Bool"/></cut>
		<paste public="1"><x path="Bool"/></paste>
		<selectAll public="1"><x path="Bool"/></selectAll>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.ui.KeyLocation" params="" file="/usr/local/lib/haxe/std/flash/ui/KeyLocation.hx">
		<D_PAD/>
		<LEFT/>
		<NUM_PAD/>
		<RIGHT/>
		<STANDARD/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>UInt</e></m>
		</meta>
	</enum>
	<class path="flash.ui.Mouse" params="" file="/usr/local/lib/haxe/std/flash/ui/Mouse.hx" extern="1">
		<cursor public="1" static="1">
			<d/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</cursor>
		<supportsCursor public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</supportsCursor>
		<supportsNativeCursor public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</supportsNativeCursor>
		<hide public="1" set="method" static="1"><f a=""><x path="Void"/></f></hide>
		<registerCursor public="1" set="method" static="1">
			<f a="name:cursor">
				<c path="String"/>
				<c path="flash.ui.MouseCursorData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</registerCursor>
		<show public="1" set="method" static="1"><f a=""><x path="Void"/></f></show>
		<unregisterCursor public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</unregisterCursor>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.ui.MouseCursor" params="" file="/usr/local/lib/haxe/std/flash/ui/MouseCursor.hx" extern="1">
		<ARROW public="1" set="null" static="1"><c path="String"/></ARROW>
		<AUTO public="1" set="null" static="1"><c path="String"/></AUTO>
		<BUTTON public="1" set="null" static="1"><c path="String"/></BUTTON>
		<HAND public="1" set="null" static="1"><c path="String"/></HAND>
		<IBEAM public="1" set="null" static="1"><c path="String"/></IBEAM>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.ui.MouseCursorData" params="" file="/usr/local/lib/haxe/std/flash/ui/MouseCursorData.hx" extern="1">
		<data public="1"><c path="flash.Vector"><c path="flash.display.BitmapData"/></c></data>
		<frameRate public="1"><x path="Float"/></frameRate>
		<hotSpot public="1"><c path="flash.geom.Point"/></hotSpot>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<class path="flash.ui.Multitouch" params="" file="/usr/local/lib/haxe/std/flash/ui/Multitouch.hx" extern="1">
		<inputMode public="1" static="1"><e path="flash.ui.MultitouchInputMode"/></inputMode>
		<mapTouchToMouse public="1" static="1"><x path="Bool"/></mapTouchToMouse>
		<maxTouchPoints public="1" set="null" static="1"><x path="Int"/></maxTouchPoints>
		<supportedGestures public="1" set="null" static="1"><c path="flash.Vector"><c path="String"/></c></supportedGestures>
		<supportsGestureEvents public="1" set="null" static="1"><x path="Bool"/></supportsGestureEvents>
		<supportsTouchEvents public="1" set="null" static="1"><x path="Bool"/></supportsTouchEvents>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<enum path="flash.ui.MultitouchInputMode" params="" file="/usr/local/lib/haxe/std/flash/ui/MultitouchInputMode.hx">
		<GESTURE/>
		<NONE/>
		<TOUCH_POINT/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.utils.IDataInput" params="" file="/usr/local/lib/haxe/std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
	</class>
	<class path="flash.utils.IDataInput2" params="" file="/usr/local/lib/haxe/std/flash/utils/IDataInput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataInput"/></class>
	<class path="flash.utils.IDataOutput" params="" file="/usr/local/lib/haxe/std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
	</class>
	<class path="flash.utils.IDataOutput2" params="" file="/usr/local/lib/haxe/std/flash/utils/IDataOutput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataOutput"/></class>
	<class path="flash.utils.ByteArray" params="" file="/usr/local/lib/haxe/std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput2"/>
		<implements path="flash.utils.IDataOutput2"/>
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<length public="1"><x path="UInt"/></length>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<position public="1"><x path="UInt"/></position>
		<shareable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</shareable>
		<atomicCompareAndSwapIntAt public="1" set="method">
			<f a="byteIndex:expectedValue:newValue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</atomicCompareAndSwapIntAt>
		<atomicCompareAndSwapLength public="1" set="method">
			<f a="expectedLength:newLength">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</atomicCompareAndSwapLength>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clear>
		<compress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></compress>
		<deflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</deflate>
		<inflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</inflate>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<uncompress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></uncompress>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flash.utils.CompressionAlgorithm" params="" file="/usr/local/lib/haxe/std/flash/utils/CompressionAlgorithm.hx">
		<DEFLATE/>
		<LZMA/>
		<ZLIB/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash11</e></m>
		</meta>
	</enum>
	<class path="flash.utils.Dictionary" params="" file="/usr/local/lib/haxe/std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method">
			<f a="?weakKeys" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ weakKeys : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flash.utils.Endian" params="" file="/usr/local/lib/haxe/std/flash/utils/Endian.hx">
		<BIG_ENDIAN/>
		<LITTLE_ENDIAN/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<typedef path="flash.utils.Function" params="" file="/usr/local/lib/haxe/std/flash/utils/Function.hx"><d/></typedef>
	<class path="flash.utils.Namespace" params="" file="/usr/local/lib/haxe/std/flash/utils/Namespace.hx" extern="1">
		<prefix public="1" set="null"><d/></prefix>
		<uri public="1" set="null"><c path="String"/></uri>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<typedef path="flash.utils.Object" params="" file="/usr/local/lib/haxe/std/flash/utils/Object.hx"><d/></typedef>
	<class path="flash.xml.XML" params="" file="/usr/local/lib/haxe/std/flash/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><x path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><x path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><x path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><x path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><x path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<x path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></localName>
		<name public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<notification public="1" set="method"><f a=""><t path="flash.utils.Function"/></f></notification>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<setNotification public="1" set="method"><f a="f">
	<t path="flash.utils.Function"/>
	<d/>
</f></setNotification>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toJSON public="1" set="method">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.xml.XMLList" params="" file="/usr/local/lib/haxe/std/flash/xml/XMLList.hx" extern="1">
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></localName>
		<name public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toJSON public="1" set="method">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="haxe.Function" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is public and
	  * unifies with the type used for type parameter `T`.

	If a type parameter A is assigned to a type parameter B which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="/usr/local/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints" interface="1">
		<set public="1" set="method"><f a="k:v">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
	<x path="Void"/>
</f></set>
		<exists public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></exists>
		<remove public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></remove>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/usr/local/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="50" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="63" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="79" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="96" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="108" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an 
  [extension](https://haxe.org/manual/lf-static-extension.html) to the 
  `enum` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/local/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="132" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="143" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="157" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="169" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<match public="1" set="method" static="1">
			<f a="e:pattern">
				<x path="EnumValue"/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Matches enum instance `e` against pattern `pattern`, returning `true` if
		matching succeeded and `false` otherwise.

		Example usage:

		```haxe
		if (e.match(pattern)) {
			// codeIfTrue
		} else {
			// codeIfFalse
		}
		```

		This is equivalent to the following code:

		```haxe
		switch (e) {
			case pattern:
				// codeIfTrue
			case _:
				// codeIfFalse
		}
		```

		This method is implemented in the compiler. This definition exists only
		for documentation.</haxe_doc>
		</match>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an 
  [extension](https://haxe.org/manual/lf-static-extension.html) to the 
  `EnumValue` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<abstract path="haxe.Int32" params="" file="/usr/local/lib/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
 	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="/usr/local/lib/haxe/std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<meta><m n=":notNull"/></meta>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta>
		<m n=":keep"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="/usr/local/lib/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>* This typedef will fool @:coreApi into thinking that we are using
  * the same underlying type, even though it might be different on
  * specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe._Int64.___Int64" params="" file="/usr/local/lib/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<high public="1"><x path="haxe.Int32"/></high>
		<low public="1"><x path="haxe.Int32"/></low>
		<new public="1" get="inline" set="null" line="459"><f a="high:low">
	<x path="haxe.Int32"/>
	<x path="haxe.Int32"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Json" params="" file="/usr/local/lib/haxe/std/flash/_std/haxe/Json.hx" extern="1">
		<parse public="1" set="method" static="1">
			<f a="text">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[Parses given JSON-encoded `text` and returns the resulting object.

		JSON objects are parsed into anonymous structures and JSON arrays
		are parsed into `Array<Dynamic>`.

		If given `text` is not valid JSON, an exception will be thrown.

		@see https://haxe.org/manual/std-Json-parsing.html]]></haxe_doc>
		</parse>
		<stringify public="1" set="method" static="1">
			<f a="value:?replacer:?space">
				<d/>
				<f a="key:value">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes the given `value` and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve the
		actual object to be encoded. The `replacer` function takes two parameters,
		the key and the value being encoded. Initial key value is an empty string.
		
		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.

		@see https://haxe.org/manual/std-Json-encoding.html</haxe_doc>
		</stringify>
		<haxe_doc>Cross-platform JSON API: it will automatically use the optimized native API if available.
	Use `-D haxeJSON` to force usage of the Haxe implementation even if a native API is found:
	This will provide extra encoding features such as enums (replaced by their index) and StringMaps.

	@see https://haxe.org/manual/std-Json.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":native"><e>"JSON"</e></m>
		</meta>
	</class>
	<class path="haxe.Log" params="" file="/usr/local/lib/haxe/std/flash/_std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="35" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:
		
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/local/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Serializer" params="" file="/usr/local/lib/haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" expr="false" line="56" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set `USE_CACHE` to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of Serializer by
		setting their useCache field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" expr="false" line="68" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of Serializer by
		setting their useEnumIndex field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="70" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<BASE64_CODES expr="null" line="71" static="1">
			<x path="haxe.ds.Vector"><x path="Null"><x path="Int"/></x></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</BASE64_CODES>
		<run public="1" set="method" line="565" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

		This is a convenience function for creating a new instance of
		Serializer, serialize `v` into it and obtain the result through a call
		to toString().</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See USE_CACHE for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See USE_ENUM_INDEX for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="117">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		https://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="154"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="173"><f a="v">
	<d/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeClassFields set="method" line="196">
			<f a="v:c">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</serializeClassFields>
		<serializeFields set="method" line="210"><f a="v">
	<a/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="228">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

		All haxe-defined values and objects with the exception of functions can
		be serialized. Serialization of external/native objects is not
		guaranteed to work.

		The values of `this.useCache` and `this.useEnumIndex` may affect
		serialization output.</haxe_doc>
		</serialize>
		<new public="1" set="method" line="102">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each Serializer instance maintains its own cache if this.useCache` is
		true.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The Serializer class can be used to encode values and objects into a `String`,
	from which the `Unserializer` class can recreate the original representation.

	This class can be used in two ways:

	- create a `new Serializer()` instance, call its `serialize()` method with
		any argument and finally retrieve the String representation from
		`toString()`
	- call `Serializer.run()` to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/std-serialization-format.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Timer" params="" file="/Users/joshua/Development/Haxe/lime/src/haxe/Timer.hx">
		<delay public="1" set="method" line="141" static="1">
			<f a="f:time_ms">
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<c path="haxe.Timer"/>
			</f>
			<haxe_doc>Invokes `f` after `time_ms` milliseconds.

		This is a convenience function for creating a new Timer instance with
		`time_ms` as argument, binding its run() method to `f` and then stopping
		`this` Timer upon the first invocation.

		If `f` is null, the result is unspecified.</haxe_doc>
		</delay>
		<measure public="1" params="T" set="method" line="161" static="1">
			<f a="f:?pos">
				<f a=""><c path="measure.T"/></f>
				<t path="haxe.PosInfos"/>
				<c path="measure.T"/>
			</f>
			<haxe_doc>Measures the time it takes to execute `f`, in seconds with fractions.

		This is a convenience function for calculating the difference between
		Timer.stamp() before and after the invocation of `f`.

		The difference is passed as argument to Log.trace(), with "s" appended
		to denote the unit. The optional `pos` argument is passed through.

		If `f` is null, the result is unspecified.</haxe_doc>
		</measure>
		<stamp public="1" get="inline" set="null" line="174" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a timestamp, in seconds with fractions.

		The value itself might differ depending on platforms, only differences
		between two values make sense.</haxe_doc>
		</stamp>
		<id><x path="Null"><x path="Int"/></x></id>
		<stop public="1" set="method" line="93">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Stops `this` Timer.

		After calling this method, no additional invocations of `this.run`
		will occur.

		It is not possible to restart `this` Timer once stopped.</haxe_doc>
		</stop>
		<run public="1" set="dynamic" line="128">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This method is invoked repeatedly on `this` Timer.

		It can be overridden in a subclass, or rebound directly to a custom
		function:
			var timer = new haxe.Timer(1000); // 1000ms delay
			timer.run = function() { ... }

		Once bound, it can still be rebound to different functions until `this`
		Timer is stopped through a call to `this.stop`.</haxe_doc>
		</run>
		<new public="1" set="method" line="65">
			<f a="time_ms">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new timer that will run every `time_ms` milliseconds.

		After creating the Timer instance, it calls `this.run` repeatedly,
		with delays of `time_ms` milliseconds, until `this.stop` is called.

		The first invocation occurs after `time_ms` milliseconds, not
		immediately.

		The accuracy of this may be platform-dependent.</haxe_doc>
		</new>
		<haxe_doc>The Timer class allows you to create asynchronous timers on platforms that
	support events.

	The intended usage is to create an instance of the Timer class with a given
	interval, set its run() method to a custom function to be invoked and
	eventually call stop() to stop the Timer.

	Note that a running Timer may or may not prevent the program to exit
	automatically when main() returns.

	It is also possible to extend this class and override its run() method in
	the child class.</haxe_doc>
	</class>
	<class path="haxe._Unserializer.DefaultResolver" params="" file="/usr/local/lib/haxe/std/haxe/Unserializer.hx" private="1" module="haxe.Unserializer">
		<resolveClass final="1" public="1" get="inline" set="null" line="479">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":final"/></meta>
		</resolveClass>
		<resolveEnum final="1" public="1" get="inline" set="null" line="480">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":final"/></meta>
		</resolveEnum>
		<new public="1" set="method" line="478"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Unserializer" params="" file="/usr/local/lib/haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" expr="new DefaultResolver()" line="65" static="1">
			<t path="haxe.TypeResolver"/>
			<meta><m n=":value"><e>new DefaultResolver()</e></m></meta>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a `Class` or `Enum` instance from a given `String`.
		By default, the Haxe `Type` Api is used.

		A type resolver must provide two methods:

		1. `resolveClass(name:String):Class<Dynamic>` is called to determine a
				`Class` from a class name
		2. `resolveEnum(name:String):Enum<Dynamic>` is called to determine an
				`Enum` from an enum name

		This value is applied when a new `Unserializer` instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="67" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<CODES expr="null" line="70" static="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</CODES>
		<initCodes set="method" line="72" static="1"><f a=""><c path="flash.utils.ByteArray"/></f></initCodes>
		<run public="1" set="method" line="467" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserializes `v` and returns the according value.

		This is a convenience function for creating a new instance of
		Unserializer with `v` as buffer and calling its unserialize() method
		once.</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<readDigits set="method" line="149"><f a=""><x path="Int"/></f></readDigits>
		<readFloat set="method" line="174"><f a=""><x path="Float"/></f></readFloat>
		<unserializeObject set="method" line="188"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum params="T" set="method" line="203"><f a="edecl:tag">
	<x path="Enum"><c path="unserializeEnum.T"/></x>
	<c path="String"/>
	<c path="unserializeEnum.T"/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="235">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different Haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from `Type.createEmptyInstance`, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="104">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The `Unserializer` class is the complement to the `Serializer` class. It parses
	a serialization `String` and creates objects from the contained data.

	This class can be used in two ways:

	- create a `new Unserializer()` instance with a given serialization
		String, then call its `unserialize()` method until all values are
		extracted
	- call `Unserializer.run()`  to unserialize a single value from a given
		String

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/serialization/format>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="/Users/joshua/Development/Haxe/lime/src/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="457" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="483" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="541" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<fastGet public="1" get="inline" set="null" line="557" static="1">
			<f a="b:pos">
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read the most efficiently possible the n-th byte of the data.
		Behavior when reading outside of the available data is unspecified.</haxe_doc>
		</fastGet>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="51"><f a="pos">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="67"><f a="pos:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<blit public="1" set="method" line="85"><f a="pos:src:srcpos:len">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<fill public="1" set="method" line="118"><f a="pos:len:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fill>
		<sub public="1" set="method" line="137"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="163"><f a="other">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
</f></compare>
		<getDouble public="1" get="inline" set="null" line="212">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE double precision value at given position (in low endian encoding).
		Result is unspecified if reading outside of the bounds</haxe_doc>
		</getDouble>
		<getFloat public="1" get="inline" set="null" line="231">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE single precision value at given position (in low endian encoding).
		Result is unspecified if reading outside of the bounds</haxe_doc>
		</getFloat>
		<setDouble public="1" get="inline" set="null" line="250">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the IEEE double precision value at given position in low endian encoding.
		Result is unspecified if writing outside of the bounds.</haxe_doc>
		</setDouble>
		<setFloat public="1" get="inline" set="null" line="273">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the IEEE single precision value at given position in low endian encoding.
		Result is unspecified if writing outside of the bounds.</haxe_doc>
		</setFloat>
		<getUInt16 public="1" get="inline" set="null" line="293">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the 16 bit unsigned integer at given position (in low endian encoding).</haxe_doc>
		</getUInt16>
		<setUInt16 public="1" get="inline" set="null" line="304">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the 16 bit unsigned integer at given position (in low endian encoding).</haxe_doc>
		</setUInt16>
		<getInt32 public="1" get="inline" set="null" line="316">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the 32 bit integer at given position (in low endian encoding).</haxe_doc>
		</getInt32>
		<getInt64 public="1" get="inline" set="null" line="333">
			<f a="pos">
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Returns the 64 bit integer at given position (in low endian encoding).</haxe_doc>
		</getInt64>
		<setInt32 public="1" get="inline" set="null" line="340">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the 32 bit integer at given position (in low endian encoding).</haxe_doc>
		</setInt32>
		<setInt64 public="1" get="inline" set="null" line="354">
			<f a="pos:v">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the 64 bit integer at given position (in low endian encoding).</haxe_doc>
		</setInt64>
		<getString public="1" set="method" line="359"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getString>
		<readString public="1" get="inline" set="null" line="416">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":deprecated"><e>"readString is deprecated, use getString instead"</e></m>
				<m n=":noCompletion"/>
			</meta>
		</readString>
		<toString public="1" set="method" line="420"><f a=""><c path="String"/></f></toString>
		<toHex public="1" set="method" line="439"><f a=""><c path="String"/></f></toHex>
		<getData public="1" get="inline" set="null" line="453"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="43"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":autoBuild"><e>lime._internal.macros.AssetsMacro.embedBytes()</e></m>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="haxe.crypto.BaseCode" params="" file="/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx">
		<haxe_doc>Allows one to encode/decode String and bytes using a power of two base dictionary.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.crypto.Sha1" params="" file="/usr/local/lib/haxe/std/haxe/crypto/Sha1.hx">
		<encode public="1" set="method" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<str2blks set="method" line="97" static="1"><f a="s">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<doEncode set="method" line="51"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<ft set="method" line="144">
			<f a="t:b:c:d">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Perform the appropriate triplet combination function for the current iteration</haxe_doc>
		</ft>
		<kt set="method" line="154">
			<f a="t">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Determine the appropriate additive constant for the current iteration</haxe_doc>
		</kt>
		<hex set="method" line="164"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></hex>
		<new set="method" line="48"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a Sha1 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/local/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="/usr/local/lib/haxe/std/flash/_std/haxe/ds/IntMap.hx">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h><c path="flash.utils.Dictionary"/></h>
		<set public="1" get="inline" set="null" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<exists public="1" get="inline" set="null" line="40">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="44">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds._IntMap.IntMapKeysIterator" params="" file="/usr/local/lib/haxe/std/flash/_std/haxe/ds/IntMap.hx" private="1" module="haxe.ds.IntMap">
		<h><c path="flash.utils.Dictionary"/></h>
		<index><x path="Int"/></index>
		<nextIndex><x path="Int"/></nextIndex>
		<hasNext public="1" get="inline" set="null" line="117">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":has_untyped"/></meta>
		</hasNext>
		<next public="1" get="inline" set="null" line="124">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</next>
		<new get="inline" set="null" line="111"><f a="h">
	<c path="flash.utils.Dictionary"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>haxe.ds.IntMap</e></m>
		</meta>
	</class>
	<class path="haxe.ds._IntMap.IntMapValuesIterator" params="T" file="/usr/local/lib/haxe/std/flash/_std/haxe/ds/IntMap.hx" private="1" module="haxe.ds.IntMap">
		<h><c path="flash.utils.Dictionary"/></h>
		<index><x path="Int"/></index>
		<nextIndex><x path="Int"/></nextIndex>
		<hasNext public="1" get="inline" set="null" line="144">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":has_untyped"/></meta>
		</hasNext>
		<next public="1" get="inline" set="null" line="151">
			<f a=""><c path="haxe.ds._IntMap.IntMapValuesIterator.T"/></f>
			<meta><m n=":has_untyped"/></meta>
		</next>
		<new get="inline" set="null" line="138"><f a="h">
	<c path="flash.utils.Dictionary"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>haxe.ds.IntMap</e></m>
		</meta>
	</class>
	<class path="haxe.ds.List" params="T" file="/usr/local/lib/haxe/std/haxe/ds/List.hx">
		<h><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></h>
		<q><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="53">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<pop public="1" set="method" line="100">
			<f a=""><x path="Null"><c path="haxe.ds.List.T"/></x></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.

		The element is removed from `this` List.</haxe_doc>
		</pop>
		<clear public="1" set="method" line="124">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Empties `this` List.

		This function does not traverse the elements, but simply sets the
		internal references to null and `this.length` to 0.</haxe_doc>
		</clear>
		<remove public="1" set="method" line="138">
			<f a="v">
				<c path="haxe.ds.List.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `v` in `this` List.

		If `v` is found by checking standard equality, it is removed from `this`
		List and the function returns true.

		Otherwise, false is returned.</haxe_doc>
		</remove>
		<new public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds._List.ListNode" params="T" file="/usr/local/lib/haxe/std/haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<item public="1"><c path="haxe.ds._List.ListNode.T"/></item>
		<next public="1"><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c></next>
		<new public="1" set="method" line="256"><f a="item:next">
	<c path="haxe.ds._List.ListNode.T"/>
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="/usr/local/lib/haxe/std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta><m n=":multiType"><e>@:followWithAbstracts K</e></m></meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/local/lib/haxe/std/flash/_std/haxe/ds/ObjectMap.hx">
		<extends path="flash.utils.Dictionary"/>
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<set public="1" get="inline" set="null" line="35">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<exists public="1" get="inline" set="null" line="39">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="43">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="63">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds._ObjectMap.NativePropertyIterator" params="" file="/usr/local/lib/haxe/std/flash/_std/haxe/ds/ObjectMap.hx" private="1" module="haxe.ds.ObjectMap">
		<collection><d/></collection>
		<index expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</index>
		<hasNext public="1" get="inline" set="null" line="103">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":has_untyped"/></meta>
		</hasNext>
		<next public="1" get="inline" set="null" line="112">
			<f a=""><d/></f>
			<meta><m n=":has_untyped"/></meta>
		</next>
		<new set="method" line="101"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="/usr/local/lib/haxe/std/flash/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<reserved expr="{ }" line="28" static="1">
			<a/>
			<meta><m n=":value"><e>{ }</e></m></meta>
		</reserved>
		<h><d/></h>
		<rh><d/></rh>
		<set public="1" get="inline" set="null" line="38">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<exists public="1" get="inline" set="null" line="51">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<setReserved set="method" line="57">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setReserved>
		<getReserved set="method" line="62">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getReserved>
		<existsReserved set="method" line="66">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</existsReserved>
		<remove public="1" set="method" line="71">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<new public="1" set="method" line="30">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds._StringMap.StringMapKeysIterator" params="" file="/usr/local/lib/haxe/std/flash/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap">
		<h><d/></h>
		<rh><d/></rh>
		<index><x path="Int"/></index>
		<nextIndex><x path="Int"/></nextIndex>
		<isReserved><x path="Bool"/></isReserved>
		<hasNext public="1" get="inline" set="null" line="158">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":has_untyped"/></meta>
		</hasNext>
		<next public="1" get="inline" set="null" line="172">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
		</next>
		<new get="inline" set="null" line="150"><f a="h:rh">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>haxe.ds.StringMap</e></m>
		</meta>
	</class>
	<class path="haxe.ds._StringMap.StringMapValuesIterator" params="T" file="/usr/local/lib/haxe/std/flash/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap">
		<h><d/></h>
		<rh><d/></rh>
		<index><x path="Int"/></index>
		<nextIndex><x path="Int"/></nextIndex>
		<hasNext public="1" get="inline" set="null" line="195">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":has_untyped"/></meta>
		</hasNext>
		<next public="1" get="inline" set="null" line="208">
			<f a=""><c path="haxe.ds._StringMap.StringMapValuesIterator.T"/></f>
			<meta><m n=":has_untyped"/></meta>
		</next>
		<new get="inline" set="null" line="188"><f a="h:rh">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>haxe.ds.StringMap</e></m>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="/usr/local/lib/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="flash.Vector"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="/usr/local/lib/haxe/std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
	</length>
	<meta>
		<m n=":keep"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<typedef path="haxe.io.BytesData" params="" file="/usr/local/lib/haxe/std/haxe/io/BytesData.hx"><c path="flash.utils.ByteArray"/></typedef>
	<enum path="haxe.io.Error" params="" file="/usr/local/lib/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.io.Path" params="" file="/usr/local/lib/haxe/std/haxe/io/Path.hx">
		<directory public="1" set="method" line="147" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of `path`.

		If the directory is null, the empty String `""` is returned.

		If `path` is null, the result is unspecified.</haxe_doc>
		</directory>
		<extension public="1" set="method" line="161" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the extension of `path`.

		If the extension is null, the empty String `""` is returned.

		If `path` is null, the result is unspecified.</haxe_doc>
		</extension>
		<dir public="1">
			<c path="String"/>
			<haxe_doc>The directory.

		This is the leading part of the path that is not part of the file name
		and the extension.

		Does not end with a `/` or `\` separator.

		If the path has no directory, the value is null.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

		This is the part of the part between the directory and the extension.

		If there is no file name, e.g. for ".htaccess" or "/dir/", the value
		is the empty String "".</haxe_doc>
		</file>
		<ext public="1">
			<c path="String"/>
			<haxe_doc>The file extension.

		It is separated from the file name by a dot. This dot is not part of
		the extension.

		If the path has no extension, the value is null.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>True if the last directory separator is a backslash, false otherwise.</haxe_doc>
		</backslash>
		<new public="1" set="method" line="76">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Path instance by parsing `path`.

		Path information can be retrieved by accessing the dir, file and ext
		properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- directory1/directory2/filename.extension
	- directory1\directory2\filename.extension</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.macro.IncludePosition" params="" file="/usr/local/lib/haxe/std/haxe/macro/Compiler.hx" module="haxe.macro.Compiler">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.macro._Compiler.IncludePosition_Impl_" params="" file="/usr/local/lib/haxe/std/haxe/macro/Compiler.hx" private="1" module="haxe.macro.Compiler"><meta>
	<m n=":keep"/>
	<m n=":final"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<typedef path="haxe.macro.Position" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<min>
				<x path="Int"/>
				<haxe_doc>Position of the first character.</haxe_doc>
			</min>
			<max>
				<x path="Int"/>
				<haxe_doc>Position of the last character.</haxe_doc>
			</max>
			<file>
				<c path="String"/>
				<haxe_doc>Reference to the filename.</haxe_doc>
			</file>
		</a>
		<haxe_doc>Represents a position in a file.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Expr" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.ExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a node in the AST.
	@see https://haxe.org/manual/macro-reification-expression.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<t path="haxe.macro.Expr"/>
		<haxe_doc>Represents a AST node identical to `Expr`, but it allows constraining the
	type of accepted expressions.
	@see https://haxe.org/manual/macro-ExprOf.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Case" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<values>
				<c path="Array"><t path="haxe.macro.Expr"/></c>
				<haxe_doc>The value expressions of the case.</haxe_doc>
			</values>
			<guard>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional guard expressions of the case, if available.</haxe_doc>
			</guard>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the case, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a switch case.
	@see https://haxe.org/manual/expression-switch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Var" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The type-hint of the variable, if available.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the variable, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a variable in the AST.
	@see https://haxe.org/manual/expression-var.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Catch" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<e path="haxe.macro.ComplexType"/>
				<haxe_doc>The type of the catch.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the catch variable.</haxe_doc>
			</name>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The expression of the catch.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a catch in the AST.
	@https://haxe.org/manual/expression-try-catch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ObjectField" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<quotes>
				<x path="Null"><e path="haxe.macro.QuoteStatus"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>How the field name is quoted.</haxe_doc>
			</quotes>
			<field>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</field>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The field expression.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents the field of an object declaration.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypePath" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<sub>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sub is set on module sub-type access:
		`pack.Module.Type` has name = Module, sub = Type, if available.</haxe_doc>
			</sub>
			<params>
				<x path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional parameters of the type path.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>Represents the package of the type path.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type path.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a type path in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the type parameter.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the type parameter.</haxe_doc>
			</meta>
			<constraints>
				<x path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional constraints of the type parameter.</haxe_doc>
			</constraints>
		</a>
		<haxe_doc>Represents a type parameter declaration in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Function" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<ret>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The return type-hint of the function, if available.</haxe_doc>
			</ret>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional list of function parameter type declarations.</haxe_doc>
			</params>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the function body, if available.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><t path="haxe.macro.FunctionArg"/></c>
				<haxe_doc>A list of function arguments.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<value>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional value of the function argument, if available.</haxe_doc>
			</value>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The type-hint of the function argument, if available.</haxe_doc>
			</type>
			<opt>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the function argument is optional.</haxe_doc>
			</opt>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the function argument.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the function argument.</haxe_doc>
			</meta>
		</a>
		<haxe_doc>Represents a function argument in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the metadata entry.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the metadata entry.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the metadata entry.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a metadata entry in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
		<haxe_doc>Represents metadata in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Field" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the field.</haxe_doc>
			</pos>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldType"/>
				<haxe_doc>The kind of the field.</haxe_doc>
			</kind>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the field, if available. If the field has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
			<access>
				<x path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The access modifiers of the field. By default fields have private access.
		@see https://haxe.org/manual/class-field-access-modifier.html</haxe_doc>
			</access>
		</a>
		<haxe_doc>Represents a field in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position to the type definition.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The parameter type declarations of the type definition.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type definition.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type definition.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the type definition.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.TypeDefKind"/>
				<haxe_doc>The kind of the type definition.</haxe_doc>
			</kind>
			<isExtern>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<fields>
				<c path="Array"><t path="haxe.macro.Field"/></c>
				<haxe_doc>The fields of the type definition.</haxe_doc>
			</fields>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the type, if available. If the type has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a type definition.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="/usr/local/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<path>
				<c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c>
				<haxe_doc>The path to the import expression.</haxe_doc>
			</path>
			<mode>
				<e path="haxe.macro.ImportMode"/>
				<haxe_doc>The mode of the import expression.</haxe_doc>
			</mode>
		</a>
		<haxe_doc>Represents the import expression.</haxe_doc>
	</typedef>
	<class path="lime._internal.backend.flash.FlashApplication" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/backend/flash/FlashApplication.hx">
		<createFirstWindow static="1"><x path="Bool"/></createFirstWindow>
		<parent><c path="lime.app.Application"/></parent>
		<requestedWindow><x path="Bool"/></requestedWindow>
		<exec public="1" set="method" line="36"><f a=""><x path="Int"/></f></exec>
		<exit public="1" set="method" line="45"><f a=""><x path="Void"/></f></exit>
		<new public="1" set="method" line="22"><f a="parent">
	<c path="lime.app.Application"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.app.Application</e></m>
		</meta>
	</class>
	<class path="lime._internal.backend.flash.FlashAudioSource" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/backend/flash/FlashAudioSource.hx">
		<channel><c path="flash.media.SoundChannel"/></channel>
		<completed><x path="Bool"/></completed>
		<length><x path="Null"><x path="Int"/></x></length>
		<loops><x path="Int"/></loops>
		<parent><c path="lime.media.AudioSource"/></parent>
		<pauseTime><x path="Int"/></pauseTime>
		<playing><x path="Bool"/></playing>
		<position><c path="lime.math.Vector4"/></position>
		<dispose public="1" set="method" line="33"><f a=""><x path="Void"/></f></dispose>
		<init public="1" set="method" line="40"><f a=""><x path="Void"/></f></init>
		<play public="1" set="method" line="47"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method" line="55"><f a=""><x path="Void"/></f></pause>
		<stop public="1" set="method" line="67"><f a=""><x path="Void"/></f></stop>
		<getCurrentTime public="1" set="method" line="87"><f a=""><x path="Int"/></f></getCurrentTime>
		<setCurrentTime public="1" set="method" line="102"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></setCurrentTime>
		<getGain public="1" set="method" line="119"><f a=""><x path="Float"/></f></getGain>
		<setGain public="1" set="method" line="126"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></setGain>
		<getLength public="1" set="method" line="136"><f a=""><x path="Int"/></f></getLength>
		<setLength public="1" set="method" line="149"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></setLength>
		<getLoops public="1" set="method" line="156"><f a=""><x path="Int"/></f></getLoops>
		<setLoops public="1" set="method" line="163"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></setLoops>
		<getPosition public="1" set="method" line="170"><f a=""><c path="lime.math.Vector4"/></f></getPosition>
		<setPosition public="1" set="method" line="179"><f a="value">
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
</f></setPosition>
		<new public="1" set="method" line="24"><f a="parent">
	<c path="lime.media.AudioSource"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.media.AudioBuffer</e></m>
		</meta>
	</class>
	<class path="lime._internal.backend.flash.FlashWindow" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/backend/flash/FlashWindow.hx">
		<windowID expr="0" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</windowID>
		<cacheMouseX><x path="Float"/></cacheMouseX>
		<cacheMouseY><x path="Float"/></cacheMouseY>
		<cacheTime><x path="Int"/></cacheTime>
		<currentTouches expr="new Map&lt;Int,Touch&gt;()">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="lime.ui.Touch"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Touch>()]]></e></m></meta>
		</currentTouches>
		<cursor><e path="lime.ui.MouseCursor"/></cursor>
		<frameRate><x path="Float"/></frameRate>
		<mouseLeft><x path="Bool"/></mouseLeft>
		<parent><c path="lime.ui.Window"/></parent>
		<textInputEnabled><x path="Bool"/></textInputEnabled>
		<unusedTouchesPool expr="new List&lt;Touch&gt;()">
			<c path="haxe.ds.List"><c path="lime.ui.Touch"/></c>
			<meta><m n=":value"><e><![CDATA[new List<Touch>()]]></e></m></meta>
		</unusedTouchesPool>
		<alert public="1" set="method" line="70"><f a="message:title">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></alert>
		<close public="1" set="method" line="77"><f a=""><x path="Void"/></f></close>
		<convertKeyCode set="method" line="84"><f a="keyCode">
	<x path="Int"/>
	<x path="lime.ui.KeyCode"/>
</f></convertKeyCode>
		<create set="method" line="159"><f a=""><x path="Void"/></f></create>
		<focus public="1" set="method" line="244"><f a=""><x path="Void"/></f></focus>
		<getCursor public="1" set="method" line="251"><f a=""><e path="lime.ui.MouseCursor"/></f></getCursor>
		<getDisplay public="1" set="method" line="258"><f a=""><c path="lime.system.Display"/></f></getDisplay>
		<getDisplayMode public="1" set="method" line="265"><f a=""><c path="lime.system.DisplayMode"/></f></getDisplayMode>
		<handleApplicationEvent set="method" line="272"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></handleApplicationEvent>
		<handleKeyEvent set="method" line="284"><f a="event">
	<c path="flash.events.KeyboardEvent"/>
	<x path="Void"/>
</f></handleKeyEvent>
		<handleMouseEvent set="method" line="308"><f a="event">
	<c path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></handleMouseEvent>
		<handleTouchEvent set="method" line="357"><f a="event">
	<c path="flash.events.TouchEvent"/>
	<x path="Void"/>
</f></handleTouchEvent>
		<handleWindowEvent set="method" line="453"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></handleWindowEvent>
		<readPixels public="1" set="method" line="492"><f a="rect">
	<c path="lime.math.Rectangle"/>
	<c path="lime.graphics.Image"/>
</f></readPixels>
		<setCursor public="1" set="method" line="527"><f a="value">
	<e path="lime.ui.MouseCursor"/>
	<e path="lime.ui.MouseCursor"/>
</f></setCursor>
		<setDisplayMode public="1" set="method" line="571"><f a="value">
	<c path="lime.system.DisplayMode"/>
	<c path="lime.system.DisplayMode"/>
</f></setDisplayMode>
		<getFrameRate public="1" set="method" line="578"><f a=""><x path="Float"/></f></getFrameRate>
		<getMouseLock public="1" set="method" line="585"><f a=""><x path="Bool"/></f></getMouseLock>
		<getTextInputEnabled public="1" set="method" line="592"><f a=""><x path="Bool"/></f></getTextInputEnabled>
		<move public="1" set="method" line="599"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></move>
		<resize public="1" set="method" line="606"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setBorderless public="1" set="method" line="613"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setBorderless>
		<setFrameRate public="1" set="method" line="620"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></setFrameRate>
		<setFullscreen public="1" set="method" line="629"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setFullscreen>
		<setIcon public="1" set="method" line="637"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></setIcon>
		<setMaximized public="1" set="method" line="644"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setMaximized>
		<setMinimized public="1" set="method" line="651"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setMinimized>
		<setMouseLock public="1" set="method" line="658"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setMouseLock>
		<setResizable public="1" set="method" line="665"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setResizable>
		<setTextInputEnabled public="1" set="method" line="672"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setTextInputEnabled>
		<setTitle public="1" set="method" line="679"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></setTitle>
		<warpMouse public="1" set="method" line="686"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></warpMouse>
		<new public="1" set="method" line="57"><f a="parent">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime._internal.backend.flash.FlashApplication</e></m>
			<m n=":access"><e>lime.app.Application</e></m>
			<m n=":access"><e>lime.graphics.RenderContext</e></m>
			<m n=":access"><e>lime.ui.Window</e></m>
		</meta>
	</class>
	<typedef path="lime._internal.backend.native.Float32" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/backend/native/NativeCFFI.hx" module="lime._internal.backend.native.NativeCFFI"><x path="Float"/></typedef>
	<typedef path="lime._internal.backend.native.CFFI" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/backend/native/NativeCFFI.hx" module="lime._internal.backend.native.NativeCFFI"><d/></typedef>
	<typedef path="lime._internal.backend.native.CFFIPointer" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/backend/native/NativeCFFI.hx" module="lime._internal.backend.native.NativeCFFI"><d/></typedef>
	<class path="lime._internal.backend.native.NativeCFFI" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/backend/native/NativeCFFI.hx"><meta>
	<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
	<m n=":noDebug"/>
</meta></class>
	<class path="lime._internal.format.BMP" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/format/BMP.hx">
		<encode public="1" set="method" line="17" static="1">
			<f a="image:?type" v=":null">
				<c path="lime.graphics.Image"/>
				<e path="lime._internal.format.BMPType"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</encode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<enum path="lime._internal.format.BMPType" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/format/BMP.hx" module="lime._internal.format.BMP">
		<RGB/>
		<BITFIELD/>
		<ICO/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="lime._internal.format.Deflate" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/format/Deflate.hx">
		<compress public="1" set="method" line="22" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></compress>
		<decompress public="1" set="method" line="62" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decompress>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime._internal.format.GZip" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/format/GZip.hx">
		<compress public="1" set="method" line="18" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></compress>
		<decompress public="1" set="method" line="48" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decompress>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime._internal.format.JPEG" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/format/JPEG.hx">
		<decodeBytes public="1" set="method" line="36" static="1">
			<f a="bytes:?decodeData" v=":true">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ decodeData : true }</e></m></meta>
		</decodeBytes>
		<decodeFile public="1" set="method" line="67" static="1">
			<f a="path:?decodeData" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ decodeData : true }</e></m></meta>
		</decodeFile>
		<encode public="1" set="method" line="98" static="1"><f a="image:quality">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></encode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
		</meta>
	</class>
	<class path="lime._internal.format.LZMA" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/format/LZMA.hx">
		<compress public="1" set="method" line="23" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></compress>
		<decompress public="1" set="method" line="54" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decompress>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime._internal.format.PNG" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/format/PNG.hx">
		<decodeBytes public="1" set="method" line="36" static="1">
			<f a="bytes:?decodeData" v=":true">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ decodeData : true }</e></m></meta>
		</decodeBytes>
		<decodeFile public="1" set="method" line="67" static="1">
			<f a="path:?decodeData" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ decodeData : true }</e></m></meta>
		</decodeFile>
		<encode public="1" set="method" line="98" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<c path="haxe.io.Bytes"/>
</f></encode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
		</meta>
	</class>
	<class path="lime._internal.format.Zlib" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/format/Zlib.hx">
		<compress public="1" set="method" line="22" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></compress>
		<decompress public="1" set="method" line="62" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decompress>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime._internal.graphics.ImageCanvasUtil" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/graphics/ImageCanvasUtil.hx">
		<colorTransform public="1" set="method" line="27" static="1"><f a="image:rect:colorMatrix">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.math.ColorMatrix"/>
	<x path="Void"/>
</f></colorTransform>
		<convertToCanvas public="1" set="method" line="36" static="1">
			<f a="image:?clear" v=":false">
				<c path="lime.graphics.Image"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ clear : false }</e></m></meta>
		</convertToCanvas>
		<convertToData public="1" set="method" line="92" static="1">
			<f a="image:?clear" v=":false">
				<c path="lime.graphics.Image"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ clear : false }</e></m></meta>
		</convertToData>
		<copyChannel public="1" set="method" line="138" static="1"><f a="image:sourceImage:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<e path="lime.graphics.ImageChannel"/>
	<e path="lime.graphics.ImageChannel"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method" line="148" static="1">
			<f a="image:sourceImage:sourceRect:destPoint:?alphaImage:?alphaPoint:?mergeAlpha" v="::::null:null:false">
				<c path="lime.graphics.Image"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false, alphaPoint : null, alphaImage : null }</e></m></meta>
		</copyPixels>
		<createCanvas public="1" set="method" line="197" static="1"><f a="image:width:height">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></createCanvas>
		<createImageData public="1" set="method" line="230" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></createImageData>
		<fillRect public="1" set="method" line="258" static="1"><f a="image:rect:color:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method" line="310" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></floodFill>
		<getPixel public="1" set="method" line="319" static="1"><f a="image:x:y:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></getPixel>
		<getPixel32 public="1" set="method" line="328" static="1"><f a="image:x:y:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></getPixel32>
		<getPixels public="1" set="method" line="337" static="1"><f a="image:rect:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.graphics.PixelFormat"/>
	<c path="haxe.io.Bytes"/>
</f></getPixels>
		<merge public="1" set="method" line="346" static="1"><f a="image:sourceImage:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></merge>
		<resize public="1" set="method" line="356" static="1"><f a="image:newWidth:newHeight">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<scroll public="1" set="method" line="384" static="1"><f a="image:x:y">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<setPixel public="1" set="method" line="401" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method" line="410" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method" line="419" static="1"><f a="image:rect:bytePointer:format:endian">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.utils.BytePointer"/>
	<x path="lime.graphics.PixelFormat"/>
	<e path="lime.system.Endian"/>
	<x path="Void"/>
</f></setPixels>
		<sync public="1" set="method" line="428" static="1"><f a="image:clear">
	<c path="lime.graphics.Image"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sync>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
		</meta>
	</class>
	<class path="lime._internal.graphics.ImageDataUtil" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/graphics/ImageDataUtil.hx">
		<colorTransform public="1" set="method" line="36" static="1"><f a="image:rect:colorMatrix">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.math.ColorMatrix"/>
	<x path="Void"/>
</f></colorTransform>
		<copyChannel public="1" set="method" line="82" static="1"><f a="image:sourceImage:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<e path="lime.graphics.ImageChannel"/>
	<e path="lime.graphics.ImageChannel"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method" line="167" static="1">
			<f a="image:sourceImage:sourceRect:destPoint:?alphaImage:?alphaPoint:?mergeAlpha" v="::::null:null:false">
				<c path="lime.graphics.Image"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false, alphaPoint : null, alphaImage : null }</e></m></meta>
		</copyPixels>
		<fillRect public="1" set="method" line="372" static="1"><f a="image:rect:color:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method" line="425" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></floodFill>
		<gaussianBlur public="1" set="method" line="510" static="1">
			<f a="image:sourceImage:sourceRect:destPoint:?blurX:?blurY:?quality:?strength" v="::::4:4:1:1">
				<c path="lime.graphics.Image"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ strength : 1, quality : 1, blurY : 4, blurX : 4 }</e></m></meta>
		</gaussianBlur>
		<calculateSourceOffset get="inline" set="null" line="687" static="1">
			<f a="sourceRect:destPoint:destX:destY">
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns: the offset for translated coordinate in the source image or -1 if the source the coordinate out of the source or destination bounds
	* Note: destX and destY should be valid coordinates</haxe_doc>
		</calculateSourceOffset>
		<translatePixel get="inline" set="null" line="696" static="1"><f a="imgB:sourceRect:destRect:destPoint:destX:destY:strength">
	<x path="lime.utils.UInt8Array"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translatePixel>
		<getColorBoundsRect public="1" set="method" line="713" static="1"><f a="image:mask:color:findColor:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="lime.graphics.PixelFormat"/>
	<c path="lime.math.Rectangle"/>
</f></getColorBoundsRect>
		<getPixel public="1" set="method" line="880" static="1"><f a="image:x:y:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></getPixel>
		<getPixel32 public="1" set="method" line="898" static="1"><f a="image:x:y:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></getPixel32>
		<getPixels public="1" set="method" line="915" static="1"><f a="image:rect:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.graphics.PixelFormat"/>
	<c path="haxe.io.Bytes"/>
</f></getPixels>
		<merge public="1" set="method" line="969" static="1"><f a="image:sourceImage:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></merge>
		<multiplyAlpha public="1" set="method" line="1022" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></multiplyAlpha>
		<resize public="1" set="method" line="1052" static="1"><f a="image:newWidth:newHeight">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<resizeBuffer public="1" set="method" line="1135" static="1"><f a="image:newWidth:newHeight">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resizeBuffer>
		<setFormat public="1" set="method" line="1174" static="1"><f a="image:format">
	<c path="lime.graphics.Image"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setFormat>
		<setPixel public="1" set="method" line="1264" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method" line="1290" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method" line="1311" static="1"><f a="image:rect:bytePointer:format:endian">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.utils.BytePointer"/>
	<x path="lime.graphics.PixelFormat"/>
	<e path="lime.system.Endian"/>
	<x path="Void"/>
</f></setPixels>
		<threshold public="1" set="method" line="1371" static="1"><f a="image:sourceImage:sourceRect:destPoint:operation:threshold:color:mask:copySource:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></threshold>
		<unmultiplyAlpha public="1" set="method" line="1490" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></unmultiplyAlpha>
		<__pixelCompare get="inline" set="null" line="1520" static="1"><f a="n1:n2">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Int"/>
</f></__pixelCompare>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
			<m n=":access"><e>lime.math.RGBA</e></m>
		</meta>
	</class>
	<class path="lime._internal.graphics._ImageDataUtil.ImageDataView" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/graphics/ImageDataUtil.hx" private="1" module="lime._internal.graphics.ImageDataUtil">
		<x public="1" set="null"><x path="Int"/></x>
		<y public="1" set="null"><x path="Int"/></y>
		<height public="1" set="null"><x path="Int"/></height>
		<width public="1" set="null"><x path="Int"/></width>
		<byteOffset><x path="Int"/></byteOffset>
		<image><c path="lime.graphics.Image"/></image>
		<rect><c path="lime.math.Rectangle"/></rect>
		<stride><x path="Int"/></stride>
		<tempRect><c path="lime.math.Rectangle"/></tempRect>
		<clip public="1" set="method" line="1619"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clip>
		<hasRow public="1" get="inline" set="null" line="1630"><f a="y">
	<x path="Int"/>
	<x path="Bool"/>
</f></hasRow>
		<offset public="1" set="method" line="1637"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></offset>
		<row public="1" get="inline" set="null" line="1668"><f a="y">
	<x path="Int"/>
	<x path="Int"/>
</f></row>
		<__update set="method" line="1675"><f a=""><x path="Void"/></f></__update>
		<new public="1" set="method" line="1592">
			<f a="image:?rect" v=":null">
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rect : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._internal.graphics._ImageDataUtil.ThresholdOperation" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/graphics/ImageDataUtil.hx" private="1" module="lime._internal.graphics.ImageDataUtil">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="lime._internal.graphics._ImageDataUtil.ThresholdOperation_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/graphics/ImageDataUtil.hx" private="1" module="lime._internal.graphics.ImageDataUtil" extern="1">
	<NOT_EQUALS public="1" get="inline" set="null" expr="cast 0" line="1691" static="1">
		<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NOT_EQUALS>
	<EQUALS public="1" get="inline" set="null" expr="cast 1" line="1692" static="1">
		<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EQUALS>
	<LESS_THAN public="1" get="inline" set="null" expr="cast 2" line="1693" static="1">
		<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LESS_THAN>
	<LESS_THAN_OR_EQUAL_TO public="1" get="inline" set="null" expr="cast 3" line="1694" static="1">
		<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LESS_THAN_OR_EQUAL_TO>
	<GREATER_THAN public="1" get="inline" set="null" expr="cast 4" line="1695" static="1">
		<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREATER_THAN>
	<GREATER_THAN_OR_EQUAL_TO public="1" get="inline" set="null" expr="cast 5" line="1696" static="1">
		<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREATER_THAN_OR_EQUAL_TO>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._internal.graphics._ImageDataUtil.ThresholdOperation_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/graphics/ImageDataUtil.hx" private="1" module="lime._internal.graphics.ImageDataUtil" extern="1">
		<NOT_EQUALS public="1" get="inline" set="null" expr="cast 0" line="1691" static="1">
			<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NOT_EQUALS>
		<EQUALS public="1" get="inline" set="null" expr="cast 1" line="1692" static="1">
			<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EQUALS>
		<LESS_THAN public="1" get="inline" set="null" expr="cast 2" line="1693" static="1">
			<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LESS_THAN>
		<LESS_THAN_OR_EQUAL_TO public="1" get="inline" set="null" expr="cast 3" line="1694" static="1">
			<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LESS_THAN_OR_EQUAL_TO>
		<GREATER_THAN public="1" get="inline" set="null" expr="cast 4" line="1695" static="1">
			<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREATER_THAN>
		<GREATER_THAN_OR_EQUAL_TO public="1" get="inline" set="null" expr="cast 5" line="1696" static="1">
			<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREATER_THAN_OR_EQUAL_TO>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime._internal.macros.AssetsMacro" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/macros/AssetsMacro.hx"><cacheVersion public="1" set="method" static="1"><f a=""><d/></f></cacheVersion></class>
	<abstract path="lime._internal.unifill.CodePoint" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/CodePoint.hx">
		<from><icast field="fromInt"><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast field="toString"><c path="String"/></icast>
			<icast field="toInt"><x path="Int"/></icast>
		</to>
		<impl><class path="lime._internal.unifill._CodePoint.CodePoint_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/CodePoint.hx" private="1" module="lime._internal.unifill.CodePoint">
	<fromInt public="1" get="inline" set="null" line="6" static="1">
		<f a="code">
			<x path="Int"/>
			<x path="lime._internal.unifill.CodePoint"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<cons public="1" get="inline" set="null" line="14" static="1">
		<f a="a:b">
			<x path="lime._internal.unifill.CodePoint"/>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</cons>
	<snoc public="1" get="inline" set="null" line="18" static="1">
		<f a="a:b">
			<c path="String"/>
			<x path="lime._internal.unifill.CodePoint"/>
			<c path="String"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</snoc>
	<addInt public="1" get="inline" set="null" line="22" static="1">
		<f a="a:b">
			<x path="lime._internal.unifill.CodePoint"/>
			<x path="Int"/>
			<x path="lime._internal.unifill.CodePoint"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</addInt>
	<sub public="1" get="inline" set="null" line="26" static="1">
		<f a="a:b">
			<x path="lime._internal.unifill.CodePoint"/>
			<x path="lime._internal.unifill.CodePoint"/>
			<x path="Int"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</sub>
	<subInt public="1" get="inline" set="null" line="30" static="1">
		<f a="a:b">
			<x path="lime._internal.unifill.CodePoint"/>
			<x path="Int"/>
			<x path="lime._internal.unifill.CodePoint"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</subInt>
	<_new get="inline" set="null" line="40" static="1">
		<f a="code">
			<x path="Int"/>
			<x path="lime._internal.unifill.CodePoint"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<toString public="1" get="inline" set="null" line="45" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<toInt public="1" get="inline" set="null" line="49" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toInt>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime._internal.unifill._CodePoint.CodePoint_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/CodePoint.hx" private="1" module="lime._internal.unifill.CodePoint">
		<fromInt public="1" get="inline" set="null" line="6" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="lime._internal.unifill.CodePoint"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<cons public="1" get="inline" set="null" line="14" static="1">
			<f a="a:b">
				<x path="lime._internal.unifill.CodePoint"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</cons>
		<snoc public="1" get="inline" set="null" line="18" static="1">
			<f a="a:b">
				<c path="String"/>
				<x path="lime._internal.unifill.CodePoint"/>
				<c path="String"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</snoc>
		<addInt public="1" get="inline" set="null" line="22" static="1">
			<f a="a:b">
				<x path="lime._internal.unifill.CodePoint"/>
				<x path="Int"/>
				<x path="lime._internal.unifill.CodePoint"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</addInt>
		<sub public="1" get="inline" set="null" line="26" static="1">
			<f a="a:b">
				<x path="lime._internal.unifill.CodePoint"/>
				<x path="lime._internal.unifill.CodePoint"/>
				<x path="Int"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</sub>
		<subInt public="1" get="inline" set="null" line="30" static="1">
			<f a="a:b">
				<x path="lime._internal.unifill.CodePoint"/>
				<x path="Int"/>
				<x path="lime._internal.unifill.CodePoint"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</subInt>
		<_new get="inline" set="null" line="40" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="lime._internal.unifill.CodePoint"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<toString public="1" get="inline" set="null" line="45" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<toInt public="1" get="inline" set="null" line="49" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toInt>
		<meta><m n=":final"/></meta>
	</class>
	<class path="lime._internal.unifill.CodePointIter" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/CodePointIter.hx">
		<string><c path="String"/></string>
		<index><x path="Int"/></index>
		<endIndex><x path="Int"/></endIndex>
		<hasNext public="1" get="inline" set="null" line="20"><f a=""><x path="Bool"/></f></hasNext>
		<i expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</i>
		<next public="1" get="inline" set="null" line="25"><f a=""><x path="lime._internal.unifill.CodePoint"/></f></next>
		<new public="1" get="inline" set="null" line="14"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime._internal.unifill.Exception" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Exception.hx">
		<toString public="1" set="method" line="11"><f a=""><c path="String"/></f></toString>
		<new set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime._internal.unifill.InvalidCodePoint" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Exception.hx" module="lime._internal.unifill.Exception">
		<extends path="lime._internal.unifill.Exception"/>
		<code public="1" set="null"><x path="Int"/></code>
		<toString public="1" set="method" line="27" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="23"><f a="code">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime._internal.unifill.InvalidCodeUnitSequence" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Exception.hx" module="lime._internal.unifill.Exception">
		<extends path="lime._internal.unifill.Exception"/>
		<index public="1" set="null"><x path="Int"/></index>
		<toString public="1" set="method" line="43" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="39"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<typedef path="lime._internal.unifill._InternalEncoding.UtfX" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/InternalEncoding.hx" private="1" module="lime._internal.unifill.InternalEncoding"><x path="lime._internal.unifill.Utf16"/></typedef>
	<class path="lime._internal.unifill.InternalEncoding" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/InternalEncoding.hx">
		<internalEncoding public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>Returns Encoding strings on the platform are encoded in.</haxe_doc>
		</internalEncoding>
		<get_internalEncoding get="inline" set="null" line="27" static="1"><f a=""><c path="String"/></f></get_internalEncoding>
		<codeUnitAt public="1" get="inline" set="null" line="40" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the UTF-8/16/32 code unit at position `index` of
	   String `s`.</haxe_doc>
		</codeUnitAt>
		<codePointAt public="1" get="inline" set="null" line="48" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the Unicode code point at position `index` of
	   String `s`.</haxe_doc>
		</codePointAt>
		<charAt public="1" get="inline" set="null" line="56" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character as a String at position `index` of
	   String `s`.</haxe_doc>
		</charAt>
		<codePointCount public="1" get="inline" set="null" line="64" static="1">
			<f a="s:beginIndex:endIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of Unicode code points from `beginIndex`
	   to `endIndex` in String `s`.</haxe_doc>
		</codePointCount>
		<codePointWidthAt public="1" get="inline" set="null" line="72" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of units of the code point at position
	   `index` of String `s`.</haxe_doc>
		</codePointWidthAt>
		<codePointWidthBefore public="1" get="inline" set="null" line="80" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of units of the code point before
	   position `index` of String `s`.</haxe_doc>
		</codePointWidthBefore>
		<offsetByCodePoints public="1" get="inline" set="null" line="88" static="1">
			<f a="s:index:codePointOffset">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index within String `s` that is offset from
	   position `index` by `codePointOffset` code points.</haxe_doc>
		</offsetByCodePoints>
		<backwardOffsetByCodePoints public="1" get="inline" set="null" line="97" static="1">
			<f a="s:index:codePointOffset">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index within String `s` that is offset from
	   position `index` by `codePointOffset` code points counting
	   backward.</haxe_doc>
		</backwardOffsetByCodePoints>
		<fromCodePoint public="1" get="inline" set="null" line="104" static="1">
			<f a="codePoint">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts the code point `code` to a character as String.</haxe_doc>
		</fromCodePoint>
		<fromCodePoints public="1" get="inline" set="null" line="111" static="1">
			<f a="codePoints">
				<t path="Iterable"><x path="Int"/></t>
				<c path="String"/>
			</f>
			<haxe_doc>Converts `codePoints` to a String.</haxe_doc>
		</fromCodePoints>
		<validate public="1" get="inline" set="null" line="121" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Validates String `s`.

	   If the code unit sequence of `s` is invalid,
	   `Exception.InvalidCodeUnitSequence` is throwed.</haxe_doc>
		</validate>
		<isValidString public="1" set="method" line="128" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns if String `s` is valid.</haxe_doc>
		</isValidString>
		<encodeWith public="1" get="inline" set="null" line="137" static="1"><f a="f:c">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></encodeWith>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime._internal.unifill.InternalEncodingIter" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/InternalEncodingIter.hx">
		<string public="1"><c path="String"/></string>
		<index public="1"><x path="Int"/></index>
		<endIndex public="1"><x path="Int"/></endIndex>
		<hasNext public="1" get="inline" set="null" line="20"><f a=""><x path="Bool"/></f></hasNext>
		<i expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</i>
		<next public="1" get="inline" set="null" line="25"><f a=""><x path="Int"/></f></next>
		<new public="1" get="inline" set="null" line="14"><f a="s:beginIndex:endIndex">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime._internal.unifill.Unicode" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Unicode.hx">
		<minCodePoint public="1" get="inline" set="null" expr="0x0000" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0000</e></m></meta>
		</minCodePoint>
		<maxCodePoint public="1" get="inline" set="null" expr="0x10FFFF" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x10FFFF</e></m></meta>
		</maxCodePoint>
		<minHighSurrogate public="1" get="inline" set="null" expr="0xD800" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD800</e></m></meta>
		</minHighSurrogate>
		<maxHighSurrogate public="1" get="inline" set="null" expr="0xDBFF" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xDBFF</e></m></meta>
		</maxHighSurrogate>
		<minLowSurrogate public="1" get="inline" set="null" expr="0xDC00" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xDC00</e></m></meta>
		</minLowSurrogate>
		<maxLowSurrogate public="1" get="inline" set="null" expr="0xDFFF" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xDFFF</e></m></meta>
		</maxLowSurrogate>
		<decodeSurrogate public="1" get="inline" set="null" line="17" static="1"><f a="hi:lo">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></decodeSurrogate>
		<encodeHighSurrogate public="1" get="inline" set="null" line="20" static="1"><f a="c">
	<x path="Int"/>
	<x path="Int"/>
</f></encodeHighSurrogate>
		<encodeLowSurrogate public="1" get="inline" set="null" line="23" static="1"><f a="c">
	<x path="Int"/>
	<x path="Int"/>
</f></encodeLowSurrogate>
		<isScalar public="1" get="inline" set="null" line="26" static="1"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isScalar>
		<isHighSurrogate public="1" get="inline" set="null" line="30" static="1"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isHighSurrogate>
		<isLowSurrogate public="1" get="inline" set="null" line="34" static="1"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isLowSurrogate>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime._internal.unifill.Unifill" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Unifill.hx">
		<uLength public="1" get="inline" set="null" line="18" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of Unicode code points of String `s`.</haxe_doc>
		</uLength>
		<uCharAt public="1" get="inline" set="null" line="24" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` by code points of String `s`.</haxe_doc>
		</uCharAt>
		<uCharCodeAt public="1" get="inline" set="null" line="36" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the code point as Int at position `index` by code points of String `s`.</haxe_doc>
		</uCharCodeAt>
		<uCodePointAt public="1" get="inline" set="null" line="48" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="lime._internal.unifill.CodePoint"/>
			</f>
			<haxe_doc>Returns the code point at position `index` by code points of String `s`.</haxe_doc>
		</uCodePointAt>
		<uIndexOf public="1" get="inline" set="null" line="57" static="1">
			<f a="s:value:?startIndex" v="::0">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ startIndex : 0 }</e></m></meta>
			<haxe_doc>Returns the position of the leftmost occurence of the str within String `s`.

	   `startIndex` is counted by code points.</haxe_doc>
		</uIndexOf>
		<uLastIndexOf public="1" get="inline" set="null" line="67" static="1">
			<f a="s:value:?startIndex">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of the str within String `s`.

	   `startIndex` is counted by code points.</haxe_doc>
		</uLastIndexOf>
		<uSplit public="1" get="inline" set="null" line="77" static="1">
			<f a="s:delimiter">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits String `s` at each occurence of `delimiter`.</haxe_doc>
		</uSplit>
		<uSubstr public="1" get="inline" set="null" line="90" static="1">
			<f a="s:startIndex:?length">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `length` characters of String `s`, starting at position `startIndex`.

	   `startIndex` and `length` are counted by code points.</haxe_doc>
		</uSubstr>
		<uSubstring public="1" get="inline" set="null" line="105" static="1">
			<f a="s:startIndex:?endIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of String `s` from `startIndex` to `endIndex`.

	   `startIndex` and `endIndex` are counted by code points.</haxe_doc>
		</uSubstring>
		<uIterator public="1" get="inline" set="null" line="117" static="1">
			<f a="s">
				<c path="String"/>
				<c path="lime._internal.unifill.CodePointIter"/>
			</f>
			<haxe_doc>Returns an iterator of the code points of String `s`.</haxe_doc>
		</uIterator>
		<uCompare public="1" set="method" line="124" static="1">
			<f a="a:b">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares String `a` and `b`.</haxe_doc>
		</uCompare>
		<uToString public="1" get="inline" set="null" line="145" static="1">
			<f a="codePoints">
				<t path="Iterable"><x path="lime._internal.unifill.CodePoint"/></t>
				<c path="String"/>
			</f>
			<haxe_doc>Converts `codePoints` to string.</haxe_doc>
		</uToString>
		<uAddChar public="1" get="inline" set="null" line="151" static="1">
			<f a="sb:c">
				<c path="StringBuf"/>
				<x path="lime._internal.unifill.CodePoint"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the character `c` to StringBuf `sb`.</haxe_doc>
		</uAddChar>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime._internal.unifill.Utf16" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Utf16.hx">
		<this><x path="lime._internal.unifill._Utf16.StringU16"/></this>
		<impl><class path="lime._internal.unifill._Utf16.Utf16_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Utf16.hx" private="1" module="lime._internal.unifill.Utf16">
	<fromCodePoint public="1" get="inline" set="null" line="8" static="1">
		<f a="codePoint">
			<x path="Int"/>
			<x path="lime._internal.unifill.Utf16"/>
		</f>
		<haxe_doc>Converts the code point `code` to a character as a Utf16 string.</haxe_doc>
	</fromCodePoint>
	<fromCodePoints public="1" get="inline" set="null" line="21" static="1">
		<f a="codePoints">
			<t path="Iterable"><x path="Int"/></t>
			<x path="lime._internal.unifill.Utf16"/>
		</f>
		<haxe_doc>Converts `codePoints` to a Utf16 string.</haxe_doc>
	</fromCodePoints>
	<fromString public="1" get="inline" set="null" line="29" static="1"><f a="s">
	<c path="String"/>
	<x path="lime._internal.unifill.Utf16"/>
</f></fromString>
	<fromArray public="1" get="inline" set="null" line="33" static="1"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<x path="lime._internal.unifill.Utf16"/>
</f></fromArray>
	<encodeWith public="1" get="inline" set="null" line="37" static="1"><f a="f:c">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></encodeWith>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<codeUnitAt public="1" get="inline" set="null" line="46" static="1">
		<f a="this:index">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the UTF-16 code unit at position `index` of `this`.</haxe_doc>
	</codeUnitAt>
	<codePointAt public="1" set="method" line="54" static="1">
		<f a="this:index">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the Unicode code point at position `index` of
	   `this`.</haxe_doc>
	</codePointAt>
	<charAt public="1" get="inline" set="null" line="62" static="1">
		<f a="this:index">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<x path="Int"/>
			<x path="lime._internal.unifill.Utf16"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the character as a String at position `index` of
	   `this`.</haxe_doc>
	</charAt>
	<codePointCount public="1" set="method" line="70" static="1">
		<f a="this:beginIndex:endIndex">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the number of Unicode code points from `beginIndex`
	   to `endIndex` in `this`.</haxe_doc>
	</codePointCount>
	<codePointWidthAt public="1" get="inline" set="null" line="84" static="1">
		<f a="this:index">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the number of units of the code point at position
	   `index` of `this`.</haxe_doc>
	</codePointWidthAt>
	<codePointWidthBefore public="1" get="inline" set="null" line="93" static="1">
		<f a="this:index">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the number of units of the code point before
	   position `index` of `this`.</haxe_doc>
	</codePointWidthBefore>
	<offsetByCodePoints public="1" get="inline" set="null" line="101" static="1">
		<f a="this:index:codePointOffset">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the index within `this` that is offset from
	   position `index` by `codePointOffset` code points.</haxe_doc>
	</offsetByCodePoints>
	<substr public="1" get="inline" set="null" line="112" static="1">
		<f a="this:index:?len">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime._internal.unifill.Utf16"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns `len` code units of `this`, starting at position pos.</haxe_doc>
	</substr>
	<validate public="1" set="method" line="122" static="1">
		<f a="this">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Validates `this` Utf16 string.

	   If the code unit sequence of `this` is invalid,
	   `Exception.InvalidCodeUnitSequence` is throwed.</haxe_doc>
	</validate>
	<toString public="1" get="inline" set="null" line="132" static="1">
		<f a="this">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<toArray public="1" get="inline" set="null" line="136" static="1">
		<f a="this">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<c path="Array"><x path="Int"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</toArray>
	<_new get="inline" set="null" line="140" static="1">
		<f a="s">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<x path="lime._internal.unifill.Utf16"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get_length get="inline" set="null" line="144" static="1">
		<f a="this">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<forward_offset_by_code_points get="inline" set="null" line="148" static="1">
		<f a="this:index:codePointOffset">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</forward_offset_by_code_points>
	<backward_offset_by_code_points get="inline" set="null" line="158" static="1">
		<f a="this:index:codePointOffset">
			<x path="lime._internal.unifill._Utf16.StringU16"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</backward_offset_by_code_points>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._internal.unifill._Utf16.Utf16_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Utf16.hx" private="1" module="lime._internal.unifill.Utf16">
		<fromCodePoint public="1" get="inline" set="null" line="8" static="1">
			<f a="codePoint">
				<x path="Int"/>
				<x path="lime._internal.unifill.Utf16"/>
			</f>
			<haxe_doc>Converts the code point `code` to a character as a Utf16 string.</haxe_doc>
		</fromCodePoint>
		<fromCodePoints public="1" get="inline" set="null" line="21" static="1">
			<f a="codePoints">
				<t path="Iterable"><x path="Int"/></t>
				<x path="lime._internal.unifill.Utf16"/>
			</f>
			<haxe_doc>Converts `codePoints` to a Utf16 string.</haxe_doc>
		</fromCodePoints>
		<fromString public="1" get="inline" set="null" line="29" static="1"><f a="s">
	<c path="String"/>
	<x path="lime._internal.unifill.Utf16"/>
</f></fromString>
		<fromArray public="1" get="inline" set="null" line="33" static="1"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<x path="lime._internal.unifill.Utf16"/>
</f></fromArray>
		<encodeWith public="1" get="inline" set="null" line="37" static="1"><f a="f:c">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></encodeWith>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<codeUnitAt public="1" get="inline" set="null" line="46" static="1">
			<f a="this:index">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the UTF-16 code unit at position `index` of `this`.</haxe_doc>
		</codeUnitAt>
		<codePointAt public="1" set="method" line="54" static="1">
			<f a="this:index">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the Unicode code point at position `index` of
	   `this`.</haxe_doc>
		</codePointAt>
		<charAt public="1" get="inline" set="null" line="62" static="1">
			<f a="this:index">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<x path="Int"/>
				<x path="lime._internal.unifill.Utf16"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the character as a String at position `index` of
	   `this`.</haxe_doc>
		</charAt>
		<codePointCount public="1" set="method" line="70" static="1">
			<f a="this:beginIndex:endIndex">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the number of Unicode code points from `beginIndex`
	   to `endIndex` in `this`.</haxe_doc>
		</codePointCount>
		<codePointWidthAt public="1" get="inline" set="null" line="84" static="1">
			<f a="this:index">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the number of units of the code point at position
	   `index` of `this`.</haxe_doc>
		</codePointWidthAt>
		<codePointWidthBefore public="1" get="inline" set="null" line="93" static="1">
			<f a="this:index">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the number of units of the code point before
	   position `index` of `this`.</haxe_doc>
		</codePointWidthBefore>
		<offsetByCodePoints public="1" get="inline" set="null" line="101" static="1">
			<f a="this:index:codePointOffset">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the index within `this` that is offset from
	   position `index` by `codePointOffset` code points.</haxe_doc>
		</offsetByCodePoints>
		<substr public="1" get="inline" set="null" line="112" static="1">
			<f a="this:index:?len">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime._internal.unifill.Utf16"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns `len` code units of `this`, starting at position pos.</haxe_doc>
		</substr>
		<validate public="1" set="method" line="122" static="1">
			<f a="this">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Validates `this` Utf16 string.

	   If the code unit sequence of `this` is invalid,
	   `Exception.InvalidCodeUnitSequence` is throwed.</haxe_doc>
		</validate>
		<toString public="1" get="inline" set="null" line="132" static="1">
			<f a="this">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<toArray public="1" get="inline" set="null" line="136" static="1">
			<f a="this">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</toArray>
		<_new get="inline" set="null" line="140" static="1">
			<f a="s">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<x path="lime._internal.unifill.Utf16"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get_length get="inline" set="null" line="144" static="1">
			<f a="this">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<forward_offset_by_code_points get="inline" set="null" line="148" static="1">
			<f a="this:index:codePointOffset">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</forward_offset_by_code_points>
		<backward_offset_by_code_points get="inline" set="null" line="158" static="1">
			<f a="this:index:codePointOffset">
				<x path="lime._internal.unifill._Utf16.StringU16"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</backward_offset_by_code_points>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="lime._internal.unifill._Utf16.Utf16Impl" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Utf16.hx" private="1" module="lime._internal.unifill.Utf16">
		<code_point_width public="1" get="inline" set="null" line="171" static="1"><f a="c">
	<x path="Int"/>
	<x path="Int"/>
</f></code_point_width>
		<find_prev_code_point public="1" get="inline" set="null" line="175" static="1"><f a="accessor:index">
	<f a="">
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
</f></find_prev_code_point>
		<encode_code_point public="1" get="inline" set="null" line="180" static="1"><f a="addUnit:codePoint">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></encode_code_point>
		<decode_code_point public="1" set="method" line="189" static="1"><f a="len:accessor:index">
	<x path="Int"/>
	<f a="">
		<x path="Int"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
</f></decode_code_point>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._internal.unifill._Utf16.StringU16Buffer" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Utf16.hx" private="1" module="lime._internal.unifill.Utf16">
		<this><c path="StringBuf"/></this>
		<impl><class path="lime._internal.unifill._Utf16.StringU16Buffer_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Utf16.hx" private="1" module="lime._internal.unifill.Utf16">
	<_new public="1" get="inline" set="null" line="216" static="1">
		<f a=""><x path="lime._internal.unifill._Utf16.StringU16Buffer"/></f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<addUnit public="1" get="inline" set="null" line="220" static="1">
		<f a="this:unit">
			<c path="StringBuf"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</addUnit>
	<getStringU16 public="1" get="inline" set="null" line="224" static="1">
		<f a="this">
			<c path="StringBuf"/>
			<x path="lime._internal.unifill._Utf16.StringU16"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getStringU16>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime._internal.unifill._Utf16.StringU16Buffer_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Utf16.hx" private="1" module="lime._internal.unifill.Utf16">
		<_new public="1" get="inline" set="null" line="216" static="1">
			<f a=""><x path="lime._internal.unifill._Utf16.StringU16Buffer"/></f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<addUnit public="1" get="inline" set="null" line="220" static="1">
			<f a="this:unit">
				<c path="StringBuf"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</addUnit>
		<getStringU16 public="1" get="inline" set="null" line="224" static="1">
			<f a="this">
				<c path="StringBuf"/>
				<x path="lime._internal.unifill._Utf16.StringU16"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getStringU16>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime._internal.unifill._Utf16.StringU16" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Utf16.hx" private="1" module="lime._internal.unifill.Utf16">
		<this><c path="String"/></this>
		<impl><class path="lime._internal.unifill._Utf16.StringU16_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Utf16.hx" private="1" module="lime._internal.unifill.Utf16">
	<fromString public="1" get="inline" set="null" line="232" static="1"><f a="s">
	<c path="String"/>
	<x path="lime._internal.unifill._Utf16.StringU16"/>
</f></fromString>
	<fromCodeUnit public="1" get="inline" set="null" line="236" static="1"><f a="u">
	<x path="Int"/>
	<x path="lime._internal.unifill._Utf16.StringU16"/>
</f></fromCodeUnit>
	<fromTwoCodeUnits public="1" get="inline" set="null" line="240" static="1"><f a="u0:u1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime._internal.unifill._Utf16.StringU16"/>
</f></fromTwoCodeUnits>
	<ofArray public="1" get="inline" set="null" line="244" static="1"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<x path="lime._internal.unifill._Utf16.StringU16"/>
</f></ofArray>
	<fromArray public="1" get="inline" set="null" line="248" static="1"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<x path="lime._internal.unifill._Utf16.StringU16"/>
</f></fromArray>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<codeUnitAt public="1" set="method" line="258" static="1">
		<f a="this:index">
			<c path="String"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</codeUnitAt>
	<substr public="1" get="inline" set="null" line="262" static="1">
		<f a="this:index:?len">
			<c path="String"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime._internal.unifill._Utf16.StringU16"/>
		</f>
		<meta><m n=":impl"/></meta>
	</substr>
	<toString public="1" get="inline" set="null" line="266" static="1">
		<f a="this">
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<toArray public="1" get="inline" set="null" line="270" static="1">
		<f a="this">
			<c path="String"/>
			<c path="Array"><x path="Int"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</toArray>
	<_new get="inline" set="null" line="276" static="1">
		<f a="s">
			<c path="String"/>
			<x path="lime._internal.unifill._Utf16.StringU16"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get_length get="inline" set="null" line="280" static="1">
		<f a="this">
			<c path="String"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._internal.unifill._Utf16.StringU16_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/_internal/unifill/Utf16.hx" private="1" module="lime._internal.unifill.Utf16">
		<fromString public="1" get="inline" set="null" line="232" static="1"><f a="s">
	<c path="String"/>
	<x path="lime._internal.unifill._Utf16.StringU16"/>
</f></fromString>
		<fromCodeUnit public="1" get="inline" set="null" line="236" static="1"><f a="u">
	<x path="Int"/>
	<x path="lime._internal.unifill._Utf16.StringU16"/>
</f></fromCodeUnit>
		<fromTwoCodeUnits public="1" get="inline" set="null" line="240" static="1"><f a="u0:u1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime._internal.unifill._Utf16.StringU16"/>
</f></fromTwoCodeUnits>
		<ofArray public="1" get="inline" set="null" line="244" static="1"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<x path="lime._internal.unifill._Utf16.StringU16"/>
</f></ofArray>
		<fromArray public="1" get="inline" set="null" line="248" static="1"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<x path="lime._internal.unifill._Utf16.StringU16"/>
</f></fromArray>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<codeUnitAt public="1" set="method" line="258" static="1">
			<f a="this:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</codeUnitAt>
		<substr public="1" get="inline" set="null" line="262" static="1">
			<f a="this:index:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime._internal.unifill._Utf16.StringU16"/>
			</f>
			<meta><m n=":impl"/></meta>
		</substr>
		<toString public="1" get="inline" set="null" line="266" static="1">
			<f a="this">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<toArray public="1" get="inline" set="null" line="270" static="1">
			<f a="this">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</toArray>
		<_new get="inline" set="null" line="276" static="1">
			<f a="s">
				<c path="String"/>
				<x path="lime._internal.unifill._Utf16.StringU16"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get_length get="inline" set="null" line="280" static="1">
			<f a="this">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="lime.app.IModule" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/app/IModule.hx" interface="1">
		<__registerLimeModule set="method">
			<f a="application">
				<c path="lime.app.Application"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>show</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__registerLimeModule>
		<__unregisterLimeModule set="method">
			<f a="application">
				<c path="lime.app.Application"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>show</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__unregisterLimeModule>
	</class>
	<class path="lime.app.Module" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/app/Module.hx">
		<implements path="lime.app.IModule"/>
		<onExit public="1" expr="new Event&lt;Int&gt;()">
			<c path="lime.app._Event_Int_Void"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int>()]]></e></m></meta>
			<haxe_doc>Exit events are dispatched when the application is exiting</haxe_doc>
		</onExit>
		<__registerLimeModule set="method" line="39">
			<f a="application">
				<c path="lime.app.Application"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__registerLimeModule>
		<__unregisterLimeModule set="method" line="40">
			<f a="application">
				<c path="lime.app.Application"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__unregisterLimeModule>
		<new public="1" set="method" line="32">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new `Module` instance</haxe_doc>
		</new>
		<haxe_doc>`Module` instances can be added to a running `Application`,
	simplifying support for adding new components, such as a renderer,
	input handler or higher-level framework.</haxe_doc>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app.Application" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/app/Application.hx">
		<extends path="lime.app.Module"/>
		<current public="1" set="null" static="1">
			<c path="lime.app.Application"/>
			<haxe_doc>The current Application instance that is executing</haxe_doc>
		</current>
		<meta public="1">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<haxe_doc>Meta-data values for the application, such as a version or a package name</haxe_doc>
		</meta>
		<modules public="1" set="null">
			<c path="Array"><c path="lime.app.IModule"/></c>
			<haxe_doc>A list of currently attached Module instances</haxe_doc>
		</modules>
		<onUpdate public="1" expr="new Event&lt;Int&gt;()">
			<c path="lime.app._Event_Int_Void"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int>()]]></e></m></meta>
			<haxe_doc>Update events are dispatched each frame (usually just before rendering)</haxe_doc>
		</onUpdate>
		<onCreateWindow public="1" expr="new Event&lt;Window&gt;()">
			<c path="lime.app._Event_lime_ui_Window_Void"><f a="">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Window>()]]></e></m></meta>
			<haxe_doc>Dispatched when a new window has been created by this application</haxe_doc>
		</onCreateWindow>
		<preloader public="1" get="accessor" set="null">
			<c path="lime.utils.Preloader"/>
			<haxe_doc>The Preloader for the current Application</haxe_doc>
		</preloader>
		<window public="1" get="accessor" set="null">
			<c path="lime.ui.Window"/>
			<haxe_doc>The Window associated with this Application, or the first Window
		if there are multiple Windows active</haxe_doc>
		</window>
		<windows public="1" get="accessor" set="null">
			<c path="Array"><c path="lime.ui.Window"/></c>
			<haxe_doc>A list of active Window instances associated with this Application</haxe_doc>
		</windows>
		<__backend>
			<t path="lime.app._Application.ApplicationBackend"/>
			<meta><m n=":noCompletion"/></meta>
		</__backend>
		<__preloader>
			<c path="lime.utils.Preloader"/>
			<meta><m n=":noCompletion"/></meta>
		</__preloader>
		<__window>
			<c path="lime.ui.Window"/>
			<meta><m n=":noCompletion"/></meta>
		</__window>
		<__windowByID>
			<t path="Map">
				<x path="Int"/>
				<c path="lime.ui.Window"/>
			</t>
			<meta><m n=":noCompletion"/></meta>
		</__windowByID>
		<__windows>
			<c path="Array"><c path="lime.ui.Window"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__windows>
		<addModule public="1" set="method" line="136">
			<f a="module">
				<c path="lime.app.IModule"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a new module to the Application
		@param	module	A module to add</haxe_doc>
		</addModule>
		<createWindow public="1" set="method" line="148">
			<f a="attributes">
				<t path="lime.ui.WindowAttributes"/>
				<c path="lime.ui.Window"/>
			</f>
			<haxe_doc>Creates a new Window and adds it to the Application
		@param	window	A Window object to add</haxe_doc>
		</createWindow>
		<exec public="1" set="method" line="163">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Execute the Application. On native platforms, this method
		blocks until the application is finished running. On other
		platforms, it will return immediately
		@return	An exit code, 0 if there was no error</haxe_doc>
		</exec>
		<onGamepadAxisMove public="1" set="method" line="178">
			<f a="gamepad:axis:value">
				<c path="lime.ui.Gamepad"/>
				<x path="lime.ui.GamepadAxis"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a gamepad axis move event is fired
		@param	gamepad	The current gamepad
		@param	axis	The axis that was moved
		@param	value	The axis value (between 0 and 1)</haxe_doc>
		</onGamepadAxisMove>
		<onGamepadButtonDown public="1" set="method" line="186">
			<f a="gamepad:button">
				<c path="lime.ui.Gamepad"/>
				<x path="lime.ui.GamepadButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a gamepad button down event is fired
		@param	gamepad	The current gamepad
		@param	button	The button that was pressed</haxe_doc>
		</onGamepadButtonDown>
		<onGamepadButtonUp public="1" set="method" line="194">
			<f a="gamepad:button">
				<c path="lime.ui.Gamepad"/>
				<x path="lime.ui.GamepadButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a gamepad button up event is fired
		@param	gamepad	The current gamepad
		@param	button	The button that was released</haxe_doc>
		</onGamepadButtonUp>
		<onGamepadConnect public="1" set="method" line="201">
			<f a="gamepad">
				<c path="lime.ui.Gamepad"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a gamepad is connected
		@param	gamepad	The gamepad that was connected</haxe_doc>
		</onGamepadConnect>
		<onGamepadDisconnect public="1" set="method" line="208">
			<f a="gamepad">
				<c path="lime.ui.Gamepad"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a gamepad is disconnected
		@param	gamepad	The gamepad that was disconnected</haxe_doc>
		</onGamepadDisconnect>
		<onJoystickAxisMove public="1" set="method" line="217">
			<f a="joystick:axis:value">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick axis move event is fired
		@param	joystick	The current joystick
		@param	axis	The axis that was moved
		@param	value	The axis value (between 0 and 1)</haxe_doc>
		</onJoystickAxisMove>
		<onJoystickButtonDown public="1" set="method" line="225">
			<f a="joystick:button">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick button down event is fired
		@param	joystick	The current joystick
		@param	button	The button that was pressed</haxe_doc>
		</onJoystickButtonDown>
		<onJoystickButtonUp public="1" set="method" line="233">
			<f a="joystick:button">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick button up event is fired
		@param	joystick	The current joystick
		@param	button	The button that was released</haxe_doc>
		</onJoystickButtonUp>
		<onJoystickConnect public="1" set="method" line="240">
			<f a="joystick">
				<c path="lime.ui.Joystick"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick is connected
		@param	joystick	The joystick that was connected</haxe_doc>
		</onJoystickConnect>
		<onJoystickDisconnect public="1" set="method" line="247">
			<f a="joystick">
				<c path="lime.ui.Joystick"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick is disconnected
		@param	joystick	The joystick that was disconnected</haxe_doc>
		</onJoystickDisconnect>
		<onJoystickHatMove public="1" set="method" line="256">
			<f a="joystick:hat:position">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="lime.ui.JoystickHatPosition"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick hat move event is fired
		@param	joystick	The current joystick
		@param	hat	The hat that was moved
		@param	position	The current hat position</haxe_doc>
		</onJoystickHatMove>
		<onJoystickTrackballMove public="1" set="method" line="266">
			<f a="joystick:trackball:x:y">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick axis move event is fired
		@param	joystick	The current joystick
		@param	trackball	The trackball that was moved
		@param	x	The x movement of the trackball (between 0 and 1)
		@param	y	The y movement of the trackball (between 0 and 1)</haxe_doc>
		</onJoystickTrackballMove>
		<onKeyDown public="1" set="method" line="274">
			<f a="keyCode:modifier">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyModifier"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a key down event is fired on the primary window
		@param	keyCode	The code of the key that was pressed
		@param	modifier	The modifier of the key that was pressed</haxe_doc>
		</onKeyDown>
		<onKeyUp public="1" set="method" line="282">
			<f a="keyCode:modifier">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyModifier"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a key up event is fired on the primary window
		@param	keyCode	The code of the key that was released
		@param	modifier	The modifier of the key that was released</haxe_doc>
		</onKeyUp>
		<onModuleExit public="1" set="method" line="288">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when the module is exiting</haxe_doc>
		</onModuleExit>
		<onMouseDown public="1" set="method" line="297">
			<f a="x:y:button">
				<x path="Float"/>
				<x path="Float"/>
				<x path="lime.ui.MouseButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a mouse down event is fired on the primary window
		@param	x	The current x coordinate of the mouse
		@param	y	The current y coordinate of the mouse
		@param	button	The ID of the mouse button that was pressed</haxe_doc>
		</onMouseDown>
		<onMouseMove public="1" set="method" line="306">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a mouse move event is fired on the primary window
		@param	x	The current x coordinate of the mouse
		@param	y	The current y coordinate of the mouse
		@param	button	The ID of the mouse button that was pressed</haxe_doc>
		</onMouseMove>
		<onMouseMoveRelative public="1" set="method" line="315">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a mouse move relative event is fired on the primary window
		@param	x	The x movement of the mouse
		@param	y	The y movement of the mouse
		@param	button	The ID of the mouse button that was pressed</haxe_doc>
		</onMouseMoveRelative>
		<onMouseUp public="1" set="method" line="324">
			<f a="x:y:button">
				<x path="Float"/>
				<x path="Float"/>
				<x path="lime.ui.MouseButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a mouse up event is fired on the primary window
		@param	x	The current x coordinate of the mouse
		@param	y	The current y coordinate of the mouse
		@param	button	The ID of the button that was released</haxe_doc>
		</onMouseUp>
		<onMouseWheel public="1" set="method" line="332">
			<f a="deltaX:deltaY:deltaMode">
				<x path="Float"/>
				<x path="Float"/>
				<e path="lime.ui.MouseWheelMode"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a mouse wheel event is fired on the primary window
		@param	deltaX	The amount of horizontal scrolling (if applicable)
		@param	deltaY	The amount of vertical scrolling (if applicable)</haxe_doc>
		</onMouseWheel>
		<onPreloadComplete public="1" set="method" line="338">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a preload complete event is fired</haxe_doc>
		</onPreloadComplete>
		<onPreloadProgress public="1" set="method" line="346">
			<f a="loaded:total">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a preload progress event is fired
		@param	loaded	The number of items that are loaded
		@param	total	The total number of items will be loaded</haxe_doc>
		</onPreloadProgress>
		<onRenderContextLost public="1" set="method" line="352">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a render context is lost on the primary window</haxe_doc>
		</onRenderContextLost>
		<onRenderContextRestored public="1" set="method" line="359">
			<f a="context">
				<c path="lime.graphics.RenderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a render context is restored on the primary window
		@param	context	The render context relevant to the event</haxe_doc>
		</onRenderContextRestored>
		<onTextEdit public="1" set="method" line="368">
			<f a="text:start:length">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a text edit event is fired on the primary window
		@param	text	The current replacement text
		@param	start	The starting index for the edit
		@param	length	The length of the edit</haxe_doc>
		</onTextEdit>
		<onTextInput public="1" set="method" line="375">
			<f a="text">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a text input event is fired on the primary window
		@param	text	The current input text</haxe_doc>
		</onTextInput>
		<onTouchCancel public="1" set="method" line="382">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a touch cancel event is fired
		@param	touch	The current touch object</haxe_doc>
		</onTouchCancel>
		<onTouchEnd public="1" set="method" line="389">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a touch end event is fired
		@param	touch	The current touch object</haxe_doc>
		</onTouchEnd>
		<onTouchMove public="1" set="method" line="396">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a touch move event is fired
		@param	touch	The current touch object</haxe_doc>
		</onTouchMove>
		<onTouchStart public="1" set="method" line="403">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a touch start event is fired
		@param	touch	The current touch object</haxe_doc>
		</onTouchStart>
		<onWindowActivate public="1" set="method" line="409">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window activate event is fired on the primary window</haxe_doc>
		</onWindowActivate>
		<onWindowClose public="1" set="method" line="415">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window close event is fired on the primary window</haxe_doc>
		</onWindowClose>
		<onWindowCreate public="1" set="method" line="421">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when the primary window is created</haxe_doc>
		</onWindowCreate>
		<onWindowDeactivate public="1" set="method" line="427">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window deactivate event is fired on the primary window</haxe_doc>
		</onWindowDeactivate>
		<onWindowDropFile public="1" set="method" line="433">
			<f a="file">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a window drop file event is fired on the primary window</haxe_doc>
		</onWindowDropFile>
		<onWindowEnter public="1" set="method" line="439">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window enter event is fired on the primary window</haxe_doc>
		</onWindowEnter>
		<onWindowExpose public="1" set="method" line="445">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window expose event is fired on the primary window</haxe_doc>
		</onWindowExpose>
		<onWindowFocusIn public="1" set="method" line="451">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window focus in event is fired on the primary window</haxe_doc>
		</onWindowFocusIn>
		<onWindowFocusOut public="1" set="method" line="457">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window focus out event is fired on the primary window</haxe_doc>
		</onWindowFocusOut>
		<onWindowFullscreen public="1" set="method" line="463">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when the primary window enters fullscreen</haxe_doc>
		</onWindowFullscreen>
		<onWindowLeave public="1" set="method" line="469">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window leave event is fired on the primary window</haxe_doc>
		</onWindowLeave>
		<onWindowMove public="1" set="method" line="477">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a window move event is fired on the primary window
		@param	x	The x position of the window in desktop coordinates
		@param	y	The y position of the window in desktop coordinates</haxe_doc>
		</onWindowMove>
		<onWindowMinimize public="1" set="method" line="483">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when the primary window is minimized</haxe_doc>
		</onWindowMinimize>
		<onWindowResize public="1" set="method" line="491">
			<f a="width:height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a window resize event is fired on the primary window
		@param	width	The width of the window
		@param	height	The height of the window</haxe_doc>
		</onWindowResize>
		<onWindowRestore public="1" set="method" line="497">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when the primary window is restored from being minimized or fullscreen</haxe_doc>
		</onWindowRestore>
		<removeModule public="1" set="method" line="504">
			<f a="module">
				<c path="lime.app.IModule"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes a module from the Application
		@param	module	A module to remove</haxe_doc>
		</removeModule>
		<render public="1" set="method" line="520">
			<f a="context">
				<c path="lime.graphics.RenderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a render event is fired on the primary window
		@param	context	The render context ready to be rendered</haxe_doc>
		</render>
		<update public="1" set="method" line="527">
			<f a="deltaTime">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when an update event is fired on the primary window
		@param	deltaTime	The amount of time in milliseconds that has elapsed since the last update</haxe_doc>
		</update>
		<__addWindow set="method" line="530">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__addWindow>
		<__createWindow set="method" line="580">
			<f a="attributes">
				<t path="lime.ui.WindowAttributes"/>
				<c path="lime.ui.Window"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__createWindow>
		<__registerLimeModule set="method" line="589" override="1">
			<f a="application">
				<c path="lime.app.Application"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__registerLimeModule>
		<__removeWindow set="method" line="619">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__removeWindow>
		<__onGamepadConnect set="method" line="646">
			<f a="gamepad">
				<c path="lime.ui.Gamepad"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onGamepadConnect>
		<__onJoystickConnect set="method" line="658">
			<f a="joystick">
				<c path="lime.ui.Joystick"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onJoystickConnect>
		<__onModuleExit set="method" line="672">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onModuleExit>
		<__onWindowClose set="method" line="679">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onWindowClose>
		<__unregisterLimeModule set="method" line="692" override="1">
			<f a="application">
				<c path="lime.app.Application"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__unregisterLimeModule>
		<get_preloader get="inline" set="null" line="717">
			<f a=""><c path="lime.utils.Preloader"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_preloader>
		<get_window get="inline" set="null" line="724">
			<f a=""><c path="lime.ui.Window"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_window>
		<get_windows get="inline" set="null" line="731">
			<f a=""><c path="Array"><c path="lime.ui.Window"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_windows>
		<new public="1" set="method" line="106">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Application instance</haxe_doc>
		</new>
		<haxe_doc>The Application class forms the foundation for most Lime projects.
	It is common to extend this class in a main class. It is then possible
	to override "on" functions in the class in order to handle standard events
	that are relevant.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.ui.Window</e></m>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<typedef path="lime.app._Application.ApplicationBackend" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/app/Application.hx" private="1" module="lime.app.Application">
		<c path="lime._internal.backend.flash.FlashApplication"/>
		<meta><m n=":noCompletion"/></meta>
	</typedef>
	<class path="lime.app.Event" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/app/Event.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__listeners public="1">
			<c path="Array"><c path="lime.app.Event.T"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__listeners>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<dispatch public="1">
			<d/>
			<haxe_doc><![CDATA[Dispatches a new event callback to all listeners. The signature for the
		`dispatch` method depends upon the type of the `Event`. For example, an
		`Event` of type `Int->Int->Void` will create a `dispatch` method that
		takes two `Int` arguments, like `dispatch (1, 2);`]]></haxe_doc>
		</dispatch>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app.Event.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app.Event.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Event is a strictly-typed signals and slots implementation, used for
	core event dispatching.

	For example:

	```haxe
	var event = new Event<Int->Void> ();
	event.add (function (value:Int):Void { trace (value); });
	event.dispatch (100);

	var event = new Event<Void->Void> ();
	event.add (function () { trace ("callback"); });
	event.dispatch ();
	```]]></haxe_doc>
		<meta>
			<m n=":genericBuild"><e>lime._internal.macros.EventMacro.build()</e></m>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app.Future" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/app/Future.hx">
		<ofEvents public="1" params="T" set="method" line="117" static="1">
			<f a="onComplete:?onError:?onProgress" v=":null:null">
				<c path="lime.app._Event_ofEvents_T_Void"><f a="">
	<c path="ofEvents.T"/>
	<x path="Void"/>
</f></c>
				<x path="Null"><c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c></x>
				<x path="Null"><c path="lime.app._Event_Int_Int_Void"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></x>
				<c path="lime.app.Future"><c path="ofEvents.T"/></c>
			</f>
			<meta><m n=":value"><e>{ onProgress : null, onError : null }</e></m></meta>
			<haxe_doc>Create a new `Future` instance based on complete and (optionally) error and/or progress `Event` instances</haxe_doc>
		</ofEvents>
		<withError public="1" set="method" line="340" static="1">
			<f a="error">
				<d/>
				<c path="lime.app.Future"><d/></c>
			</f>
			<haxe_doc>Creates a `Future` instance which has finished with an error value
		@param	error	The error value to set
		@return	A new `Future` instance</haxe_doc>
		</withError>
		<withValue public="1" params="T" set="method" line="355" static="1">
			<f a="value">
				<c path="withValue.T"/>
				<c path="lime.app.Future"><c path="withValue.T"/></c>
			</f>
			<haxe_doc>Creates a `Future` instance which has finished with a completion value
		@param	error	The completion value to set
		@return	A new `Future` instance</haxe_doc>
		</withValue>
		<error public="1" set="null">
			<d/>
			<haxe_doc>If the `Future` has finished with an error state, the `error` value</haxe_doc>
		</error>
		<isComplete public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the `Future` finished with a completion state</haxe_doc>
		</isComplete>
		<isError public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the `Future` finished with an error state</haxe_doc>
		</isError>
		<value public="1" set="null">
			<c path="lime.app.Future.T"/>
			<haxe_doc>If the `Future` has finished with a completion state, the completion `value`</haxe_doc>
		</value>
		<__completeListeners>
			<c path="Array"><f a="">
	<c path="lime.app.Future.T"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":noCompletion"/></meta>
		</__completeListeners>
		<__errorListeners>
			<c path="Array"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":noCompletion"/></meta>
		</__errorListeners>
		<__progressListeners>
			<c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":noCompletion"/></meta>
		</__progressListeners>
		<onComplete public="1" set="method" line="137">
			<f a="listener">
				<f a="">
					<c path="lime.app.Future.T"/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><c path="lime.app.Future.T"/></c>
			</f>
			<haxe_doc>Register a listener for when the `Future` completes.

		If the `Future` has already completed, this is called immediately with the result
		@param	listener	A callback method to receive the result value
		@return	The current `Future`</haxe_doc>
		</onComplete>
		<onError public="1" set="method" line="171">
			<f a="listener">
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><c path="lime.app.Future.T"/></c>
			</f>
			<haxe_doc>Register a listener for when the `Future` ends with an error state.

		If the `Future` has already ended with an error, this is called immediately with the error value
		@param	listener	A callback method to receive the error value
		@return	The current `Future`</haxe_doc>
		</onError>
		<onProgress public="1" set="method" line="205">
			<f a="listener">
				<f a=":">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><c path="lime.app.Future.T"/></c>
			</f>
			<haxe_doc>Register a listener for when the `Future` updates progress.

		If the `Future` is already completed, this will not be called.
		@param	listener	A callback method to receive the progress value
		@return	The current `Future`</haxe_doc>
		</onProgress>
		<ready public="1" set="method" line="229">
			<f a="?waitTime" v="-1">
				<x path="Int"/>
				<c path="lime.app.Future"><c path="lime.app.Future.T"/></c>
			</f>
			<meta><m n=":value"><e>{ waitTime : -1 }</e></m></meta>
			<haxe_doc>Attempts to block on an asynchronous `Future`, returning when it is completed.
		@param	waitTime	(Optional) A timeout before this call will stop blocking
		@return	This current `Future`</haxe_doc>
		</ready>
		<result public="1" set="method" line="279">
			<f a="?waitTime" v="-1">
				<x path="Int"/>
				<x path="Null"><c path="lime.app.Future.T"/></x>
			</f>
			<meta><m n=":value"><e>{ waitTime : -1 }</e></m></meta>
			<haxe_doc>Attempts to block on an asynchronous `Future`, returning the completion value when it is finished.
		@param	waitTime	(Optional) A timeout before this call will stop blocking
		@return	The completion value, or `null` if the request timed out or blocking is not possible</haxe_doc>
		</result>
		<then public="1" params="U" set="method" line="300">
			<f a="next">
				<f a="">
					<c path="lime.app.Future.T"/>
					<c path="lime.app.Future"><c path="then.U"/></c>
				</f>
				<c path="lime.app.Future"><c path="then.U"/></c>
			</f>
			<haxe_doc>Chains two `Future` instances together, passing the result from the first
		as input for creating/returning a new `Future` instance of a new or the same type</haxe_doc>
		</then>
		<new public="1" set="method" line="82">
			<f a="?work:?async" v="null:false">
				<f a=""><c path="lime.app.Future.T"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ async : false, work : null }</e></m></meta>
			<haxe_doc>Create a new `Future` instance
		@param	work	(Optional) A function to execute
		@param	async	(Optional) If a function is specified, whether to execute it asynchronously where supported</haxe_doc>
		</new>
		<haxe_doc>`Future` is an implementation of Futures and Promises, with the exception that
	in addition to "success" and "failure" states (represented as "complete" and "error"),
	Lime `Future` introduces "progress" feedback as well to increase the value of
	`Future` values.

	```haxe
	var future = Image.loadFromFile ("image.png");
	future.onComplete (function (image) { trace ("Image loaded"); });
	future.onProgress (function (loaded, total) { trace ("Loading: " + loaded + ", " + total); });
	future.onError (function (error) { trace (error); });

	Image.loadFromFile ("image.png").then (function (image) {

		return Future.withValue (image.width);

	}).onComplete (function (width) { trace (width); })
	```

	`Future` values can be chained together for asynchronous processing of values.

	If an error occurs earlier in the chain, the error is propagated to all `onError` callbacks.

	`Future` will call `onComplete` callbacks, even if completion occurred before registering the
	callback. This resolves race conditions, so even functions that return immediately can return
	values using `Future`.

	`Future` values are meant to be immutable, if you wish to update a `Future`, you should create one
	using a `Promise`, and use the `Promise` interface to influence the error, complete or progress state
	of a `Future`.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":allow"><e>lime.app.Promise</e></m>
		</meta>
	</class>
	<class path="lime.app._Future.FutureWork" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/app/Future.hx" private="1" module="lime.app.Future">
		<threadPool static="1"><c path="lime.system.ThreadPool"/></threadPool>
		<queue public="1" set="method" line="380" static="1">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</queue>
		<threadPool_doWork set="method" line="403" static="1"><f a="state">
	<d/>
	<x path="Void"/>
</f></threadPool_doWork>
		<threadPool_onComplete set="method" line="419" static="1"><f a="state">
	<d/>
	<x path="Void"/>
</f></threadPool_onComplete>
		<threadPool_onError set="method" line="426" static="1"><f a="state">
	<d/>
	<x path="Void"/>
</f></threadPool_onError>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="lime.app.Promise" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/app/Promise.hx">
		<future public="1" set="null">
			<c path="lime.app.Future"><c path="lime.app.Promise.T"/></c>
			<haxe_doc>The `Future` associated with this `Promise`.

		All subsequent calls to set an error, completion or progress state
		will update the status and notify listeners to this `Future`</haxe_doc>
		</future>
		<isComplete public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the `Promise` (and related `Future`) has finished with a completion state.
		This will be `false` if the `Promise` has not been resolved with a completion or error state.</haxe_doc>
		</isComplete>
		<isError public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the `Promise` (and related `Future`) has finished with an error state.
		This will be `false` if the `Promise` has not been resolved with a completion or error state.</haxe_doc>
		</isError>
		<complete public="1" set="method" line="105">
			<f a="data">
				<c path="lime.app.Promise.T"/>
				<c path="lime.app.Promise"><c path="lime.app.Promise.T"/></c>
			</f>
			<haxe_doc>Resolves this `Promise` with a completion state
		@param	data	The completion value
		@return	The current `Promise`</haxe_doc>
		</complete>
		<completeWith public="1" set="method" line="137">
			<f a="future">
				<c path="lime.app.Future"><c path="lime.app.Promise.T"/></c>
				<c path="lime.app.Promise"><c path="lime.app.Promise.T"/></c>
			</f>
			<haxe_doc>Resolves this `Promise` with the complete, error and/or progress state
		of another `Future`
		@param	future	The `Future` to use to resolve this `Promise`
		@return	The current `Promise`</haxe_doc>
		</completeWith>
		<error public="1" set="method" line="153">
			<f a="msg">
				<d/>
				<c path="lime.app.Promise"><c path="lime.app.Promise.T"/></c>
			</f>
			<haxe_doc>Resolves this `Promise` with an error state
		@param	msg	The error value
		@return	The current `Promise`</haxe_doc>
		</error>
		<progress public="1" set="method" line="185">
			<f a="progress:total">
				<x path="Int"/>
				<x path="Int"/>
				<c path="lime.app.Promise"><c path="lime.app.Promise.T"/></c>
			</f>
			<haxe_doc>Sends progress updates to the related `Future`
		@param	progress	A progress value
		@param	total	A total value. This should be equal or greater to the `progress` value
		@return	The current `Promise`</haxe_doc>
		</progress>
		<get_isComplete set="method" line="213">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isComplete>
		<get_isError set="method" line="220">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isError>
		<new public="1" set="method" line="93">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Create a new `Promise` instance</haxe_doc>
		</new>
		<haxe_doc><![CDATA[`Promise` is an implementation of Futures and Promises, with the exception that
	in addition to "success" and "failure" states (represented as "complete" and "error"),
	Lime `Future` introduces "progress" feedback as well to increase the value of
	`Future` values.

	While `Future` is meant to be read-only, `Promise` can be used to set the state of a future
	for receipients of it's `Future` object. For example:

	```haxe
	function examplePromise ():Future<String> {

		var promise = new Promise<String> ();

		var progress = 0, total = 10;
		var timer = new Timer (100);
		timer.run = function () {

			promise.progress (progress, total);
			progress++;

			if (progress == total) {

				promise.complete ("Done!");
				timer.stop ();

			}

		};

		return promise.future;

	}

	var future = examplePromise ();
	future.onComplete (function (message) { trace (message); });
	future.onProgress (function (loaded, total) { trace ("Progress: " + loaded + ", " + total); });
	```]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":allow"><e>lime.app.Future</e></m>
			<m n=":generic"/>
		</meta>
	</class>
	<class path="lime.app._Event_Array_String__Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/FileDialog.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Array_String__Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_Array_String__Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_Array_String__Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="37"><f a="a">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Dynamic_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/app/Future.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Dynamic_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_Dynamic_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_Dynamic_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="">
	<d/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="117"><f a="a">
	<d/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Float_Float_Float_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/system/Sensor.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Float_Float_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_Float_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_Float_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="19"><f a="a:a1:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Float_Float_Int_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Float_Float_Int_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_Int_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_Int_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="81"><f a="a:a1:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Float_Float_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Float_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="79"><f a="a:a1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Float_Float_lime_ui_MouseButton_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Float_Float_lime_ui_MouseButton_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_lime_ui_MouseButton_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_lime_ui_MouseButton_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.ui.MouseButton"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="78"><f a="a:a1:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.ui.MouseButton"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Float_Float_lime_ui_MouseWheelMode_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Float_Float_lime_ui_MouseWheelMode_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_lime_ui_MouseWheelMode_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_lime_ui_MouseWheelMode_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<e path="lime.ui.MouseWheelMode"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="82"><f a="a:a1:a2">
	<x path="Float"/>
	<x path="Float"/>
	<e path="lime.ui.MouseWheelMode"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Int_Float_Float_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Joystick.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Int_Float_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_Int_Float_Float_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_Int_Float_Float_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="34"><f a="a:a1:a2">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Int_Float_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Joystick.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Int_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_Int_Float_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_Int_Float_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="29"><f a="a:a1">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Int_Int_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/app/Future.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Int_Int_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_Int_Int_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_Int_Int_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="117"><f a="a:a1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Int_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/app/Application.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Int_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_Int_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_Int_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="57"><f a="a">
	<x path="Int"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Int_lime_ui_JoystickHatPosition_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Joystick.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Int_lime_ui_JoystickHatPosition_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_Int_lime_ui_JoystickHatPosition_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_Int_lime_ui_JoystickHatPosition_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="lime.ui.JoystickHatPosition"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="33"><f a="a:a1">
	<x path="Int"/>
	<x path="lime.ui.JoystickHatPosition"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_String_Int_Int_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_String_Int_Int_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_String_Int_Int_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_String_Int_Int_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="::">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="89"><f a="a:a1:a2">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_String_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_String_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_String_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_String_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="67"><f a="a">
	<c path="String"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Void_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Void_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_Void_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_Void_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a=""><x path="Void"/></f></c></__listeners>
		<dispatch public="1" set="method" line="64"><f a=""><x path="Void"/></f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_haxe_Function_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/system/ThreadPool.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_haxe_Function_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_haxe_Function_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_haxe_Function_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="">
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="26"><f a="a">
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_graphics_RenderContext_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_graphics_RenderContext_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_lime_graphics_RenderContext_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_lime_graphics_RenderContext_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="84"><f a="a">
	<c path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_GamepadAxis_Float_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Gamepad.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_GamepadAxis_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_GamepadAxis_Float_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_GamepadAxis_Float_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="lime.ui.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="26"><f a="a:a1">
	<x path="lime.ui.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_GamepadButton_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Gamepad.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_GamepadButton_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_GamepadButton_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_GamepadButton_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="">
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="27"><f a="a">
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_Gamepad_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Gamepad.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_Gamepad_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Gamepad_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Gamepad_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="20"><f a="a">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_Joystick_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Joystick.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_Joystick_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Joystick_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Joystick_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.ui.Joystick"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="19"><f a="a">
	<c path="lime.ui.Joystick"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="73"><f a="a:a1">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_Touch_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Touch.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_Touch_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Touch_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Touch_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="18"><f a="a">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_Window_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/app/Application.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_Window_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Window_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Window_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="62"><f a="a">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_utils_Resource_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/FileDialog.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_utils_Resource_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_lime_utils_Resource_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_lime_utils_Resource_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="">
	<x path="lime.utils.Resource"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="34"><f a="a">
	<x path="lime.utils.Resource"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_ofEvents_T_Void" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/app/Future.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="65">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_ofEvents_T_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="141">
			<f a="listener">
				<c path="lime.app._Event_ofEvents_T_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="160">
			<f a="listener">
				<c path="lime.app._Event_ofEvents_T_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.app._Event_ofEvents_T_Void.T"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="117"><f a="a">
	<c path="lime.app._Event_ofEvents_T_Void.T"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.graphics.FlashRenderContext" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/FlashRenderContext.hx">
		<from>
			<icast><c path="flash.display.Sprite"/></icast>
			<icast field="fromRenderContext"><c path="lime.graphics.RenderContext"/></icast>
		</from>
		<this><c path="flash.display.Sprite"/></this>
		<to><icast><c path="flash.display.Sprite"/></icast></to>
		<haxe_doc>The `FlashRenderContext` represents the primary `flash.display.Sprite` instance when
	targeting Flash Player.

	You can convert from `lime.graphics.RenderContext` to `FlashRenderContext` directly
	if desired:

	```haxe
	var sprite:FlashRenderContext = window.context;
	```</haxe_doc>
		<meta>
			<m n=":access"><e>lime.graphics.RenderContext</e></m>
			<m n=":forward"/>
		</meta>
		<impl><class path="lime.graphics._FlashRenderContext.FlashRenderContext_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/FlashRenderContext.hx" private="1" module="lime.graphics.FlashRenderContext">
	<fromRenderContext set="method" line="26" static="1">
		<f a="context">
			<c path="lime.graphics.RenderContext"/>
			<x path="lime.graphics.FlashRenderContext"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromRenderContext>
	<meta>
		<m n=":final"/>
		<m n=":access"><e>lime.graphics.RenderContext</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics._FlashRenderContext.FlashRenderContext_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/FlashRenderContext.hx" private="1" module="lime.graphics.FlashRenderContext">
		<fromRenderContext set="method" line="26" static="1">
			<f a="context">
				<c path="lime.graphics.RenderContext"/>
				<x path="lime.graphics.FlashRenderContext"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromRenderContext>
		<meta>
			<m n=":final"/>
			<m n=":access"><e>lime.graphics.RenderContext</e></m>
		</meta>
	</class>
	<class path="lime.graphics.Image" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/Image.hx">
		<__base64Chars expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;" line="100" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</e></m></meta>
		</__base64Chars>
		<__base64Encoder static="1"><c path="haxe.crypto.BaseCode"/></__base64Encoder>
		<fromBase64 public="1" set="method" line="676" static="1">
			<f a="base64:type">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.graphics.Image"/>
			</f>
			<haxe_doc>Converts a Base64-encoded `String` into an `Image`, or returns `null` if this is not possible
		@param	base64	A Base64-encoded `String`
		@param	type	A mime-type to describe the image data (such as "image/png")
		@return	A new `Image`, or `null` if conversion was not possible</haxe_doc>
		</fromBase64>
		<fromBitmapData public="1" set="method" line="693" static="1">
			<f a="bitmapData">
				<c path="flash.display.BitmapData"/>
				<c path="lime.graphics.Image"/>
			</f>
			<haxe_doc>Creates a new `Image` from a Flash `BitmapData` instance
		@param	bitmapData	A source `bitmapData` to use
		@return		A new `Image` instance</haxe_doc>
		</fromBitmapData>
		<fromBytes public="1" set="method" line="722" static="1">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<c path="lime.graphics.Image"/>
			</f>
			<haxe_doc>Converts a `Bytes` object to an `Image` instance

		Some platforms (such as Flash and HTML5) cannot convert `Bytes` to an
		`Image` synchronously, and may not work properly.

		`Image.loadFromBytes` works asynchronously, and should work
		consistently on all platforms.
		@param	bytes	A `Bytes` holding encoded image data
		@return	A new `Image` instance</haxe_doc>
		</fromBytes>
		<fromFile public="1" set="method" line="766" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lime.graphics.Image"/>
			</f>
			<haxe_doc>Loads an `Image` from a path synchronously.

		Some platforms, such as Flash and HTML5, cannot load
		images synchronously.

		`Image.loadFromFile` works asynchronously, and should
		behave consistently on all platforms.
		@param	path	The source file path or URL of an encoded image file
		@return	A new `Image` instance</haxe_doc>
		</fromFile>
		<loadFromBase64 public="1" set="method" line="1016" static="1">
			<f a="base64:type">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
			</f>
			<haxe_doc>Creates a new `Image` instance from a Base64-encoded `String`, asynchronously
		@param	base64	A Base64-encoded string representing encoded image data
		@param	type	The mime type of the encoded data (such as "image/png")
		@return	A `Future` to return a new `Image` instance</haxe_doc>
		</loadFromBase64>
		<loadFromBytes public="1" set="method" line="1038" static="1">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
			</f>
			<haxe_doc>Creates a new `Image` instance from image-encoded `Bytes`, loaded asynchronously
		@param	bytes	A `Bytes` instance
		@return	A `Future` to return a new `Image` instance</haxe_doc>
		</loadFromBytes>
		<loadFromFile public="1" set="method" line="1113" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
			</f>
			<haxe_doc>Creates a new `Image` instance from a file path or URL, loaded asynchronously
		@param	path	A file path or URL containing an encoded image
		@return	A `Future` to return a new `Image` instance</haxe_doc>
		</loadFromFile>
		<__base64Encode set="method" line="1572" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
</f></__base64Encode>
		<__isGIF set="method" line="1940" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></__isGIF>
		<__isJPG set="method" line="1950" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></__isJPG>
		<__isPNG set="method" line="1959" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></__isPNG>
		<__isWebP set="method" line="1968" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></__isWebP>
		<buffer public="1">
			<c path="lime.graphics.ImageBuffer"/>
			<haxe_doc>The `ImageBuffer` store that backs the `Image`</haxe_doc>
		</buffer>
		<data public="1" get="accessor" set="accessor">
			<x path="lime.utils.UInt8Array"/>
			<haxe_doc>Retrieves `UInt8Array` data from the `ImageBuffer`. If the `ImageBuffer`
		is not in a data format, it will be converted.</haxe_doc>
		</data>
		<dirty public="1">
			<x path="Bool"/>
			<haxe_doc>Whether the `Image` is dirty. This is set to `true` when pixel operations
		have been performed on the underlying `buffer`, and can be set to `false`
		again by your own renderer.</haxe_doc>
		</dirty>
		<format public="1" get="accessor" set="accessor">
			<x path="lime.graphics.PixelFormat"/>
			<haxe_doc>Get or set the `PixelFormat` for the underlying `ImageBuffer`. This can be
		used to convert the `ImageBuffer` to a new format.</haxe_doc>
		</format>
		<height public="1">
			<x path="Int"/>
			<haxe_doc>The logical height of the `Image`. This can be smaller than the `height`
		of the underlying `buffer`.</haxe_doc>
		</height>
		<offsetX public="1">
			<x path="Int"/>
			<haxe_doc>The offset X position of the `Image`, from the source `buffer`,
		when the `Image` is smaller than the full size of the source `buffer`</haxe_doc>
		</offsetX>
		<offsetY public="1">
			<x path="Int"/>
			<haxe_doc>The offset Y position of the `Image`, from the source `buffer`,
		when the `Image` is smaller than the full size of the source `buffer`</haxe_doc>
		</offsetY>
		<powerOfTwo public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Get or set whether the `ImageBuffer` dimensions are both a power-of-two
		(such as 2, 4, 8, 16, so on). Setting this value may resize the underlying
		`buffer`</haxe_doc>
		</powerOfTwo>
		<premultiplied public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Get or set whether this `Image` has premultiplied alpha. Setting this value
		may multiply or unmultiply data if the underlying `ImageBuffer` uses a
		different format.</haxe_doc>
		</premultiplied>
		<rect public="1" get="accessor" set="null">
			<c path="lime.math.Rectangle"/>
			<haxe_doc>The offset, width and height of this image as a `Rectangle`</haxe_doc>
		</rect>
		<src public="1" get="accessor" set="accessor">
			<d/>
			<haxe_doc>A higher-level representation of the source `ImageBuffer`. This might be an
		HTML5 Image, CanvasElement or a Flash BitmapData instance.</haxe_doc>
		</src>
		<transparent public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Get or set whether the underlying `ImageBuffer` is transparent.</haxe_doc>
		</transparent>
		<type public="1">
			<e path="lime.graphics.ImageType"/>
			<haxe_doc>The current `ImageType`, representing what is being used to store the `Image`'s graphics</haxe_doc>
		</type>
		<version public="1">
			<x path="Int"/>
			<haxe_doc>The `version` of the `Image` increases each time it is modified, helpful to determining
		whether a cache is out-of-date.</haxe_doc>
		</version>
		<width public="1">
			<x path="Int"/>
			<haxe_doc>The logical width of the `Image`. This can be smaller than the `width`
		of the underlying `buffer`.</haxe_doc>
		</width>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>A convenience property, unused internally, which may be helpful for different renderer
		implementations</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>A convenience property, unused internally, which may be helpful for different renderer
		implementations</haxe_doc>
		</y>
		<clone public="1" set="method" line="311">
			<f a=""><c path="lime.graphics.Image"/></f>
			<haxe_doc>Creates a duplicate copy of this `Image` and `ImageBuffer`
		@return	A new `Image` instance</haxe_doc>
		</clone>
		<colorTransform public="1" set="method" line="345">
			<f a="rect:colorMatrix">
				<c path="lime.math.Rectangle"/>
				<x path="lime.math.ColorMatrix"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Applies a color transform to the underlying `ImageBuffer` data
		@param	rect	The target rectangle to transform
		@param	colorMatrix	A `ColorMatrix` for color offset and/or multiplication</haxe_doc>
		</colorTransform>
		<copyChannel public="1" set="method" line="384">
			<f a="sourceImage:sourceRect:destPoint:sourceChannel:destChannel">
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<e path="lime.graphics.ImageChannel"/>
				<e path="lime.graphics.ImageChannel"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copy a color channel from one `Image` to another. This can also be within the same `Image` instance.
		@param	sourceImage	The `Image` to copy from
		@param	sourceRect	The source rectangle to copy from in the `sourceImage`
		@param	destPoint	The destination point to apply the channel in the current `Image`
		@param	sourceChannel	The source color channel to copy the data from
		@param	destChannel	The destination color channel to apply the data into</haxe_doc>
		</copyChannel>
		<copyPixels public="1" set="method" line="445">
			<f a="sourceImage:sourceRect:destPoint:?alphaImage:?alphaPoint:?mergeAlpha" v=":::null:null:false">
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false, alphaPoint : null, alphaImage : null }</e></m></meta>
			<haxe_doc>Copies pixels from one `Image` to another. The source `Image` can also be this `Image`
		@param	sourceImage	The source `Image` to copy from
		@param	sourceRect	The source rectangle to use when copying
		@param	destPoint	The destination point to use when copying
		@param	alphaImage	(Optional) A different `Image` to use as the alpha channel while copying
		@param	alphaPoint	(Optional) A point in the alpha image to use when copying
		@param	mergeAlpha	(Optional) Whether to blend the source and destination alpha (`true`), or to replace the destination alpha (`false`)</haxe_doc>
		</copyPixels>
		<encode public="1" set="method" line="550">
			<f a="?format:?quality" v="null:90">
				<e path="lime.graphics.ImageFileFormat"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ quality : 90, format : null }</e></m></meta>
			<haxe_doc>Encodes this `Image` into an image file format, such as PNG or JPEG.
		@param	format	(Optional) An `ImageFileFormat` to encode into (default is `PNG`)
		@param	quality	(Optional) A quality value to use when encoding as JPEG (from 0 to 100)
		@return	`Bytes` for the encoded `Image`, or `null` if encoding was not successful</haxe_doc>
		</encode>
		<fillRect public="1" set="method" line="581">
			<f a="rect:color:?format" v="::null">
				<c path="lime.math.Rectangle"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Fill a rectangle in the `Image` with a solid color
		@param	rect	A destination rectangle in this `Image` to fill
		@param	color	The color to use when filling this `Image`
		@param	format	(Optional) The `PixelFormat` that `color` is encoded in (default is `RGBA`)</haxe_doc>
		</fillRect>
		<floodFill public="1" set="method" line="633">
			<f a="x:y:color:?format" v=":::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Applies a flood fill to this `Image`, starting with the point specified.

		A flood fill behaves similarly to the "paint can" tool in many image editors,
		the fill will apply the chosen color to neighboring pixels of the same color.
		@param	x	The target x coordinate within the `Image` to use with the fill
		@param	y	The target y coordinate within the `Image` to use with the fill
		@param	color	The color to use when performing the fill
		@param	format	(Optional) The `PixelFormat` that `color` is encoded in (default is `RGBA`)</haxe_doc>
		</floodFill>
		<getColorBoundsRect public="1" set="method" line="808">
			<f a="mask:color:?findColor:?format" v="::true:null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="lime.graphics.PixelFormat"/>
				<c path="lime.math.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ format : null, findColor : true }</e></m></meta>
			<haxe_doc>Finds a region in the `Image` that includes pixels all of a certain color (when `findColor` is `true`) or
		excludes a certain color (`findColor` is `false`)
		@param	mask	A hexadecimal mask to use when comparing colors. You can use this to compare all of a color, or only certain color channels
		@param	color	The color value to use in comparisons
		@param	findColor	(Optional) Whether to find a region that does match the color (`true`) or excludes it (`false`)
		@param	format	(Optional) The `PixelFormat` that the `color` and `mask` are encoded in (default is `RGBA`)
		@return	The matching bounds `Rectangle`, or `null` if no matching region is found</haxe_doc>
		</getColorBoundsRect>
		<getPixel public="1" set="method" line="846">
			<f a="x:y:?format" v="::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Gets a 24-bit pixel from the `Image` (red, green and blue, but no alpha)
		@param	x	The `x` location to fetch
		@param	y	The `y` location to fetch
		@param	format	(Optional) The `PixelFormat` to encode the return value in (default is `RGBA`)
		@return	The specified pixel, or `0` if it is out-of-bounds</haxe_doc>
		</getPixel>
		<getPixel32 public="1" set="method" line="892">
			<f a="x:y:?format" v="::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Gets a 32-bit pixel from the `Image`, including alpha
		@param	x	The `x` location to fetch
		@param	y	The `y` location to fetch
		@param	format	(Optional) The `PixelFormat` to encode the return value in (default is `RGBA`)
		@return	The specified pixel, or `0` if it is out-of-bounds</haxe_doc>
		</getPixel32>
		<getPixels public="1" set="method" line="937">
			<f a="rect:?format" v=":null">
				<c path="lime.math.Rectangle"/>
				<x path="lime.graphics.PixelFormat"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Gets a region of pixels from the `Image`, as `Bytes`
		@param	rect	The source `Rectangle` to read from
		@param	format	(Optional) The `PixelFormat` to use when writing to the `Bytes` object (default is `RGBA`)
		@return	A `Bytes` object representing the region, or `null` if it is not possible to read</haxe_doc>
		</getPixels>
		<merge public="1" set="method" line="1202">
			<f a="sourceImage:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Blits a second `Image` onto this one, using optional color multipliers
		@param	sourceImage	An `Image` instance to copy from
		@param	sourceRect	The source rectangle to use when copying
		@param	destPoint	The destination point in this `Image` to copy into
		@param	redMultiplier	A red multiplier to use when blitting
		@param	greenMultiplier	A red multiplier to use when blitting
		@param	blueMultiplier	A red multiplier to use when blitting
		@param	alphaMultiplier	A red multiplier to use when blitting</haxe_doc>
		</merge>
		<resize public="1" set="method" line="1242">
			<f a="newWidth:newHeight">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Resizes the current `Image`, reallocating the `ImageBuffer` to a new size.
		The resize algorithm for most platforms is bilinear.
		@param	newWidth	A new width for the `Image`
		@param	newHeight	A new height for the `Image`</haxe_doc>
		</resize>
		<scroll public="1" set="method" line="1288">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scrolls the content of this `Image`.

		Pixels on the edges of the scroll will remain repeated, while others
		within the scroll area will be shifted

		@param	x	The amount of horizontal scroll to apply
		@param	y	The amount of vertical scroll to apply</haxe_doc>
		</scroll>
		<setPixel public="1" set="method" line="1320">
			<f a="x:y:color:?format" v=":::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Sets a pixel in the current `Image` in 24-bit color format (red, green, blue, no alpha)
		@param	x	The x coordinate of the pixel
		@param	y	The y coordinate of the pixel
		@param	color	The color to use
		@param	format	(Optional) The `PixelFormat` that `color` is encoded in (default is `RGBA`)</haxe_doc>
		</setPixel>
		<setPixel32 public="1" set="method" line="1364">
			<f a="x:y:color:?format" v=":::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Sets a pixel in the current `Image` in 32-bit color format (includes alpha)
		@param	x	The x coordinate of the pixel
		@param	y	The y coordinate of the pixel
		@param	color	The color to use
		@param	format	(Optional) The `PixelFormat` that `color` is encoded in (default is `RGBA`)</haxe_doc>
		</setPixel32>
		<setPixels public="1" set="method" line="1408">
			<f a="rect:bytePointer:?format:?endian" v="::null:null">
				<c path="lime.math.Rectangle"/>
				<x path="lime.utils.BytePointer"/>
				<x path="lime.graphics.PixelFormat"/>
				<e path="lime.system.Endian"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ endian : null, format : null }</e></m></meta>
			<haxe_doc>Sets a region of pixels at once using a `BytePointer`
		@param	rect	The region of pixels in this `Image` to replace with the incoming bytes
		@param	bytePointer	A `BytePointer` object referencing the `Bytes` and position to read from
		@param	format	(Optional) The `PixelFormat` that the pixels are encoded in (default is `RGBA`)
		@param	endian (Optional) The endianness of the incoming bytes (default is the system endianness)</haxe_doc>
		</setPixels>
		<threshold public="1" set="method" line="1525">
			<f a="sourceImage:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource:?format" v=":::::0x00000000:0xFFFFFFFF:false:null">
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ format : null, copySource : false, mask : 0xFFFFFFFF, color : 0x00000000 }</e></m></meta>
			<haxe_doc><![CDATA[Tests pixel values in an image against a specified threshold and sets
		pixels that pass the test to new color values. Using the
		`threshold()` method, you can isolate and replace color ranges
		in an image and perform other logical operations on image pixels.

		The `threshold()` method's test logic is as follows:

		 1. If `((pixelValue & mask) operation(threshold & mask))`,
		then set the pixel to `color`;
		 2. Otherwise, if `copySource == true`, then set the pixel to
		corresponding pixel value from `sourceBitmap`.

		The `operation` parameter specifies the comparison operator
		to use for the threshold test. For example, by using "==" as the
		`operation` parameter, you can isolate a specific color value
		in an image. Or by using `{operation: "<", mask: 0xFF000000,
		threshold: 0x7F000000, color: 0x00000000}`, you can set all
		destination pixels to be fully transparent when the source image pixel's
		alpha is less than 0x7F. You can use this technique for animated
		transitions and other effects.

		@param	sourceImage	The input bitmap image to use. The source image can be a different `Image` object or it can refer to the current `Image` instance.
		@param	sourceRect	A rectangle that defines the area of the source image to use as input.
		@param	destPoint	The point within the destination image (the current `Image` instance) that corresponds to the upper-left corner of the source rectangle.
		@param	operation	One of the following comparison operators, passed as a `String`: "<", "<=", ">", ">=", "==", "!="
		@param	threshold	The value that each pixel is tested against to see if it meets or exceeds the threshhold.
		@param	color	The color value that a pixel is set to if the threshold test succeeds. The default value is 0x00000000.
		@param	mask	The mask to use to isolate a color component.
		@param	copySource	If the value is `true`, pixel values from the source image are copied to the destination when the threshold test fails. If the value is `false`, the source image is not copied when the threshold test fails.
		@return	The number of pixels that were changed.]]></haxe_doc>
		</threshold>
		<__clipRect set="method" line="1601">
			<f a="r">
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__clipRect>
		<__fromBase64 set="method" line="1644">
			<f a="base64:type:?onload" v="::null">
				<c path="String"/>
				<c path="String"/>
				<f a="">
					<c path="lime.graphics.Image"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ onload : null }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__fromBase64>
		<__fromBytes set="method" line="1679">
			<f a="bytes:?onload" v=":null">
				<c path="haxe.io.Bytes"/>
				<f a="">
					<c path="lime.graphics.Image"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ onload : null }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__fromBytes>
		<__fromFile set="method" line="1740">
			<f a="path:?onload:?onerror" v=":null:null">
				<c path="String"/>
				<f a="">
					<c path="lime.graphics.Image"/>
					<x path="Void"/>
				</f>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ onerror : null, onload : null }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__fromFile>
		<__fromImageBuffer set="method" line="1917">
			<f a="buffer">
				<c path="lime.graphics.ImageBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromImageBuffer>
		<get_data set="method" line="1984">
			<f a=""><x path="lime.utils.UInt8Array"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_data>
		<set_data set="method" line="2006">
			<f a="value">
				<x path="lime.utils.UInt8Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_data>
		<get_format set="method" line="2013">
			<f a=""><x path="lime.graphics.PixelFormat"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_format>
		<set_format set="method" line="2020">
			<f a="value">
				<x path="lime.graphics.PixelFormat"/>
				<x path="lime.graphics.PixelFormat"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_format>
		<get_powerOfTwo set="method" line="2041">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_powerOfTwo>
		<set_powerOfTwo set="method" line="2048">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_powerOfTwo>
		<get_premultiplied set="method" line="2106">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_premultiplied>
		<set_premultiplied set="method" line="2113">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_premultiplied>
		<get_rect set="method" line="2158">
			<f a=""><c path="lime.math.Rectangle"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_rect>
		<get_src set="method" line="2165">
			<f a=""><d/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_src>
		<set_src set="method" line="2180">
			<f a="value">
				<d/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_src>
		<get_transparent set="method" line="2187">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_transparent>
		<set_transparent set="method" line="2195">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_transparent>
		<new public="1" set="method" line="235">
			<f a="?buffer:?offsetX:?offsetY:?width:?height:?color:?type" v="null:0:0:-1:-1:null:null">
				<c path="lime.graphics.ImageBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="lime.graphics.ImageType"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ type : null, color : null, height : -1, width : -1, offsetY : 0, offsetX : 0, buffer : null }</e></m></meta>
			<haxe_doc>Creates a new `Image` instance.

		If `buffer` is null, but `width` and `height` are set, a new `ImageBuffer` is allocated matching the `color` requested.
		@param	buffer	(Optional) The `ImageBuffer` this `Image` represents
		@param	offsetX	(Optional) A logical offset value within the `ImageBuffer` dimensions
		@param	offsetY	(Optional) A logical offset value within the `ImageBuffer` dimensions
		@param	width	(Optional) A logical width value within the `ImageBuffer` dimensions
		@param	height	(Optional) A logical height value within the `ImageBuffer` dimensions
		@param	color	(Optional) A fill color to use if the `buffer` property is `null`
		@param	type	(Optional) An `ImageType` to use for this `Image`</haxe_doc>
		</new>
		<haxe_doc>`Image` is a convenience class for working with bitmap images in Lime.

	Although `ImageBuffer` holds the actual bitmap data, `Image` includes convenience methods for
	loading from files, loading from bytes, and performing many pixel operations over an
	`ImageBuffer` instance.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":autoBuild"><e>lime._internal.macros.AssetsMacro.embedImage()</e></m>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":allow"><e>lime._internal.graphics.ImageCanvasUtil</e></m>
			<m n=":allow"><e>lime._internal.graphics.ImageDataUtil</e></m>
			<m n=":access"><e>lime.app.Application</e></m>
			<m n=":access"><e>lime.math.ColorMatrix</e></m>
			<m n=":access"><e>lime.math.Rectangle</e></m>
			<m n=":access"><e>lime.math.Vector2</e></m>
		</meta>
	</class>
	<class path="lime.graphics.ImageBuffer" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/ImageBuffer.hx">
		<bitsPerPixel public="1">
			<x path="Int"/>
			<haxe_doc>The number of bits per pixel in this image data</haxe_doc>
		</bitsPerPixel>
		<data public="1">
			<x path="lime.utils.UInt8Array"/>
			<haxe_doc>The data for this image, represented as a `UInt8Array`</haxe_doc>
		</data>
		<format public="1">
			<x path="lime.graphics.PixelFormat"/>
			<haxe_doc>The `PixelFormat` for this image data</haxe_doc>
		</format>
		<height public="1">
			<x path="Int"/>
			<haxe_doc>The height of this image data</haxe_doc>
		</height>
		<premultiplied public="1">
			<x path="Bool"/>
			<haxe_doc>Whether the image data has premultiplied alpha</haxe_doc>
		</premultiplied>
		<src public="1" get="accessor" set="accessor">
			<d/>
			<haxe_doc>The data for this image, represented as a `js.html.CanvasElement`, `js.html.Image` or `flash.display.BitmapData`</haxe_doc>
		</src>
		<stride public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The stride, or number of data values per row in the image data</haxe_doc>
		</stride>
		<transparent public="1">
			<x path="Bool"/>
			<haxe_doc>Whether this image data is transparent</haxe_doc>
		</transparent>
		<width public="1">
			<x path="Int"/>
			<haxe_doc>The width of this image data</haxe_doc>
		</width>
		<__srcBitmapData>
			<c path="flash.display.BitmapData"/>
			<meta><m n=":noCompletion"/></meta>
		</__srcBitmapData>
		<__srcCanvas>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcCanvas>
		<__srcContext>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcContext>
		<__srcCustom>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcCustom>
		<__srcImage>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcImage>
		<__srcImageData>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcImageData>
		<clone public="1" set="method" line="137">
			<f a=""><c path="lime.graphics.ImageBuffer"/></f>
			<haxe_doc>Creates a duplicate of this `ImageBuffer`

		If the current `ImageBuffer` has `data` or `src` information, this will be
		cloned as well.
		@return	A new `ImageBuffer` with duplicate values</haxe_doc>
		</clone>
		<get_src set="method" line="210">
			<f a=""><d/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_src>
		<set_src set="method" line="230">
			<f a="value">
				<d/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_src>
		<get_stride set="method" line="260">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_stride>
		<new public="1" set="method" line="117">
			<f a="?data:?width:?height:?bitsPerPixel:?format" v="null:0:0:32:null">
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null, bitsPerPixel : 32, height : 0, width : 0, data : null }</e></m></meta>
			<haxe_doc>Creates a new `ImageBuffer` instance
		@param	data	(Optional) Initial `UInt8Array` data
		@param	width	(Optional) An initial `width` value
		@param	height	(Optional) An initial `height` value
		@param	bitsPerPixel	(Optional) The `bitsPerPixel` of the data (default is 32)
		@param	format	(Optional) The `PixelFormat` of this image buffer</haxe_doc>
		</new>
		<haxe_doc>`ImageBuffer` is a simple object for storing image data.

	For higher-level operations, use the `Image` class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":allow"><e>lime.graphics.Image</e></m>
		</meta>
	</class>
	<enum path="lime.graphics.ImageChannel" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/ImageChannel.hx">
		<RED><haxe_doc>The red color channel</haxe_doc></RED>
		<GREEN><haxe_doc>The green color channel</haxe_doc></GREEN>
		<BLUE><haxe_doc>The blue color channel</haxe_doc></BLUE>
		<ALPHA><haxe_doc>The alpha color channel</haxe_doc></ALPHA>
		<haxe_doc>An enum with values for standard image color channels</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="lime.graphics.ImageFileFormat" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/ImageFileFormat.hx">
		<BMP><haxe_doc>An image file encoded in the BMP file format</haxe_doc></BMP>
		<JPEG><haxe_doc>An image file encoded in the JPEG file format</haxe_doc></JPEG>
		<PNG><haxe_doc>An image file encoded in the PNG file format</haxe_doc></PNG>
		<haxe_doc>An enum with values for image encoding formats</haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="lime.graphics.ImageType" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/ImageType.hx">
		<CANVAS><haxe_doc>The source image data is stored in a `js.html.Image` or `js.html.CanvasElement`</haxe_doc></CANVAS>
		<DATA><haxe_doc>The source image data is stored in a `UInt8Array`</haxe_doc></DATA>
		<FLASH><haxe_doc>The source image data is stored in a `flash.display.BitmapData`</haxe_doc></FLASH>
		<CUSTOM><haxe_doc>The source image data is stored in a custom format</haxe_doc></CUSTOM>
		<haxe_doc>An enum containing values for the underlying image type
	represented by an `ImageBuffer`</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="lime.graphics.PixelFormat" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/PixelFormat.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<haxe_doc>An enum containing different pixel encoding formats for image data</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics._PixelFormat.PixelFormat_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/PixelFormat.hx" private="1" module="lime.graphics.PixelFormat" extern="1">
	<RGBA32 public="1" get="inline" set="null" expr="cast 0" line="13" static="1">
		<x path="lime.graphics.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>An image encoded in 32-bit RGBA color order</haxe_doc>
	</RGBA32>
	<ARGB32 public="1" get="inline" set="null" expr="cast 1" line="18" static="1">
		<x path="lime.graphics.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>An image encoded in 32-bit ARGB color order</haxe_doc>
	</ARGB32>
	<BGRA32 public="1" get="inline" set="null" expr="cast 2" line="23" static="1">
		<x path="lime.graphics.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>An image encoded in 32-bit BGRA color order</haxe_doc>
	</BGRA32>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics._PixelFormat.PixelFormat_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/PixelFormat.hx" private="1" module="lime.graphics.PixelFormat" extern="1">
		<RGBA32 public="1" get="inline" set="null" expr="cast 0" line="13" static="1">
			<x path="lime.graphics.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>An image encoded in 32-bit RGBA color order</haxe_doc>
		</RGBA32>
		<ARGB32 public="1" get="inline" set="null" expr="cast 1" line="18" static="1">
			<x path="lime.graphics.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>An image encoded in 32-bit ARGB color order</haxe_doc>
		</ARGB32>
		<BGRA32 public="1" get="inline" set="null" expr="cast 2" line="23" static="1">
			<x path="lime.graphics.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>An image encoded in 32-bit BGRA color order</haxe_doc>
		</BGRA32>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.graphics.RenderContext" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/RenderContext.hx">
		<attributes public="1" set="null">
			<t path="lime.graphics.RenderContextAttributes"/>
			<haxe_doc>Additional information about the current context</haxe_doc>
		</attributes>
		<flash public="1" set="null">
			<x path="lime.graphics.FlashRenderContext"/>
			<haxe_doc>Access to the current Cairo render context, if available</haxe_doc>
		</flash>
		<type public="1" set="null">
			<x path="lime.graphics.RenderContextType"/>
			<haxe_doc>Access to the current OpenGL render API, if available</haxe_doc>
		</type>
		<version public="1" set="null"><c path="String"/></version>
		<window public="1" set="null">
			<c path="lime.ui.Window"/>
			<haxe_doc>Access to the current WebGL render API, if available</haxe_doc>
		</window>
		<new set="method" line="96">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</new>
		<haxe_doc>The `RenderContext` provides access to rendering for a Lime `Window`.

	Only one render context type is used at once, but when `OPENGL` or
	`OPENGLES` is the context type, compatibility contexts for other
	forms of GL (such as WebGL) may be available also.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="lime.graphics.RenderContextAttributes" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/RenderContextAttributes.hx">
		<a>
			<vsync>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether vertical-sync (VSync) is enabled</haxe_doc>
			</vsync>
			<version>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
			</version>
			<type>
				<x path="Null"><x path="lime.graphics.RenderContextType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type of render context requested</haxe_doc>
			</type>
			<stencil>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether a stencil buffer is enabled</haxe_doc>
			</stencil>
			<hardware>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether hardware acceleration is allowed</haxe_doc>
			</hardware>
			<depth>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether a depth buffer is enabled</haxe_doc>
			</depth>
			<colorDepth>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The color depth of the rendering context in bits</haxe_doc>
			</colorDepth>
			<background>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional `background` property to be provided to rendering,
		a value of `null` means no background color.</haxe_doc>
			</background>
			<antialiasing>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether to enable anti-aliasing, `0` is disabled, `2` enables
		2x2 anti-aliasing or `4` enables 4x4 anti-aliasing.</haxe_doc>
			</antialiasing>
		</a>
		<haxe_doc>Additional options possible for a render context</haxe_doc>
	</typedef>
	<abstract path="lime.graphics.RenderContextType" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/RenderContextType.hx">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<haxe_doc>An enum for possible render context types</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics._RenderContextType.RenderContextType_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/RenderContextType.hx" private="1" module="lime.graphics.RenderContextType" extern="1">
	<CAIRO public="1" get="inline" set="null" expr="cast &quot;cairo&quot;" line="13" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "cairo"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes a Cairo render context</haxe_doc>
	</CAIRO>
	<CANVAS public="1" get="inline" set="null" expr="cast &quot;canvas&quot;" line="18" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "canvas"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes an HTML5 canvas render context</haxe_doc>
	</CANVAS>
	<DOM public="1" get="inline" set="null" expr="cast &quot;dom&quot;" line="23" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "dom"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes an HTML5 DOM render context</haxe_doc>
	</DOM>
	<FLASH public="1" get="inline" set="null" expr="cast &quot;flash&quot;" line="28" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "flash"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes a Flash render context</haxe_doc>
	</FLASH>
	<OPENGL public="1" get="inline" set="null" expr="cast &quot;opengl&quot;" line="33" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "opengl"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes an OpenGL render context</haxe_doc>
	</OPENGL>
	<OPENGLES public="1" get="inline" set="null" expr="cast &quot;opengles&quot;" line="38" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "opengles"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes an OpenGL ES render context</haxe_doc>
	</OPENGLES>
	<WEBGL public="1" get="inline" set="null" expr="cast &quot;webgl&quot;" line="43" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "webgl"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes a WebGL render context</haxe_doc>
	</WEBGL>
	<CUSTOM public="1" get="inline" set="null" expr="cast &quot;custom&quot;" line="48" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "custom"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes a custom render context</haxe_doc>
	</CUSTOM>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics._RenderContextType.RenderContextType_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/graphics/RenderContextType.hx" private="1" module="lime.graphics.RenderContextType" extern="1">
		<CAIRO public="1" get="inline" set="null" expr="cast &quot;cairo&quot;" line="13" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "cairo"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes a Cairo render context</haxe_doc>
		</CAIRO>
		<CANVAS public="1" get="inline" set="null" expr="cast &quot;canvas&quot;" line="18" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "canvas"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes an HTML5 canvas render context</haxe_doc>
		</CANVAS>
		<DOM public="1" get="inline" set="null" expr="cast &quot;dom&quot;" line="23" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "dom"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes an HTML5 DOM render context</haxe_doc>
		</DOM>
		<FLASH public="1" get="inline" set="null" expr="cast &quot;flash&quot;" line="28" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "flash"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes a Flash render context</haxe_doc>
		</FLASH>
		<OPENGL public="1" get="inline" set="null" expr="cast &quot;opengl&quot;" line="33" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "opengl"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes an OpenGL render context</haxe_doc>
		</OPENGL>
		<OPENGLES public="1" get="inline" set="null" expr="cast &quot;opengles&quot;" line="38" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "opengles"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes an OpenGL ES render context</haxe_doc>
		</OPENGLES>
		<WEBGL public="1" get="inline" set="null" expr="cast &quot;webgl&quot;" line="43" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "webgl"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes a WebGL render context</haxe_doc>
		</WEBGL>
		<CUSTOM public="1" get="inline" set="null" expr="cast &quot;custom&quot;" line="48" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "custom"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes a custom render context</haxe_doc>
		</CUSTOM>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.math.ARGB" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/ARGB.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
			<icast field="__fromBGRA"><x path="lime.math.BGRA"/></icast>
			<icast field="__fromRGBA"><x path="lime.math.RGBA"/></icast>
		</from>
		<this><x path="UInt"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<haxe_doc>A utility for storing, accessing and converting colors in an ARGB
	(alpha, red, green, blue) color format.

	```haxe
	var color:ARGB = 0xFF883300;
	trace (color.a); // 0xFF
	trace (color.r); // 0x88
	trace (color.g); // 0x33
	trace (color.b); // 0x00

	var convert:BGRA = color; // 0x003388FF
	```</haxe_doc>
		<impl><class path="lime.math._ARGB.ARGB_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/ARGB.hx" private="1" module="lime.math.ARGB">
	<a16 static="1"><x path="Int"/></a16>
	<unmult static="1"><x path="Float"/></unmult>
	<a public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the alpha component of the color</haxe_doc>
	</a>
	<b public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the blue component of the color</haxe_doc>
	</b>
	<g public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the green component of the color</haxe_doc>
	</g>
	<r public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the red component of the color</haxe_doc>
	</r>
	<_new public="1" get="inline" set="null" line="55" static="1">
		<f a="?argb" v="0">
			<x path="Int"/>
			<x path="lime.math.ARGB"/>
		</f>
		<meta>
			<m n=":value"><e>{ argb : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new ARGB instance
		@param	argb	(Optional) An ARGB color value</haxe_doc>
	</_new>
	<create public="1" get="inline" set="null" line="70" static="1">
		<f a="a:r:g:b">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.math.ARGB"/>
		</f>
		<haxe_doc>Creates a new ARGB instance from component values
		@param	a	An alpha component value
		@param	r	A red component value
		@param	g	A green component value
		@param	b	A blue component value
		@return	A new ARGB instance</haxe_doc>
	</create>
	<multiplyAlpha public="1" get="inline" set="null" line="82" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Multiplies the red, green and blue components by the current alpha component</haxe_doc>
	</multiplyAlpha>
	<readUInt8 public="1" get="inline" set="null" line="105" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="UInt"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Reads a value from a `UInt8Array` into the current `ARGB` color
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to read
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
	</readUInt8>
	<set public="1" get="inline" set="null" line="139" static="1">
		<f a="this:a:r:g:b">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Sets the current `ARGB` color to new component values
		@param	a	The alpha component value to set
		@param	r	The red component value to set
		@param	g	The green component value to set
		@param	b	The blue component vlaue to set</haxe_doc>
	</set>
	<unmultiplyAlpha public="1" get="inline" set="null" line="149" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Divides the current red, green and blue components by the alpha component</haxe_doc>
	</unmultiplyAlpha>
	<writeUInt8 public="1" get="inline" set="null" line="168" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="UInt"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Writes the current `ARGB` color into a `UInt8Array`
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to write
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
	</writeUInt8>
	<__fromBGRA get="inline" set="null" line="204" static="1">
		<f a="bgra">
			<x path="lime.math.BGRA"/>
			<x path="lime.math.ARGB"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromBGRA>
	<__fromRGBA get="inline" set="null" line="211" static="1">
		<f a="rgba">
			<x path="lime.math.RGBA"/>
			<x path="lime.math.ARGB"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromRGBA>
	<get_a get="inline" set="null" line="225" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_a>
	<set_a get="inline" set="null" line="233" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_a>
	<get_b get="inline" set="null" line="241" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_b>
	<set_b get="inline" set="null" line="248" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_b>
	<get_g get="inline" set="null" line="256" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_g>
	<set_g get="inline" set="null" line="263" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_g>
	<get_r get="inline" set="null" line="271" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_r>
	<set_r get="inline" set="null" line="278" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_r>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.math._ARGB.ARGB_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/ARGB.hx" private="1" module="lime.math.ARGB">
		<a16 static="1"><x path="Int"/></a16>
		<unmult static="1"><x path="Float"/></unmult>
		<a public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the alpha component of the color</haxe_doc>
		</a>
		<b public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the blue component of the color</haxe_doc>
		</b>
		<g public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the green component of the color</haxe_doc>
		</g>
		<r public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the red component of the color</haxe_doc>
		</r>
		<_new public="1" get="inline" set="null" line="55" static="1">
			<f a="?argb" v="0">
				<x path="Int"/>
				<x path="lime.math.ARGB"/>
			</f>
			<meta>
				<m n=":value"><e>{ argb : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new ARGB instance
		@param	argb	(Optional) An ARGB color value</haxe_doc>
		</_new>
		<create public="1" get="inline" set="null" line="70" static="1">
			<f a="a:r:g:b">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.math.ARGB"/>
			</f>
			<haxe_doc>Creates a new ARGB instance from component values
		@param	a	An alpha component value
		@param	r	A red component value
		@param	g	A green component value
		@param	b	A blue component value
		@return	A new ARGB instance</haxe_doc>
		</create>
		<multiplyAlpha public="1" get="inline" set="null" line="82" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Multiplies the red, green and blue components by the current alpha component</haxe_doc>
		</multiplyAlpha>
		<readUInt8 public="1" get="inline" set="null" line="105" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="UInt"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Reads a value from a `UInt8Array` into the current `ARGB` color
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to read
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
		</readUInt8>
		<set public="1" get="inline" set="null" line="139" static="1">
			<f a="this:a:r:g:b">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Sets the current `ARGB` color to new component values
		@param	a	The alpha component value to set
		@param	r	The red component value to set
		@param	g	The green component value to set
		@param	b	The blue component vlaue to set</haxe_doc>
		</set>
		<unmultiplyAlpha public="1" get="inline" set="null" line="149" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Divides the current red, green and blue components by the alpha component</haxe_doc>
		</unmultiplyAlpha>
		<writeUInt8 public="1" get="inline" set="null" line="168" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="UInt"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Writes the current `ARGB` color into a `UInt8Array`
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to write
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
		</writeUInt8>
		<__fromBGRA get="inline" set="null" line="204" static="1">
			<f a="bgra">
				<x path="lime.math.BGRA"/>
				<x path="lime.math.ARGB"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromBGRA>
		<__fromRGBA get="inline" set="null" line="211" static="1">
			<f a="rgba">
				<x path="lime.math.RGBA"/>
				<x path="lime.math.ARGB"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromRGBA>
		<get_a get="inline" set="null" line="225" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_a>
		<set_a get="inline" set="null" line="233" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_a>
		<get_b get="inline" set="null" line="241" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_b>
		<set_b get="inline" set="null" line="248" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_b>
		<get_g get="inline" set="null" line="256" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_g>
		<set_g get="inline" set="null" line="263" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_g>
		<get_r get="inline" set="null" line="271" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_r>
		<set_r get="inline" set="null" line="278" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_r>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.math.BGRA" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/BGRA.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
			<icast field="__fromARGB"><x path="lime.math.ARGB"/></icast>
			<icast field="__fromRGBA"><x path="lime.math.RGBA"/></icast>
		</from>
		<this><x path="UInt"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<haxe_doc>A utility for storing, accessing and converting colors in a BGRA
	(blue, green, red, alpha) color format.

	```haxe
	var color:BGRA = 0x003388FF;
	trace (color.b); // 0x00
	trace (color.g); // 0x33
	trace (color.r); // 0x88
	trace (color.a); // 0xFF

	var convert:ARGB = color; // 0xFF883300
	```</haxe_doc>
		<impl><class path="lime.math._BGRA.BGRA_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/BGRA.hx" private="1" module="lime.math.BGRA">
	<a16 static="1"><x path="Int"/></a16>
	<unmult static="1"><x path="Float"/></unmult>
	<a public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the alpha component of the color</haxe_doc>
	</a>
	<b public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the blue component of the color</haxe_doc>
	</b>
	<g public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the green component of the color</haxe_doc>
	</g>
	<r public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the red component of the color</haxe_doc>
	</r>
	<_new public="1" get="inline" set="null" line="55" static="1">
		<f a="?bgra" v="0">
			<x path="Int"/>
			<x path="lime.math.BGRA"/>
		</f>
		<meta>
			<m n=":value"><e>{ bgra : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new BGRA instance
		@param	bgra	(Optional) A BGRA color value</haxe_doc>
	</_new>
	<create public="1" get="inline" set="null" line="70" static="1">
		<f a="b:g:r:a">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.math.BGRA"/>
		</f>
		<haxe_doc>Creates a new BGRA instance from component values
		@param	b	A blue component value
		@param	g	A green component value
		@param	r	A red component value
		@param	a	An alpha component value
		@return	A new BGRA instance</haxe_doc>
	</create>
	<multiplyAlpha public="1" get="inline" set="null" line="82" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Multiplies the red, green and blue components by the current alpha component</haxe_doc>
	</multiplyAlpha>
	<readUInt8 public="1" get="inline" set="null" line="105" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="UInt"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Reads a value from a `UInt8Array` into the current `BGRA` color
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to read
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
	</readUInt8>
	<set public="1" get="inline" set="null" line="139" static="1">
		<f a="this:b:g:r:a">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Sets the current `BGRA` color to new component values
		@param	b	The blue component vlaue to set
		@param	g	The green component value to set
		@param	r	The red component value to set
		@param	a	The alpha component value to set</haxe_doc>
	</set>
	<unmultiplyAlpha public="1" get="inline" set="null" line="149" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Divides the current red, green and blue components by the alpha component</haxe_doc>
	</unmultiplyAlpha>
	<writeUInt8 public="1" get="inline" set="null" line="168" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="UInt"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Writes the current `BGRA` color into a `UInt8Array`
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to write
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
	</writeUInt8>
	<__fromARGB get="inline" set="null" line="204" static="1">
		<f a="argb">
			<x path="lime.math.ARGB"/>
			<x path="lime.math.BGRA"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromARGB>
	<__fromRGBA get="inline" set="null" line="211" static="1">
		<f a="rgba">
			<x path="lime.math.RGBA"/>
			<x path="lime.math.BGRA"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromRGBA>
	<get_a get="inline" set="null" line="225" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_a>
	<set_a get="inline" set="null" line="232" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_a>
	<get_b get="inline" set="null" line="240" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_b>
	<set_b get="inline" set="null" line="247" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_b>
	<get_g get="inline" set="null" line="255" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_g>
	<set_g get="inline" set="null" line="262" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_g>
	<get_r get="inline" set="null" line="270" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_r>
	<set_r get="inline" set="null" line="277" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_r>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.math._BGRA.BGRA_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/BGRA.hx" private="1" module="lime.math.BGRA">
		<a16 static="1"><x path="Int"/></a16>
		<unmult static="1"><x path="Float"/></unmult>
		<a public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the alpha component of the color</haxe_doc>
		</a>
		<b public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the blue component of the color</haxe_doc>
		</b>
		<g public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the green component of the color</haxe_doc>
		</g>
		<r public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the red component of the color</haxe_doc>
		</r>
		<_new public="1" get="inline" set="null" line="55" static="1">
			<f a="?bgra" v="0">
				<x path="Int"/>
				<x path="lime.math.BGRA"/>
			</f>
			<meta>
				<m n=":value"><e>{ bgra : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new BGRA instance
		@param	bgra	(Optional) A BGRA color value</haxe_doc>
		</_new>
		<create public="1" get="inline" set="null" line="70" static="1">
			<f a="b:g:r:a">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.math.BGRA"/>
			</f>
			<haxe_doc>Creates a new BGRA instance from component values
		@param	b	A blue component value
		@param	g	A green component value
		@param	r	A red component value
		@param	a	An alpha component value
		@return	A new BGRA instance</haxe_doc>
		</create>
		<multiplyAlpha public="1" get="inline" set="null" line="82" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Multiplies the red, green and blue components by the current alpha component</haxe_doc>
		</multiplyAlpha>
		<readUInt8 public="1" get="inline" set="null" line="105" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="UInt"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Reads a value from a `UInt8Array` into the current `BGRA` color
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to read
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
		</readUInt8>
		<set public="1" get="inline" set="null" line="139" static="1">
			<f a="this:b:g:r:a">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Sets the current `BGRA` color to new component values
		@param	b	The blue component vlaue to set
		@param	g	The green component value to set
		@param	r	The red component value to set
		@param	a	The alpha component value to set</haxe_doc>
		</set>
		<unmultiplyAlpha public="1" get="inline" set="null" line="149" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Divides the current red, green and blue components by the alpha component</haxe_doc>
		</unmultiplyAlpha>
		<writeUInt8 public="1" get="inline" set="null" line="168" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="UInt"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Writes the current `BGRA` color into a `UInt8Array`
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to write
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
		</writeUInt8>
		<__fromARGB get="inline" set="null" line="204" static="1">
			<f a="argb">
				<x path="lime.math.ARGB"/>
				<x path="lime.math.BGRA"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromARGB>
		<__fromRGBA get="inline" set="null" line="211" static="1">
			<f a="rgba">
				<x path="lime.math.RGBA"/>
				<x path="lime.math.BGRA"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromRGBA>
		<get_a get="inline" set="null" line="225" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_a>
		<set_a get="inline" set="null" line="232" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_a>
		<get_b get="inline" set="null" line="240" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_b>
		<set_b get="inline" set="null" line="247" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_b>
		<get_g get="inline" set="null" line="255" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_g>
		<set_g get="inline" set="null" line="262" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_g>
		<get_r get="inline" set="null" line="270" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_r>
		<set_r get="inline" set="null" line="277" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_r>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.math.ColorMatrix" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/ColorMatrix.hx">
		<from><icast><x path="lime.utils.Float32Array"/></icast></from>
		<this><x path="lime.utils.Float32Array"/></this>
		<to><icast><x path="lime.utils.Float32Array"/></icast></to>
		<haxe_doc>`ColorMatrix` is a 4x5 matrix containing color multiplication
	and offset values for tinting and other kinds of color
	manipulation. In addition to using the multiplier, offset and
	`color` properties, it can be edited directly as a `Float32Array`</haxe_doc>
		<impl><class path="lime.math._ColorMatrix.ColorMatrix_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/ColorMatrix.hx" private="1" module="lime.math.ColorMatrix">
	<__alphaTable static="1"><x path="lime.utils.UInt8Array"/></__alphaTable>
	<__blueTable static="1"><x path="lime.utils.UInt8Array"/></__blueTable>
	<__greenTable static="1"><x path="lime.utils.UInt8Array"/></__greenTable>
	<__identity expr="[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]" line="25" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]</e></m></meta>
	</__identity>
	<__redTable static="1"><x path="lime.utils.UInt8Array"/></__redTable>
	<alphaMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current alpha multiplication value (default is 1.0)</haxe_doc>
	</alphaMultiplier>
	<alphaOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current alpha offset value (default is 0)</haxe_doc>
	</alphaOffset>
	<blueMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current blue multiplication value (default is 1.0)</haxe_doc>
	</blueMultiplier>
	<blueOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current blue offset value (default is 0)</haxe_doc>
	</blueOffset>
	<color public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Gets or sets a color offset for tinting.

		This will change the red, green and blue multipliers
		to zero, and affect the red, green and blue offset
		values.</haxe_doc>
	</color>
	<greenMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current green multiplication value (default is 1.0)</haxe_doc>
	</greenMultiplier>
	<greenOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current green offset value (default is 0)</haxe_doc>
	</greenOffset>
	<redMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current red multiplication value (default is 1.0)</haxe_doc>
	</redMultiplier>
	<redOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current red offset value (default is 0)</haxe_doc>
	</redOffset>
	<_new public="1" set="method" line="82" static="1">
		<f a="?data" v="null">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
		</f>
		<meta>
			<m n=":value"><e>{ data : null }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new `ColorMatrix` instance
		@param	data	(Optional) Initial `Float32Array` data to use</haxe_doc>
	</_new>
	<clone public="1" set="method" line="101" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Creates a duplicate of the current `ColorMatrix` instance
		@return	A new `ColorMatrix` instance</haxe_doc>
	</clone>
	<concat public="1" set="method" line="112" static="1">
		<f a="this:second">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Adds the color multipliers from a second `ColorMatrix` to the current one
		@param	second	The `ColorMatrix` to `concat` to the current one</haxe_doc>
	</concat>
	<copyFrom public="1" set="method" line="126" static="1">
		<f a="this:other">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Sets the current `ColorMatrix` values to the same as another one
		@param	other	The `ColorMatrix` to copy from</haxe_doc>
	</copyFrom>
	<identity public="1" set="method" line="136" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Resets to default values</haxe_doc>
	</identity>
	<getAlphaTable public="1" set="method" line="182" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		alpha values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `alphaMultipler` and `alphaOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.alphaOffset = 12;

		var alphaTable = colorMatrix.getAlphaTable ();
		trace (alphaTable[0]); // 12
		trace (alphaTable[1]); // 13
		```</haxe_doc>
	</getAlphaTable>
	<getBlueTable public="1" set="method" line="227" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		blue values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `blueMultiplier` and `blueOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.blueOffset = 16;

		var blueTable = colorMatrix.getBlueTable ();
		trace (blueTable[0]); // 16
		trace (blueTable[1]); // 17
		```</haxe_doc>
	</getBlueTable>
	<getGreenTable public="1" set="method" line="271" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		green values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `greenMultiplier` and `greenOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.greenOffset = 16;

		var greenTable = colorMatrix.getGreenTable ();
		trace (greenTable[0]); // 16
		trace (greenTable[1]); // 17
		```</haxe_doc>
	</getGreenTable>
	<getRedTable public="1" set="method" line="315" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		red values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `redMultiplier` and `redOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.redOffset = 16;

		var redTable = colorMatrix.getRedTable ();
		trace (redTable[0]); // 16
		trace (redTable[1]); // 17
		```</haxe_doc>
	</getRedTable>
	<__toFlashColorTransform set="method" line="339" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<c path="flash.geom.ColorTransform"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</__toFlashColorTransform>
	<get_alphaMultiplier get="inline" set="null" line="357" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_alphaMultiplier>
	<set_alphaMultiplier get="inline" set="null" line="364" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_alphaMultiplier>
	<get_alphaOffset get="inline" set="null" line="371" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_alphaOffset>
	<set_alphaOffset get="inline" set="null" line="378" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_alphaOffset>
	<get_blueMultiplier get="inline" set="null" line="385" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_blueMultiplier>
	<set_blueMultiplier get="inline" set="null" line="392" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_blueMultiplier>
	<get_blueOffset get="inline" set="null" line="399" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_blueOffset>
	<set_blueOffset get="inline" set="null" line="406" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_blueOffset>
	<get_color set="method" line="413" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_color>
	<set_color set="method" line="420" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_color>
	<get_greenMultiplier get="inline" set="null" line="435" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_greenMultiplier>
	<set_greenMultiplier get="inline" set="null" line="442" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_greenMultiplier>
	<get_greenOffset get="inline" set="null" line="449" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_greenOffset>
	<set_greenOffset get="inline" set="null" line="456" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_greenOffset>
	<get_redMultiplier get="inline" set="null" line="463" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_redMultiplier>
	<set_redMultiplier get="inline" set="null" line="470" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_redMultiplier>
	<get_redOffset get="inline" set="null" line="477" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_redOffset>
	<set_redOffset get="inline" set="null" line="484" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_redOffset>
	<get public="1" set="method" line="491" static="1">
		<f a="this:index">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set public="1" set="method" line="498" static="1">
		<f a="this:index:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.math._ColorMatrix.ColorMatrix_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/ColorMatrix.hx" private="1" module="lime.math.ColorMatrix">
		<__alphaTable static="1"><x path="lime.utils.UInt8Array"/></__alphaTable>
		<__blueTable static="1"><x path="lime.utils.UInt8Array"/></__blueTable>
		<__greenTable static="1"><x path="lime.utils.UInt8Array"/></__greenTable>
		<__identity expr="[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]" line="25" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]</e></m></meta>
		</__identity>
		<__redTable static="1"><x path="lime.utils.UInt8Array"/></__redTable>
		<alphaMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current alpha multiplication value (default is 1.0)</haxe_doc>
		</alphaMultiplier>
		<alphaOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current alpha offset value (default is 0)</haxe_doc>
		</alphaOffset>
		<blueMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current blue multiplication value (default is 1.0)</haxe_doc>
		</blueMultiplier>
		<blueOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current blue offset value (default is 0)</haxe_doc>
		</blueOffset>
		<color public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Gets or sets a color offset for tinting.

		This will change the red, green and blue multipliers
		to zero, and affect the red, green and blue offset
		values.</haxe_doc>
		</color>
		<greenMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current green multiplication value (default is 1.0)</haxe_doc>
		</greenMultiplier>
		<greenOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current green offset value (default is 0)</haxe_doc>
		</greenOffset>
		<redMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current red multiplication value (default is 1.0)</haxe_doc>
		</redMultiplier>
		<redOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current red offset value (default is 0)</haxe_doc>
		</redOffset>
		<_new public="1" set="method" line="82" static="1">
			<f a="?data" v="null">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
			</f>
			<meta>
				<m n=":value"><e>{ data : null }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new `ColorMatrix` instance
		@param	data	(Optional) Initial `Float32Array` data to use</haxe_doc>
		</_new>
		<clone public="1" set="method" line="101" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Creates a duplicate of the current `ColorMatrix` instance
		@return	A new `ColorMatrix` instance</haxe_doc>
		</clone>
		<concat public="1" set="method" line="112" static="1">
			<f a="this:second">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Adds the color multipliers from a second `ColorMatrix` to the current one
		@param	second	The `ColorMatrix` to `concat` to the current one</haxe_doc>
		</concat>
		<copyFrom public="1" set="method" line="126" static="1">
			<f a="this:other">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Sets the current `ColorMatrix` values to the same as another one
		@param	other	The `ColorMatrix` to copy from</haxe_doc>
		</copyFrom>
		<identity public="1" set="method" line="136" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Resets to default values</haxe_doc>
		</identity>
		<getAlphaTable public="1" set="method" line="182" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		alpha values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `alphaMultipler` and `alphaOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.alphaOffset = 12;

		var alphaTable = colorMatrix.getAlphaTable ();
		trace (alphaTable[0]); // 12
		trace (alphaTable[1]); // 13
		```</haxe_doc>
		</getAlphaTable>
		<getBlueTable public="1" set="method" line="227" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		blue values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `blueMultiplier` and `blueOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.blueOffset = 16;

		var blueTable = colorMatrix.getBlueTable ();
		trace (blueTable[0]); // 16
		trace (blueTable[1]); // 17
		```</haxe_doc>
		</getBlueTable>
		<getGreenTable public="1" set="method" line="271" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		green values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `greenMultiplier` and `greenOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.greenOffset = 16;

		var greenTable = colorMatrix.getGreenTable ();
		trace (greenTable[0]); // 16
		trace (greenTable[1]); // 17
		```</haxe_doc>
		</getGreenTable>
		<getRedTable public="1" set="method" line="315" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		red values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `redMultiplier` and `redOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.redOffset = 16;

		var redTable = colorMatrix.getRedTable ();
		trace (redTable[0]); // 16
		trace (redTable[1]); // 17
		```</haxe_doc>
		</getRedTable>
		<__toFlashColorTransform set="method" line="339" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<c path="flash.geom.ColorTransform"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</__toFlashColorTransform>
		<get_alphaMultiplier get="inline" set="null" line="357" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_alphaMultiplier>
		<set_alphaMultiplier get="inline" set="null" line="364" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_alphaMultiplier>
		<get_alphaOffset get="inline" set="null" line="371" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_alphaOffset>
		<set_alphaOffset get="inline" set="null" line="378" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_alphaOffset>
		<get_blueMultiplier get="inline" set="null" line="385" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_blueMultiplier>
		<set_blueMultiplier get="inline" set="null" line="392" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_blueMultiplier>
		<get_blueOffset get="inline" set="null" line="399" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_blueOffset>
		<set_blueOffset get="inline" set="null" line="406" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_blueOffset>
		<get_color set="method" line="413" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_color>
		<set_color set="method" line="420" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_color>
		<get_greenMultiplier get="inline" set="null" line="435" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_greenMultiplier>
		<set_greenMultiplier get="inline" set="null" line="442" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_greenMultiplier>
		<get_greenOffset get="inline" set="null" line="449" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_greenOffset>
		<set_greenOffset get="inline" set="null" line="456" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_greenOffset>
		<get_redMultiplier get="inline" set="null" line="463" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_redMultiplier>
		<set_redMultiplier get="inline" set="null" line="470" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_redMultiplier>
		<get_redOffset get="inline" set="null" line="477" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_redOffset>
		<set_redOffset get="inline" set="null" line="484" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_redOffset>
		<get public="1" set="method" line="491" static="1">
			<f a="this:index">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set public="1" set="method" line="498" static="1">
			<f a="this:index:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="lime.math.Matrix3" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/Matrix3.hx">
		<__identity expr="new Matrix3()" line="60" static="1">
			<c path="lime.math.Matrix3"/>
			<meta><m n=":value"><e>new Matrix3()</e></m></meta>
		</__identity>
		<a public="1">
			<x path="Float"/>
			<haxe_doc>The matrix a component, used in scaling and skewing (default is 1)</haxe_doc>
		</a>
		<b public="1">
			<x path="Float"/>
			<haxe_doc>The matrix b component, used in rotation and skewing (default is 0)</haxe_doc>
		</b>
		<c public="1">
			<x path="Float"/>
			<haxe_doc>The matrix c component, used in rotation and skewing (default is 0)</haxe_doc>
		</c>
		<d public="1">
			<x path="Float"/>
			<haxe_doc>The matrix d component, used in scaling and skewing (default is 1)</haxe_doc>
		</d>
		<tx public="1">
			<x path="Float"/>
			<haxe_doc>The matrix tx component, used in translation (default is 0)</haxe_doc>
		</tx>
		<ty public="1">
			<x path="Float"/>
			<haxe_doc>The matrix ty component, used in translation (default is 0)</haxe_doc>
		</ty>
		<clone public="1" get="inline" set="null" line="88">
			<f a=""><c path="lime.math.Matrix3"/></f>
			<haxe_doc>Creates a duplicate of the current `Matrix3`
		@return	A duplicate `Matrix3` instance</haxe_doc>
		</clone>
		<concat public="1" set="method" line="101">
			<f a="m">
				<c path="lime.math.Matrix3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Concatenates the values of a second matrix to the current
		`Matrix3`, combining the effects of both. This is the same
		as matrix multiplication. The second matrix is not modified.
		@param	m	A second `Matrix3` to concatenate to the current instance</haxe_doc>
		</concat>
		<copyColumnFrom public="1" set="method" line="125">
			<f a="column:vector4">
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the `x` and `y` components from a `Vector4` instance
		to the `a`/`c`, `b`/`d` or the `tx`/`ty` column of the current
		matrix
		@param	column	The column to copy into (0, 1 or 2)
		@param	vector4	The `Vector4` instance to copy from</haxe_doc>
		</copyColumnFrom>
		<copyColumnTo public="1" set="method" line="157">
			<f a="column:vector4">
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies a column of the current matrix into a `Vector4`
		instance. The `w` value will not be modified.
		@param	column	The column to copy from (0, 1 or 2)
		@param	vector4	The `Vector4` instance to copy to</haxe_doc>
		</copyColumnTo>
		<copyFrom public="1" set="method" line="191">
			<f a="sourceMatrix3">
				<c path="lime.math.Matrix3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the values of another `Matrix3` and
		applies it to the current instance
		@param	sourceMatrix3	The `Matrix3` to copy from</haxe_doc>
		</copyFrom>
		<copyRowFrom public="1" set="method" line="209">
			<f a="row:vector4">
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the values of a `Vector4` instance into a row
		of the current matrix
		@param	row	The row to copy into (0 or 1)
		@param	vector4	The `Vector4` instance to copy from</haxe_doc>
		</copyRowFrom>
		<copyRowTo public="1" set="method" line="238">
			<f a="row:vector4">
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies a row of the current matrix into a `Vector4`
		instance. The `w` value will not be modified.
		@param	row	The row to copy into (0, 1 or 2)
		@param	vector4	The `Vector4` instance to copy from</haxe_doc>
		</copyRowTo>
		<createBox public="1" set="method" line="276">
			<f a="scaleX:scaleY:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
			<haxe_doc>Applies a two-dimensional transformation to the current matrix.

		This is the same as calling `identity()`, `rotate()`, `scale()`
		then `translate()` with these values.
		@param	scaleX	An x scale transformation value
		@param	scaleY	A y scale transformation value
		@param	rotation (Optional) A rotation value (default is 0)
		@param	tx	(Optional) A translate x value (default is 0)
		@param	ty	(Optional) A translate y value (default is 0)</haxe_doc>
		</createBox>
		<createGradientBox public="1" set="method" line="312">
			<f a="width:height:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
			<haxe_doc>Creates a matrix to use for a linear gradient fill
		@param	width	The width of the gradient fill
		@param	height	The height of the gradient fill
		@param	rotation	(Optional) A rotation for the gradient fill (default is 0)
		@param	tx	(Optional) An x offset for the gradient fill (default is 0)
		@param	ty	(Optional) A y offset for the gradient fill (default is 0)
		@return	A new `Matrix` instance</haxe_doc>
		</createGradientBox>
		<equals public="1" set="method" line="345">
			<f a="matrix3">
				<c path="lime.math.Matrix3"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Check if two matrices have the same values
		@return	Whether both matrices are equal</haxe_doc>
		</equals>
		<deltaTransformVector public="1" set="method" line="358">
			<f a="Vector2:?result" v=":null">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Transforms a `Vector2` instance by the current matrix,
		without considering the `tx` and `ty` values of the matrix
		@param	result	(Optional) An existing `Vector2` instance to fill with the result
		@return	A new `Vector2` instance representing the transformed values</haxe_doc>
		</deltaTransformVector>
		<identity public="1" set="method" line="371">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Resets the matrix to default identity values</haxe_doc>
		</identity>
		<invert public="1" set="method" line="387">
			<f a=""><c path="lime.math.Matrix3"/></f>
			<haxe_doc>Inverts the values of the current matrix
		@return	The current matrix instance</haxe_doc>
		</invert>
		<rotate public="1" set="method" line="430">
			<f a="theta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Applies rotation to the current matrix
		@param	theta	A rotation value in degrees</haxe_doc>
		</rotate>
		<scale public="1" set="method" line="469">
			<f a="sx:sy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scales the current matrix
		@param	sx	The x scale to apply
		@param	sy	The y scale to apply</haxe_doc>
		</scale>
		<setRotation get="inline" set="null" line="490">
			<f a="theta:?scale" v=":1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ scale : 1 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</setRotation>
		<setTo public="1" get="inline" set="null" line="509">
			<f a="a:b:c:d:tx:ty">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the values of the current matrix
		@param	a	The new matrix a value
		@param	b	The new matrix b value
		@param	c	The new matrix c value
		@param	d	The new matrix d value
		@param	tx	The new matrix tx value
		@param	ty	The new matrix ty value</haxe_doc>
		</setTo>
		<to3DString public="1" get="inline" set="null" line="521">
			<f a="?roundPixels" v="false">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":value"><e>{ roundPixels : false }</e></m>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</to3DString>
		<toString public="1" get="inline" set="null" line="544">
			<f a=""><c path="String"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</toString>
		<transformRect public="1" set="method" line="559">
			<f a="rect:?result" v=":null">
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Transforms a `Rectangle` instance by the current matrix
		and returns `Rectangle` with the bounds of the transformed
		rectangle.
		@param	transform	A `Matrix3` instance to transform by
		@param	result	(Optional) A `Rectangle` instance to use for the result
		@return	A `Rectangle` represented the transformed bounds</haxe_doc>
		</transformRect>
		<transformVector public="1" set="method" line="603">
			<f a="pos:?result" v=":null">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Transforms a `Vector2` instance by the current matrix
		@param	result	(Optional) An existing `Vector2` instance to fill with the result
		@return	A new `Vector2` instance representing the transformed values</haxe_doc>
		</transformVector>
		<translate public="1" get="inline" set="null" line="618">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adjusts the `tx` and `ty` of the current matrix
		@param	dx	The x amount to translate
		@param	dy	The y amount to translate</haxe_doc>
		</translate>
		<new public="1" set="method" line="72">
			<f a="?a:?b:?c:?d:?tx:?ty" v="1:0:0:1:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, d : 1, c : 0, b : 0, a : 1 }</e></m></meta>
			<haxe_doc>Creates a new `Matrix` instance
		@param	a	(Optional) An initial a component value (default is 1)
		@param	b	(Optional) An initial b component value (default is 0)
		@param	c	(Optional) An initial c component value (default is 0)
		@param	d	(Optional) An initial d component value (default is 1)
		@param	tx	(Optional) An initial tx component value (default is 0)
		@param	ty	(Optional) An initial ty component value (default is 0)</haxe_doc>
		</new>
		<haxe_doc>`Matrix3` is a 3x3 transformation matrix particularly useful for
	two-dimensional transformation. It can be used for rotation, scale
	and skewing of a two-dimensional object.

	Although a 3x3 matrix is represented, configurable values can be
	considered as a 3x2 matrix:

	```
	[ a, c, tx ]
	[ c, d, ty ]
	[ 0, 0,  1 ]
	```</haxe_doc>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.math.Matrix4" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/Matrix4.hx">
		<from>
			<icast><x path="lime.utils.Float32Array"/></icast>
			<icast field="fromMatrix3"><c path="lime.math.Matrix3"/></icast>
		</from>
		<this><x path="lime.utils.Float32Array"/></this>
		<to><icast><x path="lime.utils.Float32Array"/></icast></to>
		<haxe_doc>`Matrix4` is a 4x4 matrix, useful for 3D calculations</haxe_doc>
		<impl><class path="lime.math._Matrix4.Matrix4_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/Matrix4.hx" private="1" module="lime.math.Matrix4">
	<__identity expr="[1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]" line="15" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]</e></m></meta>
	</__identity>
	<determinant public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Gets the determinant of the matrix</haxe_doc>
	</determinant>
	<position public="1" get="accessor" set="accessor" static="1">
		<c path="lime.math.Vector4"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Gets or sets the position value of this matrix</haxe_doc>
	</position>
	<_new public="1" set="method" line="32" static="1">
		<f a="?data" v="null">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta>
			<m n=":value"><e>{ data : null }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new matrix instance
		@param	data	(Optional) A `Float32Array` of 16 values to use for this matrix</haxe_doc>
	</_new>
	<append public="1" set="method" line="51" static="1">
		<f a="this:lhs">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Appends a second matrix by multiplying its values against the current one
		@param	lhs	A second matrix instance</haxe_doc>
	</append>
	<appendRotation public="1" set="method" line="91" static="1">
		<f a="this:degrees:axis:?pivotPoint" v=":::null">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ pivotPoint : null }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Appends rotation to the current matrix
		@param	degrees	A rotation value (in degrees)
		@param	axis	The coordinate position of the rotation axis
		@param	pivotPoint	(Optional) A pivot point to use in the rotation</haxe_doc>
	</appendRotation>
	<appendScale public="1" set="method" line="113" static="1">
		<f a="this:xScale:yScale:zScale">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Appends a scale value to the current matrix
		@param	xScale	The x scale to append
		@param	yScale	The y scale to append
		@param	zScale	The z scale to append</haxe_doc>
	</appendScale>
	<appendTranslation public="1" set="method" line="126" static="1">
		<f a="this:x:y:z">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Increases the position/translation of the current matrix
		@param	x	The x amount to offset the current position
		@param	y	The y amount to offset the current position
		@param	z	The z amount to offset the current position</haxe_doc>
	</appendTranslation>
	<clone public="1" set="method" line="139" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Creates a duplicate of the current `Matrix4`
		@return	A new `Matrix4` with the same values as the current matrix</haxe_doc>
	</clone>
	<copyColumnFrom public="1" set="method" line="151" static="1">
		<f a="this:column:vector">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Copies a column of data from a `Vector4` instance into the values of this matrix
		@param	column	The column to copy into (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy from</haxe_doc>
	</copyColumnFrom>
	<copyColumnTo public="1" set="method" line="197" static="1">
		<f a="this:column:vector">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Copies a column of data from the current matrix into a `Vector4` instance
		@param	column	The column to copy (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy to</haxe_doc>
	</copyColumnTo>
	<copyFrom public="1" set="method" line="242" static="1">
		<f a="this:other">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Copies the values of another `Matrix4` into the current matrix
		@param	other	A `Matrix4` instance to copy from</haxe_doc>
	</copyFrom>
	<copyRowFrom public="1" set="method" line="254" static="1">
		<f a="this:row:vector">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Copies a row of data from a `Vector4` instance into the values of this matrix
		@param	row	The row to copy into (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy from</haxe_doc>
	</copyRowFrom>
	<copyRowTo public="1" set="method" line="300" static="1">
		<f a="this:row:vector">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Copies a row of data from the current matrix into a `Vector4` instance
		@param	column	The row to copy (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy to</haxe_doc>
	</copyRowTo>
	<create2D public="1" set="method" line="350" static="1">
		<f a="this:a:b:c:d:?tx:?ty" v=":::::0:0">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ ty : 0, tx : 0 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Resets the current matrix using two-dimensional transform values
		@param	a	A two-dimensional matrix a value
		@param	b	A two-dimensional matrix b value
		@param	c	A two-dimensional matrix c value
		@param	d	A two-dimensional matrix d value
		@param	tx	(Optional) A two-dimensional matrix tx value (default is 0)
		@param	ty	(Optional) A two-dimensional matrix ty value (default is 0)</haxe_doc>
	</create2D>
	<createOrtho public="1" set="method" line="384" static="1">
		<f a="this:left:right:bottom:top:zNear:zFar">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Initializes this matrix with values for an orthographic projection, useful in rendering
		@param	left	The left (or x0) coordinate for the projection
		@param	right	The right (or x1) coordinate for the projection
		@param	bottom	The bottom (or y0) coordinate for the projection
		@param	top	The top (or y1) coordinate for the projection
		@param	zNear	The near depth-clipping plane position
		@param	zFar	The far depth-clipping plane position</haxe_doc>
	</createOrtho>
	<deltaTransformVector public="1" set="method" line="518" static="1">
		<f a="this:v:?result" v="::null">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta>
			<m n=":value"><e>{ result : null }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector4 objects.</haxe_doc>
	</deltaTransformVector>
	<fromMatrix3 public="1" set="method" line="530" static="1">
		<f a="matrix3">
			<c path="lime.math.Matrix3"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromMatrix3>
	<identity public="1" set="method" line="542" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Resets the current matrix using default identity values</haxe_doc>
	</identity>
	<interpolate public="1" set="method" line="572" static="1">
		<f a="thisMat:toMat:percent:?result" v=":::null">
			<x path="lime.math.Matrix4"/>
			<x path="lime.math.Matrix4"/>
			<x path="Float"/>
			<x path="lime.math.Matrix4"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta><m n=":value"><e>{ result : null }</e></m></meta>
		<haxe_doc>Interpolates from one `Matrix4` instance to another, given a percentage between the two
		@param	thisMat	The first `Matrix4` object to start from
		@param	toMat	The second `Matrix4` object to interpolate toward
		@param	percent	The percentage value to interpolate by
		@param	result	(Optional) A `Matrix4` instance to use when returning the result
		@return	A `Matrix4` with the resulting value</haxe_doc>
	</interpolate>
	<interpolateTo public="1" set="method" line="592" static="1">
		<f a="this:toMat:percent">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Interpolates the current matrix toward another matrix, resetting the values of the current matrix
		@param	toMat	The second `Matrix4` object to interpolate toward
		@param	percetn	The percentage value to interpolate by</haxe_doc>
	</interpolateTo>
	<invert public="1" set="method" line="607" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Attempts to invert the current matrix, so long as the determinant is greater than zero
		@return	Whether the `invert` operation was successful</haxe_doc>
	</invert>
	<pointAt public="1" set="method" line="651" static="1">
		<f a="this:pos:?at:?up" v="::null:null">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ up : null, at : null }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Sets the matrix values as a transformation orientated toward a certain vector position
		@param	pos	A target vector position in absolute coordinates
		@param	at	(Optional) A vector relative to this matrix which defines the current direction
		@param	up	(Optional) A vector relative to this matrix which defines the "up" direction</haxe_doc>
	</pointAt>
	<prepend public="1" set="method" line="724" static="1">
		<f a="this:rhs">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Prepends a right-hand matrix to the current matrix
		@param	rhx	A right-hand `Matrix4` to append</haxe_doc>
	</prepend>
	<prependRotation public="1" set="method" line="764" static="1">
		<f a="this:degrees:axis:?pivotPoint" v=":::null">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ pivotPoint : null }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Prepends rotation to this matrix
		@param	degrees	The rotation amount in degrees
		@param	axis	The rotation axis
		@param	pivotPoint	(Optional) A pivot point for the rotation</haxe_doc>
	</prependRotation>
	<prependScale public="1" set="method" line="786" static="1">
		<f a="this:xScale:yScale:zScale">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Prepends scale to this matrix
		@param	xScale	An x scale value
		@param	yScale	A y scale value
		@param	zScale	A z scale value</haxe_doc>
	</prependScale>
	<prependTranslation public="1" set="method" line="799" static="1">
		<f a="this:x:y:z">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Prepends translation values to this matrix
		@param	x	An x translation value
		@param	y	A y translation value
		@param	z	A z translation value</haxe_doc>
	</prependTranslation>
	<transformVector public="1" set="method" line="897" static="1">
		<f a="this:v:?result" v="::null">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta>
			<m n=":value"><e>{ result : null }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Transforms a `Vector4` instance using the current matrix
		@param	result	(Optional) An existing `Vector2` instance to fill with the result
		@return	The resulting `Vector4` instance</haxe_doc>
	</transformVector>
	<transformVectors public="1" set="method" line="915" static="1">
		<f a="this:ain:aout">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Transforms a series of [x, y, z] value pairs at once
		@param	ain	An input `Float32Array` to transform
		@param	aout	An output `Float32Array` to write to</haxe_doc>
	</transformVectors>
	<transpose public="1" set="method" line="940" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Transposes the current matrix</haxe_doc>
	</transpose>
	<__getAxisRotation set="method" line="952" static="1">
		<f a="this:x:y:z:degrees">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</__getAxisRotation>
	<__swap get="inline" set="null" line="984" static="1">
		<f a="this:a:b">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</__swap>
	<get_determinant set="method" line="1000" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_determinant>
	<get_position set="method" line="1012" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_position>
	<set_position set="method" line="1019" static="1">
		<f a="this:val">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_position>
	<get public="1" set="method" line="1029" static="1">
		<f a="this:index">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set public="1" set="method" line="1036" static="1">
		<f a="this:index:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.math._Matrix4.Matrix4_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/Matrix4.hx" private="1" module="lime.math.Matrix4">
		<__identity expr="[1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]" line="15" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]</e></m></meta>
		</__identity>
		<determinant public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Gets the determinant of the matrix</haxe_doc>
		</determinant>
		<position public="1" get="accessor" set="accessor" static="1">
			<c path="lime.math.Vector4"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Gets or sets the position value of this matrix</haxe_doc>
		</position>
		<_new public="1" set="method" line="32" static="1">
			<f a="?data" v="null">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta>
				<m n=":value"><e>{ data : null }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new matrix instance
		@param	data	(Optional) A `Float32Array` of 16 values to use for this matrix</haxe_doc>
		</_new>
		<append public="1" set="method" line="51" static="1">
			<f a="this:lhs">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Appends a second matrix by multiplying its values against the current one
		@param	lhs	A second matrix instance</haxe_doc>
		</append>
		<appendRotation public="1" set="method" line="91" static="1">
			<f a="this:degrees:axis:?pivotPoint" v=":::null">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ pivotPoint : null }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Appends rotation to the current matrix
		@param	degrees	A rotation value (in degrees)
		@param	axis	The coordinate position of the rotation axis
		@param	pivotPoint	(Optional) A pivot point to use in the rotation</haxe_doc>
		</appendRotation>
		<appendScale public="1" set="method" line="113" static="1">
			<f a="this:xScale:yScale:zScale">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Appends a scale value to the current matrix
		@param	xScale	The x scale to append
		@param	yScale	The y scale to append
		@param	zScale	The z scale to append</haxe_doc>
		</appendScale>
		<appendTranslation public="1" set="method" line="126" static="1">
			<f a="this:x:y:z">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Increases the position/translation of the current matrix
		@param	x	The x amount to offset the current position
		@param	y	The y amount to offset the current position
		@param	z	The z amount to offset the current position</haxe_doc>
		</appendTranslation>
		<clone public="1" set="method" line="139" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Creates a duplicate of the current `Matrix4`
		@return	A new `Matrix4` with the same values as the current matrix</haxe_doc>
		</clone>
		<copyColumnFrom public="1" set="method" line="151" static="1">
			<f a="this:column:vector">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Copies a column of data from a `Vector4` instance into the values of this matrix
		@param	column	The column to copy into (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy from</haxe_doc>
		</copyColumnFrom>
		<copyColumnTo public="1" set="method" line="197" static="1">
			<f a="this:column:vector">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Copies a column of data from the current matrix into a `Vector4` instance
		@param	column	The column to copy (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy to</haxe_doc>
		</copyColumnTo>
		<copyFrom public="1" set="method" line="242" static="1">
			<f a="this:other">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Copies the values of another `Matrix4` into the current matrix
		@param	other	A `Matrix4` instance to copy from</haxe_doc>
		</copyFrom>
		<copyRowFrom public="1" set="method" line="254" static="1">
			<f a="this:row:vector">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Copies a row of data from a `Vector4` instance into the values of this matrix
		@param	row	The row to copy into (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy from</haxe_doc>
		</copyRowFrom>
		<copyRowTo public="1" set="method" line="300" static="1">
			<f a="this:row:vector">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Copies a row of data from the current matrix into a `Vector4` instance
		@param	column	The row to copy (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy to</haxe_doc>
		</copyRowTo>
		<create2D public="1" set="method" line="350" static="1">
			<f a="this:a:b:c:d:?tx:?ty" v=":::::0:0">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ ty : 0, tx : 0 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Resets the current matrix using two-dimensional transform values
		@param	a	A two-dimensional matrix a value
		@param	b	A two-dimensional matrix b value
		@param	c	A two-dimensional matrix c value
		@param	d	A two-dimensional matrix d value
		@param	tx	(Optional) A two-dimensional matrix tx value (default is 0)
		@param	ty	(Optional) A two-dimensional matrix ty value (default is 0)</haxe_doc>
		</create2D>
		<createOrtho public="1" set="method" line="384" static="1">
			<f a="this:left:right:bottom:top:zNear:zFar">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Initializes this matrix with values for an orthographic projection, useful in rendering
		@param	left	The left (or x0) coordinate for the projection
		@param	right	The right (or x1) coordinate for the projection
		@param	bottom	The bottom (or y0) coordinate for the projection
		@param	top	The top (or y1) coordinate for the projection
		@param	zNear	The near depth-clipping plane position
		@param	zFar	The far depth-clipping plane position</haxe_doc>
		</createOrtho>
		<deltaTransformVector public="1" set="method" line="518" static="1">
			<f a="this:v:?result" v="::null">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta>
				<m n=":value"><e>{ result : null }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector4 objects.</haxe_doc>
		</deltaTransformVector>
		<fromMatrix3 public="1" set="method" line="530" static="1">
			<f a="matrix3">
				<c path="lime.math.Matrix3"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromMatrix3>
		<identity public="1" set="method" line="542" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Resets the current matrix using default identity values</haxe_doc>
		</identity>
		<interpolate public="1" set="method" line="572" static="1">
			<f a="thisMat:toMat:percent:?result" v=":::null">
				<x path="lime.math.Matrix4"/>
				<x path="lime.math.Matrix4"/>
				<x path="Float"/>
				<x path="lime.math.Matrix4"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Interpolates from one `Matrix4` instance to another, given a percentage between the two
		@param	thisMat	The first `Matrix4` object to start from
		@param	toMat	The second `Matrix4` object to interpolate toward
		@param	percent	The percentage value to interpolate by
		@param	result	(Optional) A `Matrix4` instance to use when returning the result
		@return	A `Matrix4` with the resulting value</haxe_doc>
		</interpolate>
		<interpolateTo public="1" set="method" line="592" static="1">
			<f a="this:toMat:percent">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Interpolates the current matrix toward another matrix, resetting the values of the current matrix
		@param	toMat	The second `Matrix4` object to interpolate toward
		@param	percetn	The percentage value to interpolate by</haxe_doc>
		</interpolateTo>
		<invert public="1" set="method" line="607" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Attempts to invert the current matrix, so long as the determinant is greater than zero
		@return	Whether the `invert` operation was successful</haxe_doc>
		</invert>
		<pointAt public="1" set="method" line="651" static="1">
			<f a="this:pos:?at:?up" v="::null:null">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ up : null, at : null }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Sets the matrix values as a transformation orientated toward a certain vector position
		@param	pos	A target vector position in absolute coordinates
		@param	at	(Optional) A vector relative to this matrix which defines the current direction
		@param	up	(Optional) A vector relative to this matrix which defines the "up" direction</haxe_doc>
		</pointAt>
		<prepend public="1" set="method" line="724" static="1">
			<f a="this:rhs">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Prepends a right-hand matrix to the current matrix
		@param	rhx	A right-hand `Matrix4` to append</haxe_doc>
		</prepend>
		<prependRotation public="1" set="method" line="764" static="1">
			<f a="this:degrees:axis:?pivotPoint" v=":::null">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ pivotPoint : null }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Prepends rotation to this matrix
		@param	degrees	The rotation amount in degrees
		@param	axis	The rotation axis
		@param	pivotPoint	(Optional) A pivot point for the rotation</haxe_doc>
		</prependRotation>
		<prependScale public="1" set="method" line="786" static="1">
			<f a="this:xScale:yScale:zScale">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Prepends scale to this matrix
		@param	xScale	An x scale value
		@param	yScale	A y scale value
		@param	zScale	A z scale value</haxe_doc>
		</prependScale>
		<prependTranslation public="1" set="method" line="799" static="1">
			<f a="this:x:y:z">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Prepends translation values to this matrix
		@param	x	An x translation value
		@param	y	A y translation value
		@param	z	A z translation value</haxe_doc>
		</prependTranslation>
		<transformVector public="1" set="method" line="897" static="1">
			<f a="this:v:?result" v="::null">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta>
				<m n=":value"><e>{ result : null }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Transforms a `Vector4` instance using the current matrix
		@param	result	(Optional) An existing `Vector2` instance to fill with the result
		@return	The resulting `Vector4` instance</haxe_doc>
		</transformVector>
		<transformVectors public="1" set="method" line="915" static="1">
			<f a="this:ain:aout">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Transforms a series of [x, y, z] value pairs at once
		@param	ain	An input `Float32Array` to transform
		@param	aout	An output `Float32Array` to write to</haxe_doc>
		</transformVectors>
		<transpose public="1" set="method" line="940" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Transposes the current matrix</haxe_doc>
		</transpose>
		<__getAxisRotation set="method" line="952" static="1">
			<f a="this:x:y:z:degrees">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</__getAxisRotation>
		<__swap get="inline" set="null" line="984" static="1">
			<f a="this:a:b">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</__swap>
		<get_determinant set="method" line="1000" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_determinant>
		<get_position set="method" line="1012" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_position>
		<set_position set="method" line="1019" static="1">
			<f a="this:val">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_position>
		<get public="1" set="method" line="1029" static="1">
			<f a="this:index">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set public="1" set="method" line="1036" static="1">
			<f a="this:index:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.math.RGBA" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/RGBA.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
			<icast field="__fromARGB"><x path="lime.math.ARGB"/></icast>
			<icast field="__fromBGRA"><x path="lime.math.BGRA"/></icast>
		</from>
		<this><x path="UInt"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<haxe_doc>A utility for storing, accessing and converting colors in an RGBA
	(red, green, blue, alpha) color format.

	```haxe
	var color:RGBA = 0x883300FF;
	trace (color.r); // 0x88
	trace (color.g); // 0x33
	trace (color.b); // 0x00
	trace (color.a); // 0xFF

	var convert:ARGB = color; // 0xFF883300
	```</haxe_doc>
		<meta><m n=":allow"><e>lime.math</e></m></meta>
		<impl><class path="lime.math._RGBA.RGBA_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/RGBA.hx" private="1" module="lime.math.RGBA">
	<__alpha16 static="1"><x path="lime.utils.UInt32Array"/></__alpha16>
	<__clamp static="1"><x path="lime.utils.UInt8Array"/></__clamp>
	<a16 static="1"><x path="Int"/></a16>
	<unmult static="1"><x path="Float"/></unmult>
	<a public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the alpha component of the color</haxe_doc>
	</a>
	<b public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the blue component of the color</haxe_doc>
	</b>
	<g public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the green component of the color</haxe_doc>
	</g>
	<r public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the red component of the color</haxe_doc>
	</r>
	<_new public="1" get="inline" set="null" line="120" static="1">
		<f a="?rgba" v="0">
			<x path="Int"/>
			<x path="lime.math.RGBA"/>
		</f>
		<meta>
			<m n=":value"><e>{ rgba : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new RGBA instance
		@param	rgba	(Optional) An RGBA color value</haxe_doc>
	</_new>
	<create public="1" get="inline" set="null" line="135" static="1">
		<f a="r:g:b:a">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.math.RGBA"/>
		</f>
		<haxe_doc>Creates a new RGBA instance from component values
		@param	r	A red component value
		@param	g	A green component value
		@param	b	A blue component value
		@param	a	An alpha component value
		@return	A new RGBA instance</haxe_doc>
	</create>
	<multiplyAlpha public="1" get="inline" set="null" line="147" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Multiplies the red, green and blue components by the current alpha component</haxe_doc>
	</multiplyAlpha>
	<readUInt8 public="1" get="inline" set="null" line="174" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="UInt"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Reads a value from a `UInt8Array` into the current `RGBA` color
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to read
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
	</readUInt8>
	<set public="1" get="inline" set="null" line="208" static="1">
		<f a="this:r:g:b:a">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Sets the current `RGBA` color to new component values
		@param	r	The red component value to set
		@param	g	The green component value to set
		@param	b	The blue component vlaue to set
		@param	a	The alpha component value to set</haxe_doc>
	</set>
	<unmultiplyAlpha public="1" get="inline" set="null" line="218" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Divides the current red, green and blue components by the alpha component</haxe_doc>
	</unmultiplyAlpha>
	<writeUInt8 public="1" get="inline" set="null" line="237" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="UInt"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Writes the current `RGBA` color into a `UInt8Array`
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to write
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
	</writeUInt8>
	<__fromARGB get="inline" set="null" line="273" static="1">
		<f a="argb">
			<x path="lime.math.ARGB"/>
			<x path="lime.math.RGBA"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromARGB>
	<__fromBGRA get="inline" set="null" line="280" static="1">
		<f a="bgra">
			<x path="lime.math.BGRA"/>
			<x path="lime.math.RGBA"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromBGRA>
	<get_a get="inline" set="null" line="294" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_a>
	<set_a get="inline" set="null" line="301" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_a>
	<get_b get="inline" set="null" line="309" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_b>
	<set_b get="inline" set="null" line="316" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_b>
	<get_g get="inline" set="null" line="324" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_g>
	<set_g get="inline" set="null" line="331" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_g>
	<get_r get="inline" set="null" line="339" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_r>
	<set_r get="inline" set="null" line="346" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_r>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":allow"><e>lime.math</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.utils.ArrayBufferView" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/ArrayBufferView.hx">
		<type public="1" expr="TypedArrayType.None">
			<x path="lime.utils.TypedArrayType"/>
			<meta><m n=":value"><e>TypedArrayType.None</e></m></meta>
		</type>
		<buffer public="1"><x path="lime.utils.ArrayBuffer"/></buffer>
		<byteOffset public="1"><x path="Int"/></byteOffset>
		<byteLength public="1"><x path="Int"/></byteLength>
		<length public="1"><x path="Int"/></length>
		<bytesPerElement set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bytesPerElement>
		<initTypedArray get="inline" set="null" line="52">
			<f a="view">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="lime.utils.ArrayBufferView"/>
			</f>
			<meta><m n=":allow"><e>lime.utils</e></m></meta>
		</initTypedArray>
		<initBuffer get="inline" set="null" line="79">
			<f a="in_buffer:?in_byteOffset:?len" v=":0:null">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lime.utils.ArrayBufferView"/>
			</f>
			<meta>
				<m n=":value"><e>{ len : null, in_byteOffset : 0 }</e></m>
				<m n=":allow"><e>lime.utils</e></m>
			</meta>
		</initBuffer>
		<initArray params="T" get="inline" set="null" line="116">
			<f a="array">
				<c path="Array"><c path="initArray.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
			</f>
			<meta><m n=":allow"><e>lime.utils</e></m></meta>
		</initArray>
		<set public="1" params="T" get="inline" set="null" line="134">
			<f a="?view:?array:?offset" v="null:null:0">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="Array"><c path="set.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0, array : null, view : null }</e></m></meta>
		</set>
		<cloneBuffer get="inline" set="null" line="150">
			<f a="src:?srcByteOffset" v=":0">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ srcByteOffset : 0 }</e></m></meta>
		</cloneBuffer>
		<subarray params="T_subarray" get="inline" set="null" line="164">
			<f a="begin:?end" v=":null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="subarray.T_subarray"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":generic"/>
				<m n=":allow"><e>lime.utils</e></m>
			</meta>
		</subarray>
		<bytesForType get="inline" set="null" line="209"><f a="type">
	<x path="lime.utils.TypedArrayType"/>
	<x path="Int"/>
</f></bytesForType>
		<toString get="inline" set="null" line="247"><f a=""><c path="String"/></f></toString>
		<toByteLength get="inline" set="null" line="268"><f a="elemCount">
	<x path="Int"/>
	<x path="Int"/>
</f></toByteLength>
		<copyFromArray set="method" line="278">
			<f a="array:?offset" v=":0">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</copyFromArray>
		<new get="inline" set="null" line="26">
			<f a="?elements:in_type" v="null:">
				<x path="Int"/>
				<x path="lime.utils.TypedArrayType"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ elements : null }</e></m>
				<m n=":allow"><e>lime.utils</e></m>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<enum path="lime.utils.TAError" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/ArrayBufferView.hx" module="lime.utils.ArrayBufferView">
		<RangeError/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</enum>
	<class path="lime.math._RGBA.RGBA_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/RGBA.hx" private="1" module="lime.math.RGBA">
		<__alpha16 static="1"><x path="lime.utils.UInt32Array"/></__alpha16>
		<__clamp static="1"><x path="lime.utils.UInt8Array"/></__clamp>
		<a16 static="1"><x path="Int"/></a16>
		<unmult static="1"><x path="Float"/></unmult>
		<a public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the alpha component of the color</haxe_doc>
		</a>
		<b public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the blue component of the color</haxe_doc>
		</b>
		<g public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the green component of the color</haxe_doc>
		</g>
		<r public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the red component of the color</haxe_doc>
		</r>
		<_new public="1" get="inline" set="null" line="120" static="1">
			<f a="?rgba" v="0">
				<x path="Int"/>
				<x path="lime.math.RGBA"/>
			</f>
			<meta>
				<m n=":value"><e>{ rgba : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new RGBA instance
		@param	rgba	(Optional) An RGBA color value</haxe_doc>
		</_new>
		<create public="1" get="inline" set="null" line="135" static="1">
			<f a="r:g:b:a">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.math.RGBA"/>
			</f>
			<haxe_doc>Creates a new RGBA instance from component values
		@param	r	A red component value
		@param	g	A green component value
		@param	b	A blue component value
		@param	a	An alpha component value
		@return	A new RGBA instance</haxe_doc>
		</create>
		<multiplyAlpha public="1" get="inline" set="null" line="147" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Multiplies the red, green and blue components by the current alpha component</haxe_doc>
		</multiplyAlpha>
		<readUInt8 public="1" get="inline" set="null" line="174" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="UInt"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Reads a value from a `UInt8Array` into the current `RGBA` color
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to read
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
		</readUInt8>
		<set public="1" get="inline" set="null" line="208" static="1">
			<f a="this:r:g:b:a">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Sets the current `RGBA` color to new component values
		@param	r	The red component value to set
		@param	g	The green component value to set
		@param	b	The blue component vlaue to set
		@param	a	The alpha component value to set</haxe_doc>
		</set>
		<unmultiplyAlpha public="1" get="inline" set="null" line="218" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Divides the current red, green and blue components by the alpha component</haxe_doc>
		</unmultiplyAlpha>
		<writeUInt8 public="1" get="inline" set="null" line="237" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="UInt"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Writes the current `RGBA` color into a `UInt8Array`
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to write
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
		</writeUInt8>
		<__fromARGB get="inline" set="null" line="273" static="1">
			<f a="argb">
				<x path="lime.math.ARGB"/>
				<x path="lime.math.RGBA"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromARGB>
		<__fromBGRA get="inline" set="null" line="280" static="1">
			<f a="bgra">
				<x path="lime.math.BGRA"/>
				<x path="lime.math.RGBA"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromBGRA>
		<get_a get="inline" set="null" line="294" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_a>
		<set_a get="inline" set="null" line="301" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_a>
		<get_b get="inline" set="null" line="309" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_b>
		<set_b get="inline" set="null" line="316" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_b>
		<get_g get="inline" set="null" line="324" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_g>
		<set_g get="inline" set="null" line="331" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_g>
		<get_r get="inline" set="null" line="339" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_r>
		<set_r get="inline" set="null" line="346" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_r>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":allow"><e>lime.math</e></m>
		</meta>
	</class>
	<class path="lime.math.Rectangle" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/Rectangle.hx">
		<bottom public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>Get or set the bottom (y + height) value of the `Rectangle`</haxe_doc>
		</bottom>
		<bottomRight public="1" get="accessor" set="accessor">
			<c path="lime.math.Vector2"/>
			<haxe_doc>Get or set the bottom-right (x + width, y + height) as a `Vector2`</haxe_doc>
		</bottomRight>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>Get or set the height of the rectangle</haxe_doc>
		</height>
		<left public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>Get or set the left (x) of the rectangle</haxe_doc>
		</left>
		<right public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>Get or set the right (x + width) of the rectangle</haxe_doc>
		</right>
		<size public="1" get="accessor" set="accessor">
			<c path="lime.math.Vector2"/>
			<haxe_doc>Get or set the size (width, height) as a `Vector2`</haxe_doc>
		</size>
		<top public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>Get or set the top (y) of the rectangle</haxe_doc>
		</top>
		<topLeft public="1" get="accessor" set="accessor">
			<c path="lime.math.Vector2"/>
			<haxe_doc>Get or set the top-left (x, y) as a `Vector2`</haxe_doc>
		</topLeft>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>Get or set the width of the rectangle</haxe_doc>
		</width>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>Get or set the x of the rectangle</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>Get or set the y of the rectangle</haxe_doc>
		</y>
		<clone public="1" set="method" line="102">
			<f a=""><c path="lime.math.Rectangle"/></f>
			<haxe_doc>Creates a clone of this `Rectangle`
		@return	A new `Rectangle` instance</haxe_doc>
		</clone>
		<contains public="1" set="method" line="115">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether this rectangle contains the specified (x, y) point
		@param	x	The x coordinate to test
		@param	y	The y coordinate to test
		@return	Whether the point is contained in the rectangle</haxe_doc>
		</contains>
		<containsPoint public="1" set="method" line="122">
			<f a="point">
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
				<m n=":deprecated"><e>"Use containsVector"</e></m>
			</meta>
		</containsPoint>
		<containsRect public="1" set="method" line="136">
			<f a="rect">
				<c path="lime.math.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether this rectangle contains another rectangle
		This will return `false` if the second rectangle only
		overlaps but is not fully contained within the current rectangle
		@param	rect	A second `Rectangle` instance to test
		@return	Whether the `rect` is contained within the current `Rectangle`</haxe_doc>
		</containsRect>
		<containsVector public="1" set="method" line="156">
			<f a="vector">
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether this rectangle contains the specified vector
		@param	vector	The vector to test
		@return	Whether the vector is contained in the rectangle</haxe_doc>
		</containsVector>
		<copyFrom public="1" set="method" line="167">
			<f a="sourceRect">
				<c path="lime.math.Rectangle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the x, y, width and height of another `Rectangle`
		@param	sourceRect	Another `Rectangle` instance</haxe_doc>
		</copyFrom>
		<equals public="1" set="method" line="183">
			<f a="toCompare">
				<c path="lime.math.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether the current `Rectangle` and another
		instance have equal values
		@param	toCompare	Another `Rectangle` to compare with
		@return	Whether both rectangles are not `null` and have equal values</haxe_doc>
		</equals>
		<inflate public="1" set="method" line="196">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Increases the size of the current rectangle by
		the given delta x and y values
		@param	dx	A delta x value to increase the size by
		@param	dy	A delta y value to increase the size by</haxe_doc>
		</inflate>
		<inflateVector public="1" set="method" line="209">
			<f a="vector">
				<c path="lime.math.Vector2"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Increases the size of the current rectangle by
		the given delta vector values
		@param	vector	A delta vector to increase the size by</haxe_doc>
		</inflateVector>
		<intersection public="1" set="method" line="225">
			<f a="toIntersect:?result" v=":null">
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Returns a new rectangle with the area where the current
		`Rectangle` and another `Rectangle` instance overlap.
		If they do not overlap, the returned `Rectangle` will
		be empty
		@param	toIntersect	Another `Rectangle` instance to intersect with
		@param	result	(Optional) A `Rectangle` instance to use for the result
		@return	A `Rectangle` of the intersection area</haxe_doc>
		</intersection>
		<intersects public="1" set="method" line="263">
			<f a="toIntersect">
				<c path="lime.math.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns if the current `Rectangle` overlaps with another instance
		@param	toIntersect	Another `Rectangle` to compare with
		@return	Whether the rectangles intersect</haxe_doc>
		</intersects>
		<isEmpty public="1" set="method" line="286">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[Whether this rectangle is empty
		@return	`true` if the width or height is <= 0]]></haxe_doc>
		</isEmpty>
		<offset public="1" set="method" line="298">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Moves the rectangle by offset x and values
		@param	dx	A delta x value
		@param	dy	A delta y value</haxe_doc>
		</offset>
		<offsetVector public="1" set="method" line="310">
			<f a="vector">
				<c path="lime.math.Vector2"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Moves the rectangle by the values of a `Vector2`
		@param	dx	A delta vector</haxe_doc>
		</offsetVector>
		<setEmpty public="1" set="method" line="321">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Makes this rectangle empty</haxe_doc>
		</setEmpty>
		<setTo public="1" set="method" line="335">
			<f a="xa:ya:widtha:heighta">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the values of this rectangle at once
		@param	xa	A new x value
		@param	ya	A new y value
		@param	widtha	A new width value
		@param	heighta	A new height value</haxe_doc>
		</setTo>
		<union public="1" set="method" line="352">
			<f a="toUnion:?result" v=":null">
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Combines two rectangles together, returning the
		minimum `Rectangle` that contains both rectangles
		@param	toUnion	A second `Rectangle` to unify
		@param	result	(Optional) A `Rectangle` instance for the result
		@return	A `Rectangle` that contains the dimensions of both rectangles</haxe_doc>
		</union>
		<__toFlashRectangle set="method" line="380">
			<f a=""><t path="flash.geom._Rectangle.FlashRectangle"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__toFlashRectangle>
		<get_bottom set="method" line="398">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bottom>
		<set_bottom set="method" line="399">
			<f a="b">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_bottom>
		<get_bottomRight set="method" line="400">
			<f a=""><c path="lime.math.Vector2"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bottomRight>
		<set_bottomRight set="method" line="401">
			<f a="p">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_bottomRight>
		<get_left set="method" line="402">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_left>
		<set_left set="method" line="403">
			<f a="l">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_left>
		<get_right set="method" line="404">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_right>
		<set_right set="method" line="405">
			<f a="r">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_right>
		<get_size set="method" line="406">
			<f a=""><c path="lime.math.Vector2"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_size>
		<set_size set="method" line="407">
			<f a="p">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_size>
		<get_top set="method" line="408">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_top>
		<set_top set="method" line="409">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_top>
		<get_topLeft set="method" line="410">
			<f a=""><c path="lime.math.Vector2"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_topLeft>
		<set_topLeft set="method" line="411">
			<f a="p">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_topLeft>
		<new public="1" set="method" line="88">
			<f a="?x:?y:?width:?height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 0, width : 0, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>Create a new `Rectangle` instance
		@param	x	(Optional) Initial x value (default is 0)
		@param	y	(Optional) Initial y value (default is 0)
		@param	width	(Optional) Initial width value (default is 0)
		@param	height	(Optional) Initial height value (default is 0)</haxe_doc>
		</new>
		<haxe_doc>The `Rectangle` class provides a simple object for storing
	and manipulating a logical rectangle for calculations</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.math.Vector2" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/Vector2.hx">
		<distance public="1" set="method" line="93" static="1">
			<f a="pt1:pt2">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Calculates the distance between two `Vector2` points
		@param	pt1	A `Vector2` instance
		@param	pt2	A second `Vector2` instance
		@return	The distance between each `Vector2`</haxe_doc>
		</distance>
		<interpolate public="1" set="method" line="122" static="1">
			<f a="pt1:pt2:f:?result" v=":::null">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
				<x path="Float"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Interpolates between two points, given a specified percentage value
		@param	pt1	A `Vector2` instance
		@param	pt2	A second `Vector2` instance
		@param	f	A percentage value to interpolate
		@param	result	(Optional) A `Vector2` instance to use for the result
		@return	A `Vector2` instance holding the interpolated value</haxe_doc>
		</interpolate>
		<polar public="1" set="method" line="172" static="1">
			<f a="len:angle:?result" v="::null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Converts a polar coordinate to into a cartesian `Vector2` instance
		@param	len	The length of the polar value
		@param	angle	The angle of the polar value
		@param	result	(Optional) A `Vector2` instance to store the result
		@return	A `Vector2` instance in cartesian coordinates</haxe_doc>
		</polar>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>Gets the length of this vector from (0, 0) to (x, y)</haxe_doc>
		</length>
		<lengthSquared public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>Gets the square of the length of this vector, which
		avoids use of `Math.sqrt` for faster performance</haxe_doc>
		</lengthSquared>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>The x coodinate for this vector</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>The y coodinate for this vector</haxe_doc>
		</y>
		<add public="1" set="method" line="67">
			<f a="v:?result" v=":null">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Adds the current vector to a second `Vector2` instance
		and returns the result
		@param	v	A `Vector2` instance to add
		@param	result	(Optional) A `Vector2` instance to store the result
		@return	A `Vector2` instance that combines both vector values</haxe_doc>
		</add>
		<clone public="1" set="method" line="80">
			<f a=""><c path="lime.math.Vector2"/></f>
			<haxe_doc>Clones the current `Vector2`
		@return	A new `Vector2` instance with the same values as the current one</haxe_doc>
		</clone>
		<equals public="1" set="method" line="107">
			<f a="toCompare">
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Whether this `Vector2` has the same values as another instance
		@param	toCompare	A `Vector2` instance to compare against
		@return	Whether the values of each vector are equal</haxe_doc>
		</equals>
		<normalize public="1" set="method" line="135">
			<f a="thickness">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Normalizes this vector between the current length and a set scale value
		@param	thickness	The scaling value. . For example, if the current vector is `(0, 5)` and you normalize it to 1, the normalized value will be `(0, 1)`</haxe_doc>
		</normalize>
		<offset public="1" set="method" line="157">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Offsets the current value of this vector
		@param	dx	An offset x value
		@param	dy	An offset y value</haxe_doc>
		</offset>
		<setTo public="1" get="inline" set="null" line="186">
			<f a="xa:ya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets this `Vector2` to new values
		@param	xa	An `x` value
		@param	ya	A `y` value</haxe_doc>
		</setTo>
		<subtract public="1" set="method" line="199">
			<f a="v:?result" v=":null">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Subtracts the current vector from another `Vector2` instance
		@param	v	A `Vector2` instance to subtract from the current vector
		@param	result	(Optional) A `Vector2` instance to store the result
		@return	A `Vector2` instance containing the subtracted values</haxe_doc>
		</subtract>
		<__toFlashPoint set="method" line="208">
			<f a=""><c path="flash.geom.Point"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__toFlashPoint>
		<get_length set="method" line="226">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<get_lengthSquared set="method" line="233">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_lengthSquared>
		<new public="1" set="method" line="52">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
			<haxe_doc>Creates a new `Vector` instance
		@param	x	(Optional) An initial `x` value (default is 0)
		@param	y	(Optional) An initial `y` value (default is 0)</haxe_doc>
		</new>
		<haxe_doc>The `Vector2` class can be used for calculating math with
	basic (x, y) coordinates</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.math.Vector4" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/math/Vector4.hx">
		<X_AXIS public="1" get="accessor" set="null" static="1">
			<c path="lime.math.Vector4"/>
			<haxe_doc>A constant representing the x axis (1, 0, 0)</haxe_doc>
		</X_AXIS>
		<Y_AXIS public="1" get="accessor" set="null" static="1">
			<c path="lime.math.Vector4"/>
			<haxe_doc>A constant representing the y axis (0, 1, 0)</haxe_doc>
		</Y_AXIS>
		<Z_AXIS public="1" get="accessor" set="null" static="1">
			<c path="lime.math.Vector4"/>
			<haxe_doc>A constant representing the z axis (0, 0, 1)</haxe_doc>
		</Z_AXIS>
		<angleBetween public="1" get="inline" set="null" line="105" static="1">
			<f a="a:b">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Calculates the angle between two `Vector4` coordinates
		@param	a	A `Vector4` instance
		@param	b	A second `Vector4` instance
		@return	The calculated angle</haxe_doc>
		</angleBetween>
		<distance public="1" get="inline" set="null" line="176" static="1">
			<f a="pt1:pt2">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Calculates the distance between two vectors
		@param	pt1	A `Vector4` instance
		@param	pt2	A second `Vector4` instance
		@return	The distance between each vector</haxe_doc>
		</distance>
		<distanceSquared public="1" get="inline" set="null" line="194" static="1">
			<f a="pt1:pt2">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Calculates the squared distance between two vectors,
		(avoids the use of `Math.sqrt` for faster performance)
		@param	pt1	A `Vector4` instance
		@param	pt2	A second `Vector4` instance
		@return	The square of the distance between each vector</haxe_doc>
		</distanceSquared>
		<get_X_AXIS get="inline" set="null" line="379" static="1"><f a=""><c path="lime.math.Vector4"/></f></get_X_AXIS>
		<get_Y_AXIS get="inline" set="null" line="386" static="1"><f a=""><c path="lime.math.Vector4"/></f></get_Y_AXIS>
		<get_Z_AXIS get="inline" set="null" line="393" static="1"><f a=""><c path="lime.math.Vector4"/></f></get_Z_AXIS>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>Get the length of this vector</haxe_doc>
		</length>
		<lengthSquared public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>Get the squared length of this vector
		(avoiding the use of `Math.sqrt` for faster
		performance)</haxe_doc>
		</lengthSquared>
		<w public="1">
			<x path="Float"/>
			<haxe_doc>The w component value</haxe_doc>
		</w>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>The x component value</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>The y component value</haxe_doc>
		</y>
		<z public="1">
			<x path="Float"/>
			<haxe_doc>The z component value</haxe_doc>
		</z>
		<add public="1" get="inline" set="null" line="90">
			<f a="a:?result" v=":null">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Adds two `Vector4` instances together and returns the result
		@param	a	A `Vector4` instance to add to the current one
		@param	result	(Optional) A `Vector4` instance to store the result
		@return	A `Vector4` instance with the added value</haxe_doc>
		</add>
		<clone public="1" get="inline" set="null" line="121">
			<f a=""><c path="lime.math.Vector4"/></f>
			<haxe_doc>Creates a new `Vector4` instance with the same values as the current one
		@return	A new `Vector4` instance with the same values</haxe_doc>
		</clone>
		<copyFrom public="1" get="inline" set="null" line="132">
			<f a="sourceVector4">
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the x, y and z component values of another `Vector4` instance
		@param	sourceVector4	A `Vector4` instance to copy from</haxe_doc>
		</copyFrom>
		<crossProduct public="1" get="inline" set="null" line="147">
			<f a="a:?result" v=":null">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Performs vector multiplication between this vector and another `Vector4` instance
		@param	a	A `Vector4` instance to multiply by
		@param	result	(Optional) A `Vector4` to use for the result
		@return	A `Vector4` instance with the result</haxe_doc>
		</crossProduct>
		<decrementBy public="1" get="inline" set="null" line="161">
			<f a="a">
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Decrements the x, y and z component values by those in another `Vector4` instance
		@param	a	A `Vector4` instance to decrement the current vector by</haxe_doc>
		</decrementBy>
		<dotProduct public="1" get="inline" set="null" line="210">
			<f a="a">
				<c path="lime.math.Vector4"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Calculates the dot product of the current vector with another `Vector4` instance
		@param	a	A `Vector4` instance to use in the dot product
		@return	The calculated dot product value</haxe_doc>
		</dotProduct>
		<equals public="1" get="inline" set="null" line="225">
			<f a="toCompare:?allFour" v=":false">
				<c path="lime.math.Vector4"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
			<haxe_doc>Whether two `Vector4` instances have equal component values.

		Comparing the w component value is optional.
		@param	toCompare	A `Vector4` instance to compare against
		@param	allFour	(Optional) Whether to compare against the w component (default is false)
		@return	Whether both instances have equal values</haxe_doc>
		</equals>
		<incrementBy public="1" get="inline" set="null" line="236">
			<f a="a">
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Increments the x, y and z component values by those in a second `Vector4` instance
		@param	a	A `Vector4` instance to increment the current vector by</haxe_doc>
		</incrementBy>
		<nearEquals public="1" get="inline" set="null" line="253">
			<f a="toCompare:tolerance:?allFour" v="::false">
				<c path="lime.math.Vector4"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
			<haxe_doc>Whether two `Vector4` instances have nearly equal component values.
		Comparison is performed within a given tolerance value.
		@param	toCompare	A `Vector4` instance to compare against
		@param	tolerance	A floating point value determining how near the values must be to be considered near equal
		@param	allFour	(Optional) Whether to compare against the w component (default is false)
		@return	Whether both instances have equal values, within the given tolerance</haxe_doc>
		</nearEquals>
		<negate public="1" get="inline" set="null" line="264">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Negates the x, y and z values of the current vector
		(multiplying each value by -1)</haxe_doc>
		</negate>
		<normalize public="1" get="inline" set="null" line="277">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Divides the x, y and z component values by the
		length of the vector</haxe_doc>
		</normalize>
		<project public="1" get="inline" set="null" line="298">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Divides the x, y and z component values by the
		w component value</haxe_doc>
		</project>
		<scaleBy public="1" get="inline" set="null" line="311">
			<f a="s">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scales the x, y and z component values by a scale value
		@param	s	The amount of scale to apply</haxe_doc>
		</scaleBy>
		<setTo public="1" get="inline" set="null" line="326">
			<f a="xa:ya:za">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the x, y and z component values
		@param	xa	An x value
		@param	ya	A y value
		@param	za	A z value</haxe_doc>
		</setTo>
		<subtract public="1" get="inline" set="null" line="342">
			<f a="a:?result" v=":null">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Subtracts the values of a second `Vector4` instance
		from the current one
		@param	a	A second `Vector4` instance to substract
		@param	result	(Optional) A `Vector4` instance to store the result
		@return	A `Vector4` instance containing the subtracted value</haxe_doc>
		</subtract>
		<toString public="1" get="inline" set="null" line="351">
			<f a=""><c path="String"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</toString>
		<get_length get="inline" set="null" line="365">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<get_lengthSquared get="inline" set="null" line="372">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_lengthSquared>
		<new public="1" set="method" line="74">
			<f a="?x:?y:?z:?w" v="0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 0., z : 0., y : 0., x : 0. }</e></m></meta>
			<haxe_doc>Creates a new `Vector4` instance
		@param	x	(Optional) An initial x value (default is 0)
		@param	y	(Optional) An initial y value (default is 0)
		@param	z	(Optional) An initial z value (default is 0)
		@param	w	(Optional) An initial w value (default is 0)</haxe_doc>
		</new>
		<haxe_doc>`Vector4` is a vector suitable for three-dimensional
	math, containing (x, y, z, w) components</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.media.AudioBuffer" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/media/AudioBuffer.hx">
		<fromBase64 public="1" set="method" line="87" static="1"><f a="base64String">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></fromBase64>
		<fromBytes public="1" set="method" line="143" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.media.AudioBuffer"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="185" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></fromFile>
		<fromFiles public="1" set="method" line="243" static="1"><f a="paths">
	<c path="Array"><c path="String"/></c>
	<c path="lime.media.AudioBuffer"/>
</f></fromFiles>
		<fromVorbisFile public="1" set="method" line="289" static="1"><f a="vorbisFile">
	<d/>
	<c path="lime.media.AudioBuffer"/>
</f></fromVorbisFile>
		<loadFromFile public="1" set="method" line="298" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.media.AudioBuffer"/></c>
</f></loadFromFile>
		<loadFromFiles public="1" set="method" line="382" static="1"><f a="paths">
	<c path="Array"><c path="String"/></c>
	<c path="lime.app.Future"><c path="lime.media.AudioBuffer"/></c>
</f></loadFromFiles>
		<__getCodec set="method" line="423" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
</f></__getCodec>
		<bitsPerSample public="1"><x path="Int"/></bitsPerSample>
		<channels public="1"><x path="Int"/></channels>
		<data public="1"><x path="lime.utils.UInt8Array"/></data>
		<sampleRate public="1"><x path="Int"/></sampleRate>
		<src public="1" get="accessor" set="accessor"><d/></src>
		<__srcAudio>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcAudio>
		<__srcBuffer>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcBuffer>
		<__srcCustom>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcCustom>
		<__srcHowl>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcHowl>
		<__srcSound>
			<c path="flash.media.Sound"/>
			<meta><m n=":noCompletion"/></meta>
		</__srcSound>
		<__srcVorbisFile>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcVorbisFile>
		<dispose public="1" set="method" line="76"><f a=""><x path="Void"/></f></dispose>
		<get_src set="method" line="456">
			<f a=""><d/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_src>
		<set_src set="method" line="485">
			<f a="value">
				<d/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_src>
		<new public="1" set="method" line="69"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.utils.Assets</e></m>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.media.AudioContext" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/media/AudioContext.hx">
		<custom public="1"><d/></custom>
		<flash public="1" set="null"><c path="lime.media.FlashAudioContext"/></flash>
		<type public="1" set="null"><x path="lime.media.AudioContextType"/></type>
		<new public="1" set="method" line="34">
			<f a="?type" v="null">
				<x path="lime.media.AudioContextType"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.media.FlashAudioContext</e></m>
			<m n=":access"><e>lime.media.HTML5AudioContext</e></m>
			<m n=":access"><e>lime.media.OpenALAudioContext</e></m>
			<m n=":access"><e>lime.media.WebAudioContext</e></m>
		</meta>
	</class>
	<abstract path="lime.media.AudioContextType" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/media/AudioContextType.hx">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.media._AudioContextType.AudioContextType_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/media/AudioContextType.hx" private="1" module="lime.media.AudioContextType" extern="1">
	<FLASH public="1" get="inline" set="null" expr="cast &quot;flash&quot;" line="6" static="1">
		<x path="lime.media.AudioContextType"/>
		<meta>
			<m n=":value"><e>cast "flash"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLASH>
	<HTML5 public="1" get="inline" set="null" expr="cast &quot;html5&quot;" line="7" static="1">
		<x path="lime.media.AudioContextType"/>
		<meta>
			<m n=":value"><e>cast "html5"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HTML5>
	<OPENAL public="1" get="inline" set="null" expr="cast &quot;openal&quot;" line="8" static="1">
		<x path="lime.media.AudioContextType"/>
		<meta>
			<m n=":value"><e>cast "openal"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OPENAL>
	<WEB public="1" get="inline" set="null" expr="cast &quot;web&quot;" line="9" static="1">
		<x path="lime.media.AudioContextType"/>
		<meta>
			<m n=":value"><e>cast "web"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WEB>
	<CUSTOM public="1" get="inline" set="null" expr="cast &quot;custom&quot;" line="10" static="1">
		<x path="lime.media.AudioContextType"/>
		<meta>
			<m n=":value"><e>cast "custom"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CUSTOM>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.media._AudioContextType.AudioContextType_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/media/AudioContextType.hx" private="1" module="lime.media.AudioContextType" extern="1">
		<FLASH public="1" get="inline" set="null" expr="cast &quot;flash&quot;" line="6" static="1">
			<x path="lime.media.AudioContextType"/>
			<meta>
				<m n=":value"><e>cast "flash"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLASH>
		<HTML5 public="1" get="inline" set="null" expr="cast &quot;html5&quot;" line="7" static="1">
			<x path="lime.media.AudioContextType"/>
			<meta>
				<m n=":value"><e>cast "html5"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HTML5>
		<OPENAL public="1" get="inline" set="null" expr="cast &quot;openal&quot;" line="8" static="1">
			<x path="lime.media.AudioContextType"/>
			<meta>
				<m n=":value"><e>cast "openal"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OPENAL>
		<WEB public="1" get="inline" set="null" expr="cast &quot;web&quot;" line="9" static="1">
			<x path="lime.media.AudioContextType"/>
			<meta>
				<m n=":value"><e>cast "web"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WEB>
		<CUSTOM public="1" get="inline" set="null" expr="cast &quot;custom&quot;" line="10" static="1">
			<x path="lime.media.AudioContextType"/>
			<meta>
				<m n=":value"><e>cast "custom"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CUSTOM>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.media.AudioManager" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/media/AudioManager.hx">
		<context public="1" static="1"><c path="lime.media.AudioContext"/></context>
		<init public="1" set="method" line="29" static="1">
			<f a="?context" v="null">
				<c path="lime.media.AudioContext"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context : null }</e></m></meta>
		</init>
		<resume public="1" set="method" line="70" static="1"><f a=""><x path="Void"/></f></resume>
		<shutdown public="1" set="method" line="92" static="1"><f a=""><x path="Void"/></f></shutdown>
		<suspend public="1" set="method" line="122" static="1"><f a=""><x path="Void"/></f></suspend>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime.media.AudioSource" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/media/AudioSource.hx">
		<onComplete public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onComplete>
		<buffer public="1"><c path="lime.media.AudioBuffer"/></buffer>
		<currentTime public="1" get="accessor" set="accessor"><x path="Int"/></currentTime>
		<gain public="1" get="accessor" set="accessor"><x path="Float"/></gain>
		<length public="1" get="accessor" set="accessor"><x path="Int"/></length>
		<loops public="1" get="accessor" set="accessor"><x path="Int"/></loops>
		<offset public="1"><x path="Int"/></offset>
		<position public="1" get="accessor" set="accessor"><c path="lime.math.Vector4"/></position>
		<__backend>
			<t path="lime.media._AudioSource.AudioSourceBackend"/>
			<meta><m n=":noCompletion"/></meta>
		</__backend>
		<dispose public="1" set="method" line="55"><f a=""><x path="Void"/></f></dispose>
		<init set="method" line="62">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</init>
		<play public="1" set="method" line="69"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method" line="76"><f a=""><x path="Void"/></f></pause>
		<stop public="1" set="method" line="83"><f a=""><x path="Void"/></f></stop>
		<get_currentTime set="method" line="97">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_currentTime>
		<set_currentTime set="method" line="104">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_currentTime>
		<get_gain set="method" line="111">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_gain>
		<set_gain set="method" line="118">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_gain>
		<get_length set="method" line="125">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<set_length set="method" line="132">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_length>
		<get_loops set="method" line="139">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_loops>
		<set_loops set="method" line="146">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_loops>
		<get_position set="method" line="153">
			<f a=""><c path="lime.math.Vector4"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_position>
		<set_position set="method" line="160">
			<f a="value">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_position>
		<new public="1" set="method" line="31">
			<f a="?buffer:?offset:?length:?loops" v="null:0:null:0">
				<c path="lime.media.AudioBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ loops : 0, length : null, offset : 0, buffer : null }</e></m></meta>
		</new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<typedef path="lime.media._AudioSource.AudioSourceBackend" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/media/AudioSource.hx" private="1" module="lime.media.AudioSource">
		<c path="lime._internal.backend.flash.FlashAudioSource"/>
		<meta><m n=":noCompletion"/></meta>
	</typedef>
	<class path="lime.media.FlashAudioContext" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/media/FlashAudioContext.hx">
		<createBuffer public="1" set="method" line="19">
			<f a="?stream:?context" v="null:null">
				<d/>
				<d/>
				<c path="lime.media.AudioBuffer"/>
			</f>
			<meta><m n=":value"><e>{ context : null, stream : null }</e></m></meta>
		</createBuffer>
		<getBytesLoaded public="1" set="method" line="32"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="UInt"/>
</f></getBytesLoaded>
		<getBytesTotal public="1" set="method" line="47"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="Int"/>
</f></getBytesTotal>
		<getID3 public="1" set="method" line="62"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<d/>
</f></getID3>
		<getIsBuffering public="1" set="method" line="77"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="Bool"/>
</f></getIsBuffering>
		<getIsURLInaccessible public="1" set="method" line="92"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="Bool"/>
</f></getIsURLInaccessible>
		<getLength public="1" set="method" line="107"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="Float"/>
</f></getLength>
		<getURL public="1" set="method" line="122"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<c path="String"/>
</f></getURL>
		<close public="1" set="method" line="137"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="Void"/>
</f></close>
		<extract public="1" set="method" line="150">
			<f a="buffer:target:length:?startPosition" v=":::-1">
				<c path="lime.media.AudioBuffer"/>
				<d/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ startPosition : -1 }</e></m></meta>
		</extract>
		<load public="1" set="method" line="165">
			<f a="buffer:stream:?context" v="::null">
				<c path="lime.media.AudioBuffer"/>
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context : null }</e></m></meta>
		</load>
		<loadCompressedDataFromByteArray public="1" set="method" line="178"><f a="buffer:bytes:bytesLength">
	<c path="lime.media.AudioBuffer"/>
	<d/>
	<x path="UInt"/>
	<x path="Void"/>
</f></loadCompressedDataFromByteArray>
		<loadPCMFromByteArray public="1" set="method" line="191">
			<f a="buffer:bytes:samples:?format:?stereo:?sampleRate" v=":::null:true:44100">
				<c path="lime.media.AudioBuffer"/>
				<d/>
				<x path="UInt"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sampleRate : 44100, stereo : true, format : null }</e></m></meta>
		</loadPCMFromByteArray>
		<play public="1" set="method" line="204">
			<f a="buffer:?startTime:?loops:?sndTransform" v=":0:0:null">
				<c path="lime.media.AudioBuffer"/>
				<x path="Float"/>
				<x path="Int"/>
				<d/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ sndTransform : null, loops : 0, startTime : 0 }</e></m></meta>
		</play>
		<new set="method" line="12">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.net.HTTPRequest" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/net/HTTPRequest.hx">
		<contentType public="1"><c path="String"/></contentType>
		<data public="1"><c path="haxe.io.Bytes"/></data>
		<enableResponseHeaders public="1"><x path="Bool"/></enableResponseHeaders>
		<followRedirects public="1"><x path="Bool"/></followRedirects>
		<formData public="1"><t path="Map">
	<c path="String"/>
	<d/>
</t></formData>
		<headers public="1"><c path="Array"><c path="lime.net.HTTPRequestHeader"/></c></headers>
		<method public="1"><x path="lime.net.HTTPRequestMethod"/></method>
		<responseData public="1"><c path="lime.net.HTTPRequest.T"/></responseData>
		<responseHeaders public="1"><c path="Array"><c path="lime.net.HTTPRequestHeader"/></c></responseHeaders>
		<responseStatus public="1"><x path="Int"/></responseStatus>
		<timeout public="1"><x path="Int"/></timeout>
		<uri public="1"><c path="String"/></uri>
		<userAgent public="1"><c path="String"/></userAgent>
		<withCredentials public="1"><x path="Bool"/></withCredentials>
		<cancel public="1" set="method" line="78"><f a=""><x path="Void"/></f></cancel>
		<load public="1" set="method" line="87">
			<f a="?uri" v="null">
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.net.HTTPRequest.T"/></c>
			</f>
			<meta><m n=":value"><e>{ uri : null }</e></m></meta>
		</load>
		<new public="1" set="method" line="57">
			<f a="?uri" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ uri : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.net.HTTPRequestHeader" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/HTTPRequestHeader.hx">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method" line="17">
			<f a="name:?value" v=":&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ value : "" }</e></m></meta>
		</new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.net.HTTPRequestMethod" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/HTTPRequestMethod.hx">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.net._HTTPRequestMethod.HTTPRequestMethod_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/HTTPRequestMethod.hx" private="1" module="lime.net.HTTPRequestMethod" extern="1">
	<DELETE public="1" get="inline" set="null" expr="cast &quot;DELETE&quot;" line="6" static="1">
		<x path="lime.net.HTTPRequestMethod"/>
		<meta>
			<m n=":value"><e>cast "DELETE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DELETE>
	<GET public="1" get="inline" set="null" expr="cast &quot;GET&quot;" line="7" static="1">
		<x path="lime.net.HTTPRequestMethod"/>
		<meta>
			<m n=":value"><e>cast "GET"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GET>
	<HEAD public="1" get="inline" set="null" expr="cast &quot;HEAD&quot;" line="8" static="1">
		<x path="lime.net.HTTPRequestMethod"/>
		<meta>
			<m n=":value"><e>cast "HEAD"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEAD>
	<OPTIONS public="1" get="inline" set="null" expr="cast &quot;OPTIONS&quot;" line="9" static="1">
		<x path="lime.net.HTTPRequestMethod"/>
		<meta>
			<m n=":value"><e>cast "OPTIONS"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OPTIONS>
	<POST public="1" get="inline" set="null" expr="cast &quot;POST&quot;" line="10" static="1">
		<x path="lime.net.HTTPRequestMethod"/>
		<meta>
			<m n=":value"><e>cast "POST"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</POST>
	<PUT public="1" get="inline" set="null" expr="cast &quot;PUT&quot;" line="11" static="1">
		<x path="lime.net.HTTPRequestMethod"/>
		<meta>
			<m n=":value"><e>cast "PUT"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PUT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.net._HTTPRequestMethod.HTTPRequestMethod_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/HTTPRequestMethod.hx" private="1" module="lime.net.HTTPRequestMethod" extern="1">
		<DELETE public="1" get="inline" set="null" expr="cast &quot;DELETE&quot;" line="6" static="1">
			<x path="lime.net.HTTPRequestMethod"/>
			<meta>
				<m n=":value"><e>cast "DELETE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DELETE>
		<GET public="1" get="inline" set="null" expr="cast &quot;GET&quot;" line="7" static="1">
			<x path="lime.net.HTTPRequestMethod"/>
			<meta>
				<m n=":value"><e>cast "GET"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GET>
		<HEAD public="1" get="inline" set="null" expr="cast &quot;HEAD&quot;" line="8" static="1">
			<x path="lime.net.HTTPRequestMethod"/>
			<meta>
				<m n=":value"><e>cast "HEAD"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEAD>
		<OPTIONS public="1" get="inline" set="null" expr="cast &quot;OPTIONS&quot;" line="9" static="1">
			<x path="lime.net.HTTPRequestMethod"/>
			<meta>
				<m n=":value"><e>cast "OPTIONS"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OPTIONS>
		<POST public="1" get="inline" set="null" expr="cast &quot;POST&quot;" line="10" static="1">
			<x path="lime.net.HTTPRequestMethod"/>
			<meta>
				<m n=":value"><e>cast "POST"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</POST>
		<PUT public="1" get="inline" set="null" expr="cast &quot;PUT&quot;" line="11" static="1">
			<x path="lime.net.HTTPRequestMethod"/>
			<meta>
				<m n=":value"><e>cast "PUT"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PUT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.net.URIParser" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/URIParser.hx">
		<URI_REGEX public="1" expr="~/^(?:([^:/?#]+):)?(?://((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?))?((((?:[^?#/]*/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/" line="13" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^(?:([^:/?#]+):)?(?://((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?))?((((?:[^?#/]*/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/</e></m></meta>
		</URI_REGEX>
		<QUERY_REGEX public="1" expr="~/(?:^|&amp;)([^&amp;=]*)=?([^&amp;]*)/" line="14" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e><![CDATA[~/(?:^|&)([^&=]*)=?([^&]*)/]]></e></m></meta>
		</QUERY_REGEX>
		<parseQuery public="1" set="method" line="63" static="1"><f a="query">
	<c path="String"/>
	<c path="Array"><t path="lime.net.KVPair"/></c>
</f></parseQuery>
		<source public="1"><c path="String"/></source>
		<protocol public="1"><c path="String"/></protocol>
		<authority public="1"><c path="String"/></authority>
		<userInfo public="1"><c path="String"/></userInfo>
		<user public="1"><c path="String"/></user>
		<password public="1"><c path="String"/></password>
		<host public="1"><c path="String"/></host>
		<port public="1"><c path="String"/></port>
		<relative public="1"><c path="String"/></relative>
		<path public="1"><c path="String"/></path>
		<directory public="1"><c path="String"/></directory>
		<file public="1"><c path="String"/></file>
		<query public="1"><c path="String"/></query>
		<anchor public="1"><c path="String"/></anchor>
		<queryArray public="1"><c path="Array"><t path="lime.net.KVPair"/></c></queryArray>
		<new public="1" set="method" line="34"><f a="uri">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<typedef path="lime.net.KVPair" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/URIParser.hx" module="lime.net.URIParser">
		<a>
			<v><c path="String"/></v>
			<k><c path="String"/></k>
		</a>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<class path="lime.net.oauth.OAuthClient" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/oauth/OAuthClient.hx">
		<version public="1"><x path="lime.net.oauth.OAuthVersion"/></version>
		<consumer public="1"><c path="lime.net.oauth.OAuthConsumer"/></consumer>
		<generateNonce public="1" set="method" line="41"><f a=""><c path="String"/></f></generateNonce>
		<new public="1" set="method" line="15"><f a="version:consumer">
	<x path="lime.net.oauth.OAuthVersion"/>
	<c path="lime.net.oauth.OAuthConsumer"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.net.oauth.OAuthConsumer" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/oauth/OAuthConsumer.hx">
		<key public="1"><c path="String"/></key>
		<secret public="1"><c path="String"/></secret>
		<new public="1" set="method" line="11"><f a="key:secret">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="lime.net.oauth.OAuthSignatureMethod" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/oauth/OAuthSignatureMethod.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.net.oauth._OAuthSignatureMethod.OAuthSignatureMethod_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/oauth/OAuthSignatureMethod.hx" private="1" module="lime.net.oauth.OAuthSignatureMethod" extern="1">
	<HMAC_SHA1 public="1" get="inline" set="null" expr="cast &quot;HMAC-SHA1&quot;" line="7" static="1">
		<x path="lime.net.oauth.OAuthSignatureMethod"/>
		<meta>
			<m n=":value"><e>cast "HMAC-SHA1"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HMAC_SHA1>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.net.oauth._OAuthSignatureMethod.OAuthSignatureMethod_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/oauth/OAuthSignatureMethod.hx" private="1" module="lime.net.oauth.OAuthSignatureMethod" extern="1">
		<HMAC_SHA1 public="1" get="inline" set="null" expr="cast &quot;HMAC-SHA1&quot;" line="7" static="1">
			<x path="lime.net.oauth.OAuthSignatureMethod"/>
			<meta>
				<m n=":value"><e>cast "HMAC-SHA1"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HMAC_SHA1>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.net.oauth.RequestToken" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/oauth/OAuthToken.hx" module="lime.net.oauth.OAuthToken">
		<token public="1" set="null"><c path="String"/></token>
		<secret public="1" set="null"><c path="String"/></secret>
		<new public="1" set="method" line="9"><f a="token:secret">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.net.oauth.AccessToken" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/oauth/OAuthToken.hx" module="lime.net.oauth.OAuthToken">
		<token public="1" set="null"><c path="String"/></token>
		<new public="1" set="method" line="22"><f a="token">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.net.oauth.OAuth1AccessToken" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/oauth/OAuthToken.hx" module="lime.net.oauth.OAuthToken">
		<extends path="lime.net.oauth.AccessToken"/>
		<secret public="1" set="null"><c path="String"/></secret>
		<new public="1" set="method" line="34"><f a="token:?secret">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.net.oauth.OAuth2AccessToken" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/oauth/OAuthToken.hx" module="lime.net.oauth.OAuthToken">
		<extends path="lime.net.oauth.AccessToken"/>
		<expires public="1" set="null" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</expires>
		<new public="1" set="method" line="47"><f a="token:?expires">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.net.oauth.RefreshToken" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/oauth/OAuthToken.hx" module="lime.net.oauth.OAuthToken">
		<token public="1" set="null"><c path="String"/></token>
		<new public="1" set="method" line="60"><f a="token">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="lime.net.oauth.OAuthVersion" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/oauth/OAuthVersion.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.net.oauth._OAuthVersion.OAuthVersion_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/oauth/OAuthVersion.hx" private="1" module="lime.net.oauth.OAuthVersion" extern="1">
	<V1 public="1" get="inline" set="null" expr="cast &quot;1.0&quot;" line="6" static="1">
		<x path="lime.net.oauth.OAuthVersion"/>
		<meta>
			<m n=":value"><e>cast "1.0"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</V1>
	<V2 public="1" get="inline" set="null" expr="cast &quot;2.0&quot;" line="7" static="1">
		<x path="lime.net.oauth.OAuthVersion"/>
		<meta>
			<m n=":value"><e>cast "2.0"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</V2>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.net.oauth._OAuthVersion.OAuthVersion_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/net/oauth/OAuthVersion.hx" private="1" module="lime.net.oauth.OAuthVersion" extern="1">
		<V1 public="1" get="inline" set="null" expr="cast &quot;1.0&quot;" line="6" static="1">
			<x path="lime.net.oauth.OAuthVersion"/>
			<meta>
				<m n=":value"><e>cast "1.0"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</V1>
		<V2 public="1" get="inline" set="null" expr="cast &quot;2.0&quot;" line="7" static="1">
			<x path="lime.net.oauth.OAuthVersion"/>
			<meta>
				<m n=":value"><e>cast "2.0"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</V2>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.system.BackgroundWorker" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/BackgroundWorker.hx">
		<MESSAGE_COMPLETE expr="&quot;__COMPLETE__&quot;" line="24" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__COMPLETE__"</e></m></meta>
		</MESSAGE_COMPLETE>
		<MESSAGE_ERROR expr="&quot;__ERROR__&quot;" line="25" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ERROR__"</e></m></meta>
		</MESSAGE_ERROR>
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<completed public="1" set="null"><x path="Bool"/></completed>
		<doWork public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</doWork>
		<onComplete public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onComplete>
		<onError public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onError>
		<onProgress public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onProgress>
		<__runMessage>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__runMessage>
		<cancel public="1" set="method" line="49"><f a=""><x path="Void"/></f></cancel>
		<run public="1" set="method" line="62">
			<f a="?message" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : null }</e></m></meta>
		</run>
		<sendComplete public="1" set="method" line="90">
			<f a="?message" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : null }</e></m></meta>
		</sendComplete>
		<sendError public="1" set="method" line="113">
			<f a="?message" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : null }</e></m></meta>
		</sendError>
		<sendProgress public="1" set="method" line="134">
			<f a="?message" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : null }</e></m></meta>
		</sendProgress>
		<__doWork set="method" line="153">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__doWork>
		<__update set="method" line="175">
			<f a="deltaTime">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__update>
		<new public="1" set="method" line="42"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.system.Clipboard" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/Clipboard.hx">
		<onUpdate public="1" expr="new Event&lt;Void&gt;()" line="26" static="1">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onUpdate>
		<text public="1" get="accessor" set="accessor" static="1"><c path="String"/></text>
		<_text static="1"><c path="String"/></_text>
		<__update set="method" line="33" static="1"><f a=""><x path="Void"/></f></__update>
		<get_text set="method" line="68" static="1"><f a=""><c path="String"/></f></get_text>
		<set_text set="method" line="79" static="1"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.ui.Window</e></m>
		</meta>
	</class>
	<class path="lime.system.Display" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/Display.hx">
		<bounds public="1" set="null">
			<c path="lime.math.Rectangle"/>
			<haxe_doc>* The desktop area represented by this display, with the upper-leftmost display at 0,0</haxe_doc>
		</bounds>
		<currentMode public="1" set="null">
			<c path="lime.system.DisplayMode"/>
			<haxe_doc>* The current display mode</haxe_doc>
		</currentMode>
		<id public="1" set="null"><x path="Int"/></id>
		<dpi public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Pixel density of the display</haxe_doc>
		</dpi>
		<name public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The name of the device, such as "Samsung SyncMaster P2350", "iPhone 6", "Oculus Rift DK2", etc.</haxe_doc>
		</name>
		<supportedModes public="1" set="null">
			<c path="Array"><c path="lime.system.DisplayMode"/></c>
			<haxe_doc>* All of the display modes supported by this device</haxe_doc>
		</supportedModes>
		<new set="method" line="43">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.system.DisplayMode" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/DisplayMode.hx">
		<height public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* vertical resolution</haxe_doc>
		</height>
		<pixelFormat public="1" set="null">
			<x path="lime.graphics.PixelFormat"/>
			<haxe_doc>* pixel format</haxe_doc>
		</pixelFormat>
		<refreshRate public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* refresh rate in Hz</haxe_doc>
		</refreshRate>
		<width public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* horizontal resolution</haxe_doc>
		</width>
		<new set="method" line="36">
			<f a="width:height:refreshRate:pixelFormat">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<enum path="lime.system.Endian" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="lime.system.Locale" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/Locale.hx">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<impl><class path="lime.system._Locale.Locale_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/Locale.hx" private="1" module="lime.system.Locale">
	<currentLocale public="1" get="accessor" set="accessor" static="1">
		<x path="lime.system.Locale"/>
		<meta><m n=":isVar"/></meta>
	</currentLocale>
	<systemLocale public="1" get="accessor" set="null" static="1"><x path="lime.system.Locale"/></systemLocale>
	<__systemLocale static="1"><x path="lime.system.Locale"/></__systemLocale>
	<language public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<meta><m n=":impl"/></meta>
	</language>
	<region public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<meta><m n=":impl"/></meta>
	</region>
	<_new public="1" set="method" line="24" static="1">
		<f a="value">
			<c path="String"/>
			<x path="lime.system.Locale"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<equals set="method" line="31" static="1">
		<f a="a:b">
			<x path="lime.system.Locale"/>
			<x path="lime.system.Locale"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A == B</e></m>
		</meta>
	</equals>
	<__init set="method" line="64" static="1"><f a=""><x path="Void"/></f></__init>
	<get_language set="method" line="121" static="1">
		<f a="this">
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_language>
	<get_region set="method" line="151" static="1">
		<f a="this">
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_region>
	<get_currentLocale set="method" line="199" static="1"><f a=""><x path="lime.system.Locale"/></f></get_currentLocale>
	<set_currentLocale set="method" line="208" static="1"><f a="value">
	<x path="lime.system.Locale"/>
	<x path="lime.system.Locale"/>
</f></set_currentLocale>
	<get_systemLocale set="method" line="217" static="1"><f a=""><x path="lime.system.Locale"/></f></get_systemLocale>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.system._Locale.Locale_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/Locale.hx" private="1" module="lime.system.Locale">
		<currentLocale public="1" get="accessor" set="accessor" static="1">
			<x path="lime.system.Locale"/>
			<meta><m n=":isVar"/></meta>
		</currentLocale>
		<systemLocale public="1" get="accessor" set="null" static="1"><x path="lime.system.Locale"/></systemLocale>
		<__systemLocale static="1"><x path="lime.system.Locale"/></__systemLocale>
		<language public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":impl"/></meta>
		</language>
		<region public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":impl"/></meta>
		</region>
		<_new public="1" set="method" line="24" static="1">
			<f a="value">
				<c path="String"/>
				<x path="lime.system.Locale"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<equals set="method" line="31" static="1">
			<f a="a:b">
				<x path="lime.system.Locale"/>
				<x path="lime.system.Locale"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A == B</e></m>
			</meta>
		</equals>
		<__init set="method" line="64" static="1"><f a=""><x path="Void"/></f></__init>
		<get_language set="method" line="121" static="1">
			<f a="this">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_language>
		<get_region set="method" line="151" static="1">
			<f a="this">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_region>
		<get_currentLocale set="method" line="199" static="1"><f a=""><x path="lime.system.Locale"/></f></get_currentLocale>
		<set_currentLocale set="method" line="208" static="1"><f a="value">
	<x path="lime.system.Locale"/>
	<x path="lime.system.Locale"/>
</f></set_currentLocale>
		<get_systemLocale set="method" line="217" static="1"><f a=""><x path="lime.system.Locale"/></f></get_systemLocale>
		<meta><m n=":final"/></meta>
	</class>
	<class path="lime.system.Sensor" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/Sensor.hx">
		<sensorByID expr="new Map&lt;Int,Sensor&gt;()" line="15" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="lime.system.Sensor"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Sensor>()]]></e></m></meta>
		</sensorByID>
		<sensors expr="new Array&lt;Sensor&gt;()" line="16" static="1">
			<c path="Array"><c path="lime.system.Sensor"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Sensor>()]]></e></m></meta>
		</sensors>
		<getSensors public="1" set="method" line="31" static="1">
			<f a="?type" v="null">
				<e path="lime.system.SensorType"/>
				<c path="Array"><c path="lime.system.Sensor"/></c>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</getSensors>
		<registerSensor set="method" line="58" static="1"><f a="type:id">
	<e path="lime.system.SensorType"/>
	<x path="Int"/>
	<c path="lime.system.Sensor"/>
</f></registerSensor>
		<id public="1"><x path="Int"/></id>
		<onUpdate public="1" expr="new Event&lt;Float -&gt; Float -&gt; Float&gt;()">
			<c path="lime.app._Event_Float_Float_Float_Void"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float -> Float>()]]></e></m></meta>
		</onUpdate>
		<type public="1"><e path="lime.system.SensorType"/></type>
		<new set="method" line="23">
			<f a="type:id">
				<e path="lime.system.SensorType"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<enum path="lime.system.SensorType" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/SensorType.hx">
		<ACCELEROMETER/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="lime.system.System" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/System.hx">
		<allowScreenTimeout public="1" get="accessor" set="accessor" static="1"><x path="Bool"/></allowScreenTimeout>
		<applicationDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></applicationDirectory>
		<applicationStorageDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></applicationStorageDirectory>
		<desktopDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></desktopDirectory>
		<deviceModel public="1" get="accessor" set="null" static="1"><c path="String"/></deviceModel>
		<deviceVendor public="1" get="accessor" set="null" static="1"><c path="String"/></deviceVendor>
		<disableCFFI public="1" static="1"><x path="Bool"/></disableCFFI>
		<documentsDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></documentsDirectory>
		<endianness public="1" get="accessor" set="null" static="1"><e path="lime.system.Endian"/></endianness>
		<fontsDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></fontsDirectory>
		<numDisplays public="1" get="accessor" set="null" static="1"><x path="Int"/></numDisplays>
		<platformLabel public="1" get="accessor" set="null" static="1"><c path="String"/></platformLabel>
		<platformName public="1" get="accessor" set="null" static="1"><c path="String"/></platformName>
		<platformVersion public="1" get="accessor" set="null" static="1"><c path="String"/></platformVersion>
		<userDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></userDirectory>
		<__applicationDirectory static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__applicationDirectory>
		<__applicationEntryPoint static="1">
			<t path="Map">
				<c path="String"/>
				<x path="haxe.Function"/>
			</t>
			<meta><m n=":noCompletion"/></meta>
		</__applicationEntryPoint>
		<__applicationStorageDirectory static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__applicationStorageDirectory>
		<__desktopDirectory static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__desktopDirectory>
		<__deviceModel static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__deviceModel>
		<__deviceVendor static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__deviceVendor>
		<__directories expr="new Map&lt;SystemDirectory,String&gt;()" line="79" static="1">
			<x path="haxe.ds.Map">
				<x path="lime.system._System.SystemDirectory"/>
				<c path="String"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<SystemDirectory,String>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</__directories>
		<__documentsDirectory static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__documentsDirectory>
		<__endianness static="1">
			<e path="lime.system.Endian"/>
			<meta><m n=":noCompletion"/></meta>
		</__endianness>
		<__fontsDirectory static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__fontsDirectory>
		<__platformLabel static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__platformLabel>
		<__platformName static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__platformName>
		<__platformVersion static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__platformVersion>
		<__userDirectory static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__userDirectory>
		<getDisplay public="1" set="method" line="189" static="1"><f a="id">
	<x path="Int"/>
	<c path="lime.system.Display"/>
</f></getDisplay>
		<getTimer public="1" set="method" line="279" static="1"><f a=""><x path="Int"/></f></getTimer>
		<openFile public="1" set="method" line="313" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></openFile>
		<openURL public="1" set="method" line="353" static="1">
			<f a="url:?target" v=":&quot;_blank&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ target : "_blank" }</e></m></meta>
		</openURL>
		<__copyMissingFields set="method" line="385" static="1">
			<f a="target:source">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__copyMissingFields>
		<__getDirectory set="method" line="402" static="1">
			<f a="type">
				<x path="lime.system._System.SystemDirectory"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getDirectory>
		<__parseBool get="inline" set="null" line="580" static="1">
			<f a="value">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__parseBool>
		<__registerEntryPoint set="method" line="587" static="1">
			<f a="projectName:entryPoint">
				<c path="String"/>
				<x path="haxe.Function"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__registerEntryPoint>
		<__runProcess set="method" line="600" static="1">
			<f a="command:?args" v=":null">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
			</f>
			<meta>
				<m n=":value"><e>{ args : null }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__runProcess>
		<get_allowScreenTimeout set="method" line="626" static="1"><f a=""><x path="Bool"/></f></get_allowScreenTimeout>
		<set_allowScreenTimeout set="method" line="637" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowScreenTimeout>
		<get_applicationDirectory set="method" line="648" static="1"><f a=""><c path="String"/></f></get_applicationDirectory>
		<get_applicationStorageDirectory set="method" line="661" static="1"><f a=""><c path="String"/></f></get_applicationStorageDirectory>
		<get_deviceModel set="method" line="674" static="1"><f a=""><c path="String"/></f></get_deviceModel>
		<get_deviceVendor set="method" line="709" static="1"><f a=""><c path="String"/></f></get_deviceVendor>
		<get_desktopDirectory set="method" line="737" static="1"><f a=""><c path="String"/></f></get_desktopDirectory>
		<get_documentsDirectory set="method" line="750" static="1"><f a=""><c path="String"/></f></get_documentsDirectory>
		<get_endianness set="method" line="763" static="1"><f a=""><e path="lime.system.Endian"/></f></get_endianness>
		<get_fontsDirectory set="method" line="786" static="1"><f a=""><c path="String"/></f></get_fontsDirectory>
		<get_numDisplays set="method" line="799" static="1"><f a=""><x path="Int"/></f></get_numDisplays>
		<get_platformLabel set="method" line="810" static="1"><f a=""><c path="String"/></f></get_platformLabel>
		<get_platformName set="method" line="837" static="1"><f a=""><c path="String"/></f></get_platformName>
		<get_platformVersion set="method" line="878" static="1"><f a=""><c path="String"/></f></get_platformVersion>
		<get_userDirectory set="method" line="909" static="1"><f a=""><c path="String"/></f></get_userDirectory>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.system.Display</e></m>
			<m n=":access"><e>lime.system.DisplayMode</e></m>
		</meta>
	</class>
	<abstract path="lime.system._System.SystemDirectory" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/System.hx" private="1" module="lime.system.System">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.system._System.SystemDirectory_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/System.hx" private="1" module="lime.system.System" extern="1">
	<APPLICATION public="1" get="inline" set="null" expr="cast 0" line="927" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APPLICATION>
	<APPLICATION_STORAGE public="1" get="inline" set="null" expr="cast 1" line="928" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APPLICATION_STORAGE>
	<DESKTOP public="1" get="inline" set="null" expr="cast 2" line="929" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DESKTOP>
	<DOCUMENTS public="1" get="inline" set="null" expr="cast 3" line="930" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOCUMENTS>
	<FONTS public="1" get="inline" set="null" expr="cast 4" line="931" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FONTS>
	<USER public="1" get="inline" set="null" expr="cast 5" line="932" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</USER>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.system._System.SystemDirectory_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/System.hx" private="1" module="lime.system.System" extern="1">
		<APPLICATION public="1" get="inline" set="null" expr="cast 0" line="927" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APPLICATION>
		<APPLICATION_STORAGE public="1" get="inline" set="null" expr="cast 1" line="928" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APPLICATION_STORAGE>
		<DESKTOP public="1" get="inline" set="null" expr="cast 2" line="929" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DESKTOP>
		<DOCUMENTS public="1" get="inline" set="null" expr="cast 3" line="930" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOCUMENTS>
		<FONTS public="1" get="inline" set="null" expr="cast 4" line="931" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FONTS>
		<USER public="1" get="inline" set="null" expr="cast 5" line="932" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</USER>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.system.ThreadPool" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/ThreadPool.hx">
		<currentThreads public="1" set="null"><x path="Int"/></currentThreads>
		<doWork public="1" expr="new Event&lt;Function&gt;()">
			<c path="lime.app._Event_haxe_Function_Void"><f a="">
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Function>()]]></e></m></meta>
		</doWork>
		<maxThreads public="1"><x path="Int"/></maxThreads>
		<minThreads public="1"><x path="Int"/></minThreads>
		<onComplete public="1" expr="new Event&lt;Function&gt;()">
			<c path="lime.app._Event_haxe_Function_Void"><f a="">
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Function>()]]></e></m></meta>
		</onComplete>
		<onError public="1" expr="new Event&lt;Function&gt;()">
			<c path="lime.app._Event_haxe_Function_Void"><f a="">
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Function>()]]></e></m></meta>
		</onError>
		<onProgress public="1" expr="new Event&lt;Function&gt;()">
			<c path="lime.app._Event_haxe_Function_Void"><f a="">
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Function>()]]></e></m></meta>
		</onProgress>
		<onRun public="1" expr="new Event&lt;Function&gt;()">
			<c path="lime.app._Event_haxe_Function_Void"><f a="">
	<x path="haxe.Function"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Function>()]]></e></m></meta>
		</onRun>
		<queue public="1" set="method" line="76">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</queue>
		<sendComplete public="1" set="method" line="116">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</sendComplete>
		<sendError public="1" set="method" line="132">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</sendError>
		<sendProgress public="1" set="method" line="148">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</sendProgress>
		<runWork set="method" line="164">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ state : null }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</runWork>
		<new public="1" set="method" line="43">
			<f a="?minThreads:?maxThreads" v="0:1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ maxThreads : 1, minThreads : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<enum path="lime.system._ThreadPool.ThreadPoolMessageType" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/ThreadPool.hx" private="1" module="lime.system.ThreadPool">
		<COMPLETE/>
		<ERROR/>
		<EXIT/>
		<PROGRESS/>
		<WORK/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="lime.system._ThreadPool.ThreadPoolMessage" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/system/ThreadPool.hx" private="1" module="lime.system.ThreadPool">
		<state public="1"><d/></state>
		<type public="1"><e path="lime.system._ThreadPool.ThreadPoolMessageType"/></type>
		<new public="1" set="method" line="290"><f a="type:state">
	<e path="lime.system._ThreadPool.ThreadPoolMessageType"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.text.Font" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/text/Font.hx">
		<fromBytes public="1" set="method" line="103" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.text.Font"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="119" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></fromFile>
		<loadFromBytes public="1" set="method" line="135" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.app.Future"><c path="lime.text.Font"/></c>
</f></loadFromBytes>
		<loadFromFile public="1" set="method" line="142" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.text.Font"/></c>
</f></loadFromFile>
		<loadFromName public="1" set="method" line="162" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.text.Font"/></c>
</f></loadFromName>
		<ascender public="1" set="null"><x path="Int"/></ascender>
		<descender public="1" set="null"><x path="Int"/></descender>
		<height public="1" set="null"><x path="Int"/></height>
		<name public="1" set="null"><c path="String"/></name>
		<numGlyphs public="1" set="null"><x path="Int"/></numGlyphs>
		<src public="1"><d/></src>
		<underlinePosition public="1" set="null"><x path="Int"/></underlinePosition>
		<underlineThickness public="1" set="null"><x path="Int"/></underlineThickness>
		<unitsPerEM public="1" set="null"><x path="Int"/></unitsPerEM>
		<__fontID>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__fontID>
		<__fontPath>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__fontPath>
		<decompose public="1" set="method" line="86"><f a=""><t path="lime.text.NativeFontData"/></f></decompose>
		<getGlyph public="1" set="method" line="178"><f a="character">
	<c path="String"/>
	<x path="lime.text.Glyph"/>
</f></getGlyph>
		<getGlyphs public="1" set="method" line="189">
			<f a="?characters" v="&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^`&apos;\&quot;/\\&amp;*()[]{}&lt;&gt;|:;_-+=?,. &quot;">
				<c path="String"/>
				<c path="Array"><x path="lime.text.Glyph"/></c>
			</f>
			<meta><m n=":value"><e><![CDATA[{ characters : "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^`'\"/\\&*()[]{}<>|:;_-+=?,. " }]]></e></m></meta>
		</getGlyphs>
		<getGlyphMetrics public="1" set="method" line="201"><f a="glyph">
	<x path="lime.text.Glyph"/>
	<c path="lime.text.GlyphMetrics"/>
</f></getGlyphMetrics>
		<renderGlyph public="1" set="method" line="220"><f a="glyph:fontSize">
	<x path="lime.text.Glyph"/>
	<x path="Int"/>
	<c path="lime.graphics.Image"/>
</f></renderGlyph>
		<renderGlyphs public="1" set="method" line="258"><f a="glyphs:fontSize">
	<c path="Array"><x path="lime.text.Glyph"/></c>
	<x path="Int"/>
	<t path="Map">
		<x path="lime.text.Glyph"/>
		<c path="lime.graphics.Image"/>
	</t>
</f></renderGlyphs>
		<__copyFrom set="method" line="429">
			<f a="other">
				<c path="lime.text.Font"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__copyFrom>
		<__fromBytes set="method" line="455">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromBytes>
		<__fromFile set="method" line="470">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromFile>
		<__initializeSource set="method" line="485">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__initializeSource>
		<__loadFromName set="method" line="510">
			<f a="name">
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.text.Font"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__loadFromName>
		<__setSize set="method" line="619">
			<f a="size">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setSize>
		<new public="1" set="method" line="61">
			<f a="?name" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ name : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.text.Glyph</e></m>
		</meta>
	</class>
	<typedef path="lime.text.NativeFontData" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/text/Font.hx" module="lime.text.Font"><a>
	<style_name><c path="String"/></style_name>
	<num_glyphs><x path="Int"/></num_glyphs>
	<kerning><c path="Array"><t path="lime.text.NativeKerningData"/></c></kerning>
	<is_italic><x path="Bool"/></is_italic>
	<is_fixed_width><x path="Bool"/></is_fixed_width>
	<is_bold><x path="Bool"/></is_bold>
	<height><x path="Int"/></height>
	<has_kerning><x path="Bool"/></has_kerning>
	<has_glyph_names><x path="Bool"/></has_glyph_names>
	<glyphs><c path="Array"><t path="lime.text.NativeGlyphData"/></c></glyphs>
	<family_name><c path="String"/></family_name>
	<em_size><x path="Int"/></em_size>
	<descend><x path="Int"/></descend>
	<ascend><x path="Int"/></ascend>
</a></typedef>
	<typedef path="lime.text.NativeGlyphData" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/text/Font.hx" module="lime.text.Font"><a>
	<points><c path="Array"><x path="Int"/></c></points>
	<min_y><x path="Int"/></min_y>
	<min_x><x path="Int"/></min_x>
	<max_y><x path="Int"/></max_y>
	<max_x><x path="Int"/></max_x>
	<char_code><x path="Int"/></char_code>
	<advance><x path="Int"/></advance>
</a></typedef>
	<typedef path="lime.text.NativeKerningData" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/text/Font.hx" module="lime.text.Font"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
	<right_glyph><x path="Int"/></right_glyph>
	<left_glyph><x path="Int"/></left_glyph>
</a></typedef>
	<abstract path="lime.text.Glyph" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/text/Glyph.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<impl><class path="lime.text._Glyph.Glyph_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/text/Glyph.hx" private="1" module="lime.text.Glyph">
	<_new public="1" set="method" line="7" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="lime.text.Glyph"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.text._Glyph.Glyph_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/text/Glyph.hx" private="1" module="lime.text.Glyph">
		<_new public="1" set="method" line="7" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="lime.text.Glyph"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="lime.text.GlyphMetrics" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/text/GlyphMetrics.hx">
		<advance public="1"><c path="lime.math.Vector2"/></advance>
		<height public="1"><x path="Int"/></height>
		<horizontalBearing public="1"><c path="lime.math.Vector2"/></horizontalBearing>
		<verticalBearing public="1"><c path="lime.math.Vector2"/></verticalBearing>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.text.UTF8String" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/text/UTF8String.hx">
		<from>
			<icast><c path="String"/></icast>
			<icast field="fromDynamic"><d/></icast>
		</from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<impl><class path="lime.text._UTF8String.UTF8String_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/text/UTF8String.hx" private="1" module="lime.text.UTF8String">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The number of characters in `this` String.</haxe_doc>
	</length>
	<_new public="1" set="method" line="26" static="1">
		<f a="str">
			<c path="String"/>
			<x path="lime.text.UTF8String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a copy from a given String.</haxe_doc>
	</_new>
	<charAt public="1" set="method" line="39" static="1">
		<f a="this:index">
			<c path="String"/>
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
	</charAt>
	<charCodeAt public="1" set="method" line="55" static="1">
		<f a="this:index">
			<c path="String"/>
			<x path="Int"/>
			<x path="Null"><x path="Int"/></x>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
	</charCodeAt>
	<fromCharCode public="1" set="method" line="69" static="1">
		<f a="code">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
	</fromCharCode>
	<fromCharCodes public="1" set="method" line="82" static="1">
		<f a="codes">
			<c path="Array"><x path="Int"/></c>
			<c path="String"/>
		</f>
		<haxe_doc>Returns the string corresponding to the array of character codes `codes`.

		If #unifill is defined, these codes will be treated as UTF-8 code points,
		otherwise it will default to using String.fromCharCode() for each character</haxe_doc>
	</fromCharCodes>
	<indexOf public="1" set="method" line="108" static="1">
		<f a="this:str:?startIndex" v="::0">
			<c path="String"/>
			<c path="String"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":value"><e>{ startIndex : 0 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
	</indexOf>
	<lastIndexOf public="1" set="method" line="126" static="1">
		<f a="this:str:?startIndex">
			<c path="String"/>
			<c path="String"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
	</lastIndexOf>
	<split public="1" set="method" line="153" static="1">
		<f a="this:delimiter">
			<c path="String"/>
			<c path="String"/>
			<c path="Array"><c path="String"/></c>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Splits `this` String at each occurence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
	</split>
	<substr public="1" set="method" line="175" static="1">
		<f a="this:pos:?len">
			<c path="String"/>
			<x path="Int"/>
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
	</substr>
	<substring public="1" set="method" line="201" static="1">
		<f a="this:startIndex:?endIndex">
			<c path="String"/>
			<x path="Int"/>
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
	</substring>
	<toLowerCase public="1" set="method" line="213" static="1">
		<f a="this">
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
	</toLowerCase>
	<toString public="1" set="method" line="246" static="1">
		<f a="this">
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the String itself.</haxe_doc>
	</toString>
	<toUpperCase public="1" set="method" line="258" static="1">
		<f a="this">
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
	</toUpperCase>
	<equals set="method" line="288" static="1">
		<f a="a:b">
			<x path="lime.text.UTF8String"/>
			<x path="lime.text.UTF8String"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
	</equals>
	<lt set="method" line="296" static="1">
		<f a="a:b">
			<x path="lime.text.UTF8String"/>
			<x path="lime.text.UTF8String"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</lt>
	<gt set="method" line="305" static="1">
		<f a="a:b">
			<x path="lime.text.UTF8String"/>
			<x path="lime.text.UTF8String"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</gt>
	<lteq set="method" line="314" static="1">
		<f a="a:b">
			<x path="lime.text.UTF8String"/>
			<x path="lime.text.UTF8String"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</lteq>
	<gteq set="method" line="323" static="1">
		<f a="a:b">
			<x path="lime.text.UTF8String"/>
			<x path="lime.text.UTF8String"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</gteq>
	<plus set="method" line="332" static="1">
		<f a="a:b">
			<x path="lime.text.UTF8String"/>
			<x path="lime.text.UTF8String"/>
			<x path="lime.text.UTF8String"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</plus>
	<fromDynamic set="method" line="346" static="1">
		<f a="value">
			<d/>
			<x path="lime.text.UTF8String"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromDynamic>
	<get_length set="method" line="360" static="1">
		<f a="this">
			<c path="String"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_length>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.text._UTF8String.UTF8String_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/text/UTF8String.hx" private="1" module="lime.text.UTF8String">
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<_new public="1" set="method" line="26" static="1">
			<f a="str">
				<c path="String"/>
				<x path="lime.text.UTF8String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</_new>
		<charAt public="1" set="method" line="39" static="1">
			<f a="this:index">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method" line="55" static="1">
			<f a="this:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<fromCharCode public="1" set="method" line="69" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<fromCharCodes public="1" set="method" line="82" static="1">
			<f a="codes">
				<c path="Array"><x path="Int"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the string corresponding to the array of character codes `codes`.

		If #unifill is defined, these codes will be treated as UTF-8 code points,
		otherwise it will default to using String.fromCharCode() for each character</haxe_doc>
		</fromCharCodes>
		<indexOf public="1" set="method" line="108" static="1">
			<f a="this:str:?startIndex" v="::0">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":value"><e>{ startIndex : 0 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method" line="126" static="1">
			<f a="this:str:?startIndex">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method" line="153" static="1">
			<f a="this:delimiter">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method" line="175" static="1">
			<f a="this:pos:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method" line="201" static="1">
			<f a="this:startIndex:?endIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toLowerCase public="1" set="method" line="213" static="1">
			<f a="this">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<toString public="1" set="method" line="246" static="1">
			<f a="this">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<toUpperCase public="1" set="method" line="258" static="1">
			<f a="this">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<equals set="method" line="288" static="1">
			<f a="a:b">
				<x path="lime.text.UTF8String"/>
				<x path="lime.text.UTF8String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
		</equals>
		<lt set="method" line="296" static="1">
			<f a="a:b">
				<x path="lime.text.UTF8String"/>
				<x path="lime.text.UTF8String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</lt>
		<gt set="method" line="305" static="1">
			<f a="a:b">
				<x path="lime.text.UTF8String"/>
				<x path="lime.text.UTF8String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</gt>
		<lteq set="method" line="314" static="1">
			<f a="a:b">
				<x path="lime.text.UTF8String"/>
				<x path="lime.text.UTF8String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</lteq>
		<gteq set="method" line="323" static="1">
			<f a="a:b">
				<x path="lime.text.UTF8String"/>
				<x path="lime.text.UTF8String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</gteq>
		<plus set="method" line="332" static="1">
			<f a="a:b">
				<x path="lime.text.UTF8String"/>
				<x path="lime.text.UTF8String"/>
				<x path="lime.text.UTF8String"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</plus>
		<fromDynamic set="method" line="346" static="1">
			<f a="value">
				<d/>
				<x path="lime.text.UTF8String"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromDynamic>
		<get_length set="method" line="360" static="1">
			<f a="this">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_length>
		<meta><m n=":final"/></meta>
	</class>
	<class path="lime.text._UTF8String.Utf8Ext" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/text/UTF8String.hx" private="1" module="lime.text.UTF8String">
		<fillUpperToLowerMap public="1" set="method" line="373" static="1"><f a="map">
	<t path="Map">
		<x path="Int"/>
		<x path="Int"/>
	</t>
	<x path="Void"/>
</f></fillUpperToLowerMap>
		<fillLowerToUpperMap public="1" set="method" line="535" static="1"><f a="map">
	<t path="Map">
		<x path="Int"/>
		<x path="Int"/>
	</t>
	<x path="Void"/>
</f></fillLowerToUpperMap>
	</class>
	<class path="lime.ui.FileDialog" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/FileDialog.hx">
		<onCancel public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onCancel>
		<onOpen public="1" expr="new Event&lt;Resource&gt;()">
			<c path="lime.app._Event_lime_utils_Resource_Void"><f a="">
	<x path="lime.utils.Resource"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Resource>()]]></e></m></meta>
		</onOpen>
		<onSave public="1" expr="new Event&lt;String&gt;()">
			<c path="lime.app._Event_String_Void"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<String>()]]></e></m></meta>
		</onSave>
		<onSelect public="1" expr="new Event&lt;String&gt;()">
			<c path="lime.app._Event_String_Void"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<String>()]]></e></m></meta>
		</onSelect>
		<onSelectMultiple public="1" expr="new Event&lt;Array&lt;String&gt;&gt;()">
			<c path="lime.app._Event_Array_String__Void"><f a="">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Array<String>>()]]></e></m></meta>
		</onSelectMultiple>
		<browse public="1" set="method" line="47">
			<f a="?type:?filter:?defaultPath:?title" v="null:null:null:null">
				<e path="lime.ui.FileDialogType"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ title : null, defaultPath : null, filter : null, type : null }</e></m></meta>
		</browse>
		<open public="1" set="method" line="152">
			<f a="?filter:?defaultPath:?title" v="null:null:null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ title : null, defaultPath : null, filter : null }</e></m></meta>
		</open>
		<save public="1" set="method" line="200">
			<f a="data:?filter:?defaultPath:?title" v=":null:null:null">
				<x path="lime.utils.Resource"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ title : null, defaultPath : null, filter : null }</e></m></meta>
		</save>
		<new public="1" set="method" line="40"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.graphics.Image</e></m>
		</meta>
	</class>
	<enum path="lime.ui.FileDialogType" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/FileDialogType.hx">
		<OPEN/>
		<OPEN_MULTIPLE/>
		<SAVE/>
		<OPEN_DIRECTORY/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="lime.ui.Gamepad" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Gamepad.hx">
		<devices public="1" expr="new Map&lt;Int,Gamepad&gt;()" line="19" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="lime.ui.Gamepad"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Gamepad>()]]></e></m></meta>
		</devices>
		<onConnect public="1" expr="new Event&lt;Gamepad&gt;()" line="20" static="1">
			<c path="lime.app._Event_lime_ui_Gamepad_Void"><f a="">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Gamepad>()]]></e></m></meta>
		</onConnect>
		<addMappings public="1" set="method" line="40" static="1"><f a="mappings">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></addMappings>
		<__connect set="method" line="54" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__connect>
		<__disconnect set="method" line="67" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__disconnect>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<guid public="1" get="accessor" set="null"><c path="String"/></guid>
		<id public="1" set="null"><x path="Int"/></id>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<onAxisMove public="1" expr="new Event&lt;GamepadAxis -&gt; Float&gt;()">
			<c path="lime.app._Event_lime_ui_GamepadAxis_Float_Void"><f a=":">
	<x path="lime.ui.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<GamepadAxis -> Float>()]]></e></m></meta>
		</onAxisMove>
		<onButtonDown public="1" expr="new Event&lt;GamepadButton&gt;()">
			<c path="lime.app._Event_lime_ui_GamepadButton_Void"><f a="">
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<GamepadButton>()]]></e></m></meta>
		</onButtonDown>
		<onButtonUp public="1" expr="new Event&lt;GamepadButton&gt;()">
			<c path="lime.app._Event_lime_ui_GamepadButton_Void"><f a="">
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<GamepadButton>()]]></e></m></meta>
		</onButtonUp>
		<onDisconnect public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onDisconnect>
		<get_guid get="inline" set="null" line="84">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_guid>
		<get_name get="inline" set="null" line="102">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_name>
		<new public="1" set="method" line="32"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.ui.Joystick</e></m>
		</meta>
	</class>
	<abstract path="lime.ui.GamepadAxis" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/GamepadAxis.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._GamepadAxis.GamepadAxis_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/GamepadAxis.hx" private="1" module="lime.ui.GamepadAxis">
	<LEFT_X public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_X>
	<LEFT_Y public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_Y>
	<RIGHT_X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_X>
	<RIGHT_Y public="1" get="inline" set="null" expr="cast 3" line="10" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_Y>
	<TRIGGER_LEFT public="1" get="inline" set="null" expr="cast 4" line="11" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TRIGGER_LEFT>
	<TRIGGER_RIGHT public="1" get="inline" set="null" expr="cast 5" line="12" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TRIGGER_RIGHT>
	<toString public="1" get="inline" set="null" line="15" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.ui._GamepadAxis.GamepadAxis_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/GamepadAxis.hx" private="1" module="lime.ui.GamepadAxis">
		<LEFT_X public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_X>
		<LEFT_Y public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_Y>
		<RIGHT_X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_X>
		<RIGHT_Y public="1" get="inline" set="null" expr="cast 3" line="10" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_Y>
		<TRIGGER_LEFT public="1" get="inline" set="null" expr="cast 4" line="11" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TRIGGER_LEFT>
		<TRIGGER_RIGHT public="1" get="inline" set="null" expr="cast 5" line="12" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TRIGGER_RIGHT>
		<toString public="1" get="inline" set="null" line="15" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.ui.GamepadButton" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/GamepadButton.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._GamepadButton.GamepadButton_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/GamepadButton.hx" private="1" module="lime.ui.GamepadButton">
	<A public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A>
	<B public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</B>
	<X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</X>
	<Y public="1" get="inline" set="null" expr="cast 3" line="10" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Y>
	<BACK public="1" get="inline" set="null" expr="cast 4" line="11" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACK>
	<GUIDE public="1" get="inline" set="null" expr="cast 5" line="12" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GUIDE>
	<START public="1" get="inline" set="null" expr="cast 6" line="13" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</START>
	<LEFT_STICK public="1" get="inline" set="null" expr="cast 7" line="14" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_STICK>
	<RIGHT_STICK public="1" get="inline" set="null" expr="cast 8" line="15" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_STICK>
	<LEFT_SHOULDER public="1" get="inline" set="null" expr="cast 9" line="16" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_SHOULDER>
	<RIGHT_SHOULDER public="1" get="inline" set="null" expr="cast 10" line="17" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_SHOULDER>
	<DPAD_UP public="1" get="inline" set="null" expr="cast 11" line="18" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_UP>
	<DPAD_DOWN public="1" get="inline" set="null" expr="cast 12" line="19" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_DOWN>
	<DPAD_LEFT public="1" get="inline" set="null" expr="cast 13" line="20" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_LEFT>
	<DPAD_RIGHT public="1" get="inline" set="null" expr="cast 14" line="21" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_RIGHT>
	<toString public="1" get="inline" set="null" line="24" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.ui._GamepadButton.GamepadButton_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/GamepadButton.hx" private="1" module="lime.ui.GamepadButton">
		<A public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A>
		<B public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</B>
		<X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</X>
		<Y public="1" get="inline" set="null" expr="cast 3" line="10" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Y>
		<BACK public="1" get="inline" set="null" expr="cast 4" line="11" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACK>
		<GUIDE public="1" get="inline" set="null" expr="cast 5" line="12" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GUIDE>
		<START public="1" get="inline" set="null" expr="cast 6" line="13" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</START>
		<LEFT_STICK public="1" get="inline" set="null" expr="cast 7" line="14" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_STICK>
		<RIGHT_STICK public="1" get="inline" set="null" expr="cast 8" line="15" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_STICK>
		<LEFT_SHOULDER public="1" get="inline" set="null" expr="cast 9" line="16" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_SHOULDER>
		<RIGHT_SHOULDER public="1" get="inline" set="null" expr="cast 10" line="17" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_SHOULDER>
		<DPAD_UP public="1" get="inline" set="null" expr="cast 11" line="18" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_UP>
		<DPAD_DOWN public="1" get="inline" set="null" expr="cast 12" line="19" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_DOWN>
		<DPAD_LEFT public="1" get="inline" set="null" expr="cast 13" line="20" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" expr="cast 14" line="21" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_RIGHT>
		<toString public="1" get="inline" set="null" line="24" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.ui.Haptic" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Haptic.hx">
		<vibrate public="1" set="method" line="24" static="1"><f a="period:duration">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></vibrate>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime.ui.Joystick" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Joystick.hx">
		<devices public="1" expr="new Map&lt;Int,Joystick&gt;()" line="18" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="lime.ui.Joystick"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Joystick>()]]></e></m></meta>
		</devices>
		<onConnect public="1" expr="new Event&lt;Joystick&gt;()" line="19" static="1">
			<c path="lime.app._Event_lime_ui_Joystick_Void"><f a="">
	<c path="lime.ui.Joystick"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Joystick>()]]></e></m></meta>
		</onConnect>
		<__connect set="method" line="45" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__connect>
		<__disconnect set="method" line="58" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__disconnect>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<guid public="1" get="accessor" set="null"><c path="String"/></guid>
		<id public="1" set="null"><x path="Int"/></id>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<numAxes public="1" get="accessor" set="null"><x path="Int"/></numAxes>
		<numButtons public="1" get="accessor" set="null"><x path="Int"/></numButtons>
		<numHats public="1" get="accessor" set="null"><x path="Int"/></numHats>
		<numTrackballs public="1" get="accessor" set="null"><x path="Int"/></numTrackballs>
		<onAxisMove public="1" expr="new Event&lt;Int -&gt; Float&gt;()">
			<c path="lime.app._Event_Int_Float_Void"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> Float>()]]></e></m></meta>
		</onAxisMove>
		<onButtonDown public="1" expr="new Event&lt;Int&gt;()">
			<c path="lime.app._Event_Int_Void"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int>()]]></e></m></meta>
		</onButtonDown>
		<onButtonUp public="1" expr="new Event&lt;Int&gt;()">
			<c path="lime.app._Event_Int_Void"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int>()]]></e></m></meta>
		</onButtonUp>
		<onDisconnect public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onDisconnect>
		<onHatMove public="1" expr="new Event&lt;Int -&gt; JoystickHatPosition&gt;()">
			<c path="lime.app._Event_Int_lime_ui_JoystickHatPosition_Void"><f a=":">
	<x path="Int"/>
	<x path="lime.ui.JoystickHatPosition"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> JoystickHatPosition>()]]></e></m></meta>
		</onHatMove>
		<onTrackballMove public="1" expr="new Event&lt;Int -&gt; Float -&gt; Float&gt;()">
			<c path="lime.app._Event_Int_Float_Float_Void"><f a="::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> Float -> Float>()]]></e></m></meta>
		</onTrackballMove>
		<get_guid get="inline" set="null" line="84">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_guid>
		<get_name get="inline" set="null" line="102">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_name>
		<get_numAxes get="inline" set="null" line="120">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numAxes>
		<get_numButtons get="inline" set="null" line="134">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numButtons>
		<get_numHats get="inline" set="null" line="148">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numHats>
		<get_numTrackballs get="inline" set="null" line="159">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numTrackballs>
		<new public="1" set="method" line="37"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<abstract path="lime.ui.JoystickHatPosition" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/JoystickHatPosition.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<impl><class path="lime.ui._JoystickHatPosition.JoystickHatPosition_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/JoystickHatPosition.hx" private="1" module="lime.ui.JoystickHatPosition">
	<CENTER public="1" get="inline" set="null" expr="0x00" line="7" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x00</e></m></meta>
	</CENTER>
	<DOWN public="1" get="inline" set="null" expr="0x04" line="8" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x04</e></m></meta>
	</DOWN>
	<LEFT public="1" get="inline" set="null" expr="0x08" line="9" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x08</e></m></meta>
	</LEFT>
	<RIGHT public="1" get="inline" set="null" expr="0x02" line="10" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x02</e></m></meta>
	</RIGHT>
	<UP public="1" get="inline" set="null" expr="0x01" line="11" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x01</e></m></meta>
	</UP>
	<DOWN_LEFT public="1" get="inline" set="null" expr="(0x04 | 0x08)" line="13" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>(0x04 | 0x08)</e></m></meta>
	</DOWN_LEFT>
	<DOWN_RIGHT public="1" get="inline" set="null" expr="(0x04 | 0x02)" line="14" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>(0x04 | 0x02)</e></m></meta>
	</DOWN_RIGHT>
	<UP_LEFT public="1" get="inline" set="null" expr="(0x01 | 0x08)" line="15" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>(0x01 | 0x08)</e></m></meta>
	</UP_LEFT>
	<UP_RIGHT public="1" get="inline" set="null" expr="(0x01 | 0x02)" line="16" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>(0x01 | 0x02)</e></m></meta>
	</UP_RIGHT>
	<center public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</center>
	<down public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</down>
	<left public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</left>
	<right public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</right>
	<up public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</up>
	<_new public="1" set="method" line="25" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="lime.ui.JoystickHatPosition"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get_center set="method" line="32" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_center>
	<set_center get="inline" set="null" line="39" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_center>
	<get_down set="method" line="52" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_down>
	<set_down get="inline" set="null" line="59" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_down>
	<get_left set="method" line="76" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_left>
	<set_left get="inline" set="null" line="83" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_left>
	<get_right set="method" line="100" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_right>
	<set_right get="inline" set="null" line="107" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_right>
	<get_up set="method" line="124" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_up>
	<set_up get="inline" set="null" line="131" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_up>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.ui._JoystickHatPosition.JoystickHatPosition_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/JoystickHatPosition.hx" private="1" module="lime.ui.JoystickHatPosition">
		<CENTER public="1" get="inline" set="null" expr="0x00" line="7" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x00</e></m></meta>
		</CENTER>
		<DOWN public="1" get="inline" set="null" expr="0x04" line="8" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x04</e></m></meta>
		</DOWN>
		<LEFT public="1" get="inline" set="null" expr="0x08" line="9" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x08</e></m></meta>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" expr="0x02" line="10" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x02</e></m></meta>
		</RIGHT>
		<UP public="1" get="inline" set="null" expr="0x01" line="11" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x01</e></m></meta>
		</UP>
		<DOWN_LEFT public="1" get="inline" set="null" expr="(0x04 | 0x08)" line="13" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>(0x04 | 0x08)</e></m></meta>
		</DOWN_LEFT>
		<DOWN_RIGHT public="1" get="inline" set="null" expr="(0x04 | 0x02)" line="14" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>(0x04 | 0x02)</e></m></meta>
		</DOWN_RIGHT>
		<UP_LEFT public="1" get="inline" set="null" expr="(0x01 | 0x08)" line="15" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>(0x01 | 0x08)</e></m></meta>
		</UP_LEFT>
		<UP_RIGHT public="1" get="inline" set="null" expr="(0x01 | 0x02)" line="16" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>(0x01 | 0x02)</e></m></meta>
		</UP_RIGHT>
		<center public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</center>
		<down public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</down>
		<left public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</left>
		<right public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</right>
		<up public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</up>
		<_new public="1" set="method" line="25" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="lime.ui.JoystickHatPosition"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get_center set="method" line="32" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_center>
		<set_center get="inline" set="null" line="39" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_center>
		<get_down set="method" line="52" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_down>
		<set_down get="inline" set="null" line="59" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_down>
		<get_left set="method" line="76" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_left>
		<set_left get="inline" set="null" line="83" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_left>
		<get_right set="method" line="100" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_right>
		<set_right get="inline" set="null" line="107" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_right>
		<get_up set="method" line="124" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_up>
		<set_up get="inline" set="null" line="131" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_up>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.ui.KeyCode" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/KeyCode.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
			<icast field="fromScanCode"><x path="lime.ui.ScanCode"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="lime.ui._KeyCode.KeyCode_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/KeyCode.hx" private="1" module="lime.ui.KeyCode">
	<UNKNOWN public="1" get="inline" set="null" expr="cast 0x00" line="12" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x00</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNKNOWN>
	<BACKSPACE public="1" get="inline" set="null" expr="cast 0x08" line="13" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x08</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSPACE>
	<TAB public="1" get="inline" set="null" expr="cast 0x09" line="14" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x09</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAB>
	<RETURN public="1" get="inline" set="null" expr="cast 0x0D" line="15" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x0D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RETURN>
	<ESCAPE public="1" get="inline" set="null" expr="cast 0x1B" line="16" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x1B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ESCAPE>
	<SPACE public="1" get="inline" set="null" expr="cast 0x20" line="17" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SPACE>
	<EXCLAMATION public="1" get="inline" set="null" expr="cast 0x21" line="18" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x21</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXCLAMATION>
	<QUOTE public="1" get="inline" set="null" expr="cast 0x22" line="19" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x22</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</QUOTE>
	<HASH public="1" get="inline" set="null" expr="cast 0x23" line="20" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x23</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HASH>
	<DOLLAR public="1" get="inline" set="null" expr="cast 0x24" line="21" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x24</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOLLAR>
	<PERCENT public="1" get="inline" set="null" expr="cast 0x25" line="22" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x25</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PERCENT>
	<AMPERSAND public="1" get="inline" set="null" expr="cast 0x26" line="23" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x26</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AMPERSAND>
	<SINGLE_QUOTE public="1" get="inline" set="null" expr="cast 0x27" line="24" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x27</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SINGLE_QUOTE>
	<LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x28" line="25" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x28</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_PARENTHESIS>
	<RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x29" line="26" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x29</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_PARENTHESIS>
	<ASTERISK public="1" get="inline" set="null" expr="cast 0x2A" line="27" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ASTERISK>
	<PLUS public="1" get="inline" set="null" expr="cast 0x2B" line="28" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PLUS>
	<COMMA public="1" get="inline" set="null" expr="cast 0x2C" line="29" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMMA>
	<MINUS public="1" get="inline" set="null" expr="cast 0x2D" line="30" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MINUS>
	<PERIOD public="1" get="inline" set="null" expr="cast 0x2E" line="31" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PERIOD>
	<SLASH public="1" get="inline" set="null" expr="cast 0x2F" line="32" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLASH>
	<NUMBER_0 public="1" get="inline" set="null" expr="cast 0x30" line="33" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x30</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_0>
	<NUMBER_1 public="1" get="inline" set="null" expr="cast 0x31" line="34" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x31</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_1>
	<NUMBER_2 public="1" get="inline" set="null" expr="cast 0x32" line="35" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x32</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_2>
	<NUMBER_3 public="1" get="inline" set="null" expr="cast 0x33" line="36" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x33</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_3>
	<NUMBER_4 public="1" get="inline" set="null" expr="cast 0x34" line="37" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x34</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_4>
	<NUMBER_5 public="1" get="inline" set="null" expr="cast 0x35" line="38" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x35</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_5>
	<NUMBER_6 public="1" get="inline" set="null" expr="cast 0x36" line="39" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x36</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_6>
	<NUMBER_7 public="1" get="inline" set="null" expr="cast 0x37" line="40" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x37</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_7>
	<NUMBER_8 public="1" get="inline" set="null" expr="cast 0x38" line="41" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x38</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_8>
	<NUMBER_9 public="1" get="inline" set="null" expr="cast 0x39" line="42" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x39</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_9>
	<COLON public="1" get="inline" set="null" expr="cast 0x3A" line="43" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COLON>
	<SEMICOLON public="1" get="inline" set="null" expr="cast 0x3B" line="44" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEMICOLON>
	<LESS_THAN public="1" get="inline" set="null" expr="cast 0x3C" line="45" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LESS_THAN>
	<EQUALS public="1" get="inline" set="null" expr="cast 0x3D" line="46" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EQUALS>
	<GREATER_THAN public="1" get="inline" set="null" expr="cast 0x3E" line="47" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREATER_THAN>
	<QUESTION public="1" get="inline" set="null" expr="cast 0x3F" line="48" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</QUESTION>
	<AT public="1" get="inline" set="null" expr="cast 0x40" line="49" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AT>
	<LEFT_BRACKET public="1" get="inline" set="null" expr="cast 0x5B" line="50" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_BRACKET>
	<BACKSLASH public="1" get="inline" set="null" expr="cast 0x5C" line="51" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSLASH>
	<RIGHT_BRACKET public="1" get="inline" set="null" expr="cast 0x5D" line="52" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_BRACKET>
	<CARET public="1" get="inline" set="null" expr="cast 0x5E" line="53" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CARET>
	<UNDERSCORE public="1" get="inline" set="null" expr="cast 0x5F" line="54" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNDERSCORE>
	<GRAVE public="1" get="inline" set="null" expr="cast 0x60" line="55" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x60</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRAVE>
	<A public="1" get="inline" set="null" expr="cast 0x61" line="56" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x61</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A>
	<B public="1" get="inline" set="null" expr="cast 0x62" line="57" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x62</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</B>
	<C public="1" get="inline" set="null" expr="cast 0x63" line="58" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x63</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</C>
	<D public="1" get="inline" set="null" expr="cast 0x64" line="59" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x64</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</D>
	<E public="1" get="inline" set="null" expr="cast 0x65" line="60" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x65</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</E>
	<F public="1" get="inline" set="null" expr="cast 0x66" line="61" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x66</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F>
	<G public="1" get="inline" set="null" expr="cast 0x67" line="62" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x67</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</G>
	<H public="1" get="inline" set="null" expr="cast 0x68" line="63" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x68</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</H>
	<I public="1" get="inline" set="null" expr="cast 0x69" line="64" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x69</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</I>
	<J public="1" get="inline" set="null" expr="cast 0x6A" line="65" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</J>
	<K public="1" get="inline" set="null" expr="cast 0x6B" line="66" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</K>
	<L public="1" get="inline" set="null" expr="cast 0x6C" line="67" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</L>
	<M public="1" get="inline" set="null" expr="cast 0x6D" line="68" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</M>
	<N public="1" get="inline" set="null" expr="cast 0x6E" line="69" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</N>
	<O public="1" get="inline" set="null" expr="cast 0x6F" line="70" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</O>
	<P public="1" get="inline" set="null" expr="cast 0x70" line="71" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x70</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</P>
	<Q public="1" get="inline" set="null" expr="cast 0x71" line="72" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x71</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Q>
	<R public="1" get="inline" set="null" expr="cast 0x72" line="73" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x72</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</R>
	<S public="1" get="inline" set="null" expr="cast 0x73" line="74" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x73</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</S>
	<T public="1" get="inline" set="null" expr="cast 0x74" line="75" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x74</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</T>
	<U public="1" get="inline" set="null" expr="cast 0x75" line="76" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x75</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</U>
	<V public="1" get="inline" set="null" expr="cast 0x76" line="77" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x76</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</V>
	<W public="1" get="inline" set="null" expr="cast 0x77" line="78" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x77</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</W>
	<X public="1" get="inline" set="null" expr="cast 0x78" line="79" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x78</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</X>
	<Y public="1" get="inline" set="null" expr="cast 0x79" line="80" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x79</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Y>
	<Z public="1" get="inline" set="null" expr="cast 0x7A" line="81" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x7A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Z>
	<DELETE public="1" get="inline" set="null" expr="cast 0x7F" line="82" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x7F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DELETE>
	<CAPS_LOCK public="1" get="inline" set="null" expr="cast 0x40000039" line="83" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000039</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CAPS_LOCK>
	<F1 public="1" get="inline" set="null" expr="cast 0x4000003A" line="84" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F1>
	<F2 public="1" get="inline" set="null" expr="cast 0x4000003B" line="85" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F2>
	<F3 public="1" get="inline" set="null" expr="cast 0x4000003C" line="86" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F3>
	<F4 public="1" get="inline" set="null" expr="cast 0x4000003D" line="87" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F4>
	<F5 public="1" get="inline" set="null" expr="cast 0x4000003E" line="88" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F5>
	<F6 public="1" get="inline" set="null" expr="cast 0x4000003F" line="89" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F6>
	<F7 public="1" get="inline" set="null" expr="cast 0x40000040" line="90" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000040</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F7>
	<F8 public="1" get="inline" set="null" expr="cast 0x40000041" line="91" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000041</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F8>
	<F9 public="1" get="inline" set="null" expr="cast 0x40000042" line="92" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000042</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F9>
	<F10 public="1" get="inline" set="null" expr="cast 0x40000043" line="93" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000043</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F10>
	<F11 public="1" get="inline" set="null" expr="cast 0x40000044" line="94" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000044</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F11>
	<F12 public="1" get="inline" set="null" expr="cast 0x40000045" line="95" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000045</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F12>
	<PRINT_SCREEN public="1" get="inline" set="null" expr="cast 0x40000046" line="96" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000046</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRINT_SCREEN>
	<SCROLL_LOCK public="1" get="inline" set="null" expr="cast 0x40000047" line="97" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000047</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SCROLL_LOCK>
	<PAUSE public="1" get="inline" set="null" expr="cast 0x40000048" line="98" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000048</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAUSE>
	<INSERT public="1" get="inline" set="null" expr="cast 0x40000049" line="99" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000049</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INSERT>
	<HOME public="1" get="inline" set="null" expr="cast 0x4000004A" line="100" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HOME>
	<PAGE_UP public="1" get="inline" set="null" expr="cast 0x4000004B" line="101" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGE_UP>
	<END public="1" get="inline" set="null" expr="cast 0x4000004D" line="102" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</END>
	<PAGE_DOWN public="1" get="inline" set="null" expr="cast 0x4000004E" line="103" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGE_DOWN>
	<RIGHT public="1" get="inline" set="null" expr="cast 0x4000004F" line="104" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<LEFT public="1" get="inline" set="null" expr="cast 0x40000050" line="105" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000050</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<DOWN public="1" get="inline" set="null" expr="cast 0x40000051" line="106" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000051</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOWN>
	<UP public="1" get="inline" set="null" expr="cast 0x40000052" line="107" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000052</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UP>
	<NUM_LOCK public="1" get="inline" set="null" expr="cast 0x40000053" line="108" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000053</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUM_LOCK>
	<NUMPAD_DIVIDE public="1" get="inline" set="null" expr="cast 0x40000054" line="109" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000054</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DIVIDE>
	<NUMPAD_MULTIPLY public="1" get="inline" set="null" expr="cast 0x40000055" line="110" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000055</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MULTIPLY>
	<NUMPAD_MINUS public="1" get="inline" set="null" expr="cast 0x40000056" line="111" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000056</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MINUS>
	<NUMPAD_PLUS public="1" get="inline" set="null" expr="cast 0x40000057" line="112" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000057</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PLUS>
	<NUMPAD_ENTER public="1" get="inline" set="null" expr="cast 0x40000058" line="113" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000058</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_ENTER>
	<NUMPAD_1 public="1" get="inline" set="null" expr="cast 0x40000059" line="114" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000059</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_1>
	<NUMPAD_2 public="1" get="inline" set="null" expr="cast 0x4000005A" line="115" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_2>
	<NUMPAD_3 public="1" get="inline" set="null" expr="cast 0x4000005B" line="116" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_3>
	<NUMPAD_4 public="1" get="inline" set="null" expr="cast 0x4000005C" line="117" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_4>
	<NUMPAD_5 public="1" get="inline" set="null" expr="cast 0x4000005D" line="118" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_5>
	<NUMPAD_6 public="1" get="inline" set="null" expr="cast 0x4000005E" line="119" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_6>
	<NUMPAD_7 public="1" get="inline" set="null" expr="cast 0x4000005F" line="120" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_7>
	<NUMPAD_8 public="1" get="inline" set="null" expr="cast 0x40000060" line="121" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000060</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_8>
	<NUMPAD_9 public="1" get="inline" set="null" expr="cast 0x40000061" line="122" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000061</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_9>
	<NUMPAD_0 public="1" get="inline" set="null" expr="cast 0x40000062" line="123" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000062</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_0>
	<NUMPAD_PERIOD public="1" get="inline" set="null" expr="cast 0x40000063" line="124" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000063</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PERIOD>
	<APPLICATION public="1" get="inline" set="null" expr="cast 0x40000065" line="125" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000065</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APPLICATION>
	<POWER public="1" get="inline" set="null" expr="cast 0x40000066" line="126" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000066</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</POWER>
	<NUMPAD_EQUALS public="1" get="inline" set="null" expr="cast 0x40000067" line="127" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000067</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_EQUALS>
	<F13 public="1" get="inline" set="null" expr="cast 0x40000068" line="128" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000068</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F13>
	<F14 public="1" get="inline" set="null" expr="cast 0x40000069" line="129" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000069</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F14>
	<F15 public="1" get="inline" set="null" expr="cast 0x4000006A" line="130" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F15>
	<F16 public="1" get="inline" set="null" expr="cast 0x4000006B" line="131" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F16>
	<F17 public="1" get="inline" set="null" expr="cast 0x4000006C" line="132" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F17>
	<F18 public="1" get="inline" set="null" expr="cast 0x4000006D" line="133" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F18>
	<F19 public="1" get="inline" set="null" expr="cast 0x4000006E" line="134" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F19>
	<F20 public="1" get="inline" set="null" expr="cast 0x4000006F" line="135" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F20>
	<F21 public="1" get="inline" set="null" expr="cast 0x40000070" line="136" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000070</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F21>
	<F22 public="1" get="inline" set="null" expr="cast 0x40000071" line="137" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000071</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F22>
	<F23 public="1" get="inline" set="null" expr="cast 0x40000072" line="138" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000072</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F23>
	<F24 public="1" get="inline" set="null" expr="cast 0x40000073" line="139" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000073</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F24>
	<EXECUTE public="1" get="inline" set="null" expr="cast 0x40000074" line="140" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000074</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXECUTE>
	<HELP public="1" get="inline" set="null" expr="cast 0x40000075" line="141" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000075</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HELP>
	<MENU public="1" get="inline" set="null" expr="cast 0x40000076" line="142" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000076</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MENU>
	<SELECT public="1" get="inline" set="null" expr="cast 0x40000077" line="143" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000077</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SELECT>
	<STOP public="1" get="inline" set="null" expr="cast 0x40000078" line="144" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000078</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STOP>
	<AGAIN public="1" get="inline" set="null" expr="cast 0x40000079" line="145" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000079</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AGAIN>
	<UNDO public="1" get="inline" set="null" expr="cast 0x4000007A" line="146" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNDO>
	<CUT public="1" get="inline" set="null" expr="cast 0x4000007B" line="147" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CUT>
	<COPY public="1" get="inline" set="null" expr="cast 0x4000007C" line="148" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COPY>
	<PASTE public="1" get="inline" set="null" expr="cast 0x4000007D" line="149" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PASTE>
	<FIND public="1" get="inline" set="null" expr="cast 0x4000007E" line="150" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIND>
	<MUTE public="1" get="inline" set="null" expr="cast 0x4000007F" line="151" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MUTE>
	<VOLUME_UP public="1" get="inline" set="null" expr="cast 0x40000080" line="152" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000080</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOLUME_UP>
	<VOLUME_DOWN public="1" get="inline" set="null" expr="cast 0x40000081" line="153" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000081</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOLUME_DOWN>
	<NUMPAD_COMMA public="1" get="inline" set="null" expr="cast 0x40000085" line="154" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000085</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_COMMA>
	<ALT_ERASE public="1" get="inline" set="null" expr="cast 0x40000099" line="156" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000099</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALT_ERASE>
	<SYSTEM_REQUEST public="1" get="inline" set="null" expr="cast 0x4000009A" line="157" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SYSTEM_REQUEST>
	<CANCEL public="1" get="inline" set="null" expr="cast 0x4000009B" line="158" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CANCEL>
	<CLEAR public="1" get="inline" set="null" expr="cast 0x4000009C" line="159" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLEAR>
	<PRIOR public="1" get="inline" set="null" expr="cast 0x4000009D" line="160" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRIOR>
	<RETURN2 public="1" get="inline" set="null" expr="cast 0x4000009E" line="161" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RETURN2>
	<SEPARATOR public="1" get="inline" set="null" expr="cast 0x4000009F" line="162" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEPARATOR>
	<OUT public="1" get="inline" set="null" expr="cast 0x400000A0" line="163" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OUT>
	<OPER public="1" get="inline" set="null" expr="cast 0x400000A1" line="164" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OPER>
	<CLEAR_AGAIN public="1" get="inline" set="null" expr="cast 0x400000A2" line="165" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLEAR_AGAIN>
	<CRSEL public="1" get="inline" set="null" expr="cast 0x400000A3" line="166" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CRSEL>
	<EXSEL public="1" get="inline" set="null" expr="cast 0x400000A4" line="167" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXSEL>
	<NUMPAD_00 public="1" get="inline" set="null" expr="cast 0x400000B0" line="168" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_00>
	<NUMPAD_000 public="1" get="inline" set="null" expr="cast 0x400000B1" line="169" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_000>
	<THOUSAND_SEPARATOR public="1" get="inline" set="null" expr="cast 0x400000B2" line="170" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</THOUSAND_SEPARATOR>
	<DECIMAL_SEPARATOR public="1" get="inline" set="null" expr="cast 0x400000B3" line="171" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DECIMAL_SEPARATOR>
	<CURRENCY_UNIT public="1" get="inline" set="null" expr="cast 0x400000B4" line="172" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURRENCY_UNIT>
	<CURRENCY_SUBUNIT public="1" get="inline" set="null" expr="cast 0x400000B5" line="173" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURRENCY_SUBUNIT>
	<NUMPAD_LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x400000B6" line="174" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LEFT_PARENTHESIS>
	<NUMPAD_RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x400000B7" line="175" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_RIGHT_PARENTHESIS>
	<NUMPAD_LEFT_BRACE public="1" get="inline" set="null" expr="cast 0x400000B8" line="176" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LEFT_BRACE>
	<NUMPAD_RIGHT_BRACE public="1" get="inline" set="null" expr="cast 0x400000B9" line="177" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_RIGHT_BRACE>
	<NUMPAD_TAB public="1" get="inline" set="null" expr="cast 0x400000BA" line="178" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_TAB>
	<NUMPAD_BACKSPACE public="1" get="inline" set="null" expr="cast 0x400000BB" line="179" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BB</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_BACKSPACE>
	<NUMPAD_A public="1" get="inline" set="null" expr="cast 0x400000BC" line="180" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BC</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_A>
	<NUMPAD_B public="1" get="inline" set="null" expr="cast 0x400000BD" line="181" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BD</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_B>
	<NUMPAD_C public="1" get="inline" set="null" expr="cast 0x400000BE" line="182" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BE</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_C>
	<NUMPAD_D public="1" get="inline" set="null" expr="cast 0x400000BF" line="183" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BF</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_D>
	<NUMPAD_E public="1" get="inline" set="null" expr="cast 0x400000C0" line="184" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_E>
	<NUMPAD_F public="1" get="inline" set="null" expr="cast 0x400000C1" line="185" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_F>
	<NUMPAD_XOR public="1" get="inline" set="null" expr="cast 0x400000C2" line="186" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_XOR>
	<NUMPAD_POWER public="1" get="inline" set="null" expr="cast 0x400000C3" line="187" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_POWER>
	<NUMPAD_PERCENT public="1" get="inline" set="null" expr="cast 0x400000C4" line="188" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PERCENT>
	<NUMPAD_LESS_THAN public="1" get="inline" set="null" expr="cast 0x400000C5" line="189" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LESS_THAN>
	<NUMPAD_GREATER_THAN public="1" get="inline" set="null" expr="cast 0x400000C6" line="190" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_GREATER_THAN>
	<NUMPAD_AMPERSAND public="1" get="inline" set="null" expr="cast 0x400000C7" line="191" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_AMPERSAND>
	<NUMPAD_DOUBLE_AMPERSAND public="1" get="inline" set="null" expr="cast 0x400000C8" line="192" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DOUBLE_AMPERSAND>
	<NUMPAD_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 0x400000C9" line="193" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_VERTICAL_BAR>
	<NUMPAD_DOUBLE_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 0x400000CA" line="194" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DOUBLE_VERTICAL_BAR>
	<NUMPAD_COLON public="1" get="inline" set="null" expr="cast 0x400000CB" line="195" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CB</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_COLON>
	<NUMPAD_HASH public="1" get="inline" set="null" expr="cast 0x400000CC" line="196" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CC</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_HASH>
	<NUMPAD_SPACE public="1" get="inline" set="null" expr="cast 0x400000CD" line="197" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CD</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_SPACE>
	<NUMPAD_AT public="1" get="inline" set="null" expr="cast 0x400000CE" line="198" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CE</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_AT>
	<NUMPAD_EXCLAMATION public="1" get="inline" set="null" expr="cast 0x400000CF" line="199" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CF</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_EXCLAMATION>
	<NUMPAD_MEM_STORE public="1" get="inline" set="null" expr="cast 0x400000D0" line="200" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_STORE>
	<NUMPAD_MEM_RECALL public="1" get="inline" set="null" expr="cast 0x400000D1" line="201" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_RECALL>
	<NUMPAD_MEM_CLEAR public="1" get="inline" set="null" expr="cast 0x400000D2" line="202" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_CLEAR>
	<NUMPAD_MEM_ADD public="1" get="inline" set="null" expr="cast 0x400000D3" line="203" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_ADD>
	<NUMPAD_MEM_SUBTRACT public="1" get="inline" set="null" expr="cast 0x400000D4" line="204" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_SUBTRACT>
	<NUMPAD_MEM_MULTIPLY public="1" get="inline" set="null" expr="cast 0x400000D5" line="205" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_MULTIPLY>
	<NUMPAD_MEM_DIVIDE public="1" get="inline" set="null" expr="cast 0x400000D6" line="206" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_DIVIDE>
	<NUMPAD_PLUS_MINUS public="1" get="inline" set="null" expr="cast 0x400000D7" line="207" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PLUS_MINUS>
	<NUMPAD_CLEAR public="1" get="inline" set="null" expr="cast 0x400000D8" line="208" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_CLEAR>
	<NUMPAD_CLEAR_ENTRY public="1" get="inline" set="null" expr="cast 0x400000D9" line="209" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_CLEAR_ENTRY>
	<NUMPAD_BINARY public="1" get="inline" set="null" expr="cast 0x400000DA" line="210" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000DA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_BINARY>
	<NUMPAD_OCTAL public="1" get="inline" set="null" expr="cast 0x400000DB" line="211" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000DB</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_OCTAL>
	<NUMPAD_DECIMAL public="1" get="inline" set="null" expr="cast 0x400000DC" line="212" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000DC</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DECIMAL>
	<NUMPAD_HEXADECIMAL public="1" get="inline" set="null" expr="cast 0x400000DD" line="213" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000DD</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_HEXADECIMAL>
	<LEFT_CTRL public="1" get="inline" set="null" expr="cast 0x400000E0" line="214" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_CTRL>
	<LEFT_SHIFT public="1" get="inline" set="null" expr="cast 0x400000E1" line="215" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_SHIFT>
	<LEFT_ALT public="1" get="inline" set="null" expr="cast 0x400000E2" line="216" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_ALT>
	<LEFT_META public="1" get="inline" set="null" expr="cast 0x400000E3" line="217" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_META>
	<RIGHT_CTRL public="1" get="inline" set="null" expr="cast 0x400000E4" line="218" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_CTRL>
	<RIGHT_SHIFT public="1" get="inline" set="null" expr="cast 0x400000E5" line="219" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_SHIFT>
	<RIGHT_ALT public="1" get="inline" set="null" expr="cast 0x400000E6" line="220" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_ALT>
	<RIGHT_META public="1" get="inline" set="null" expr="cast 0x400000E7" line="221" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_META>
	<MODE public="1" get="inline" set="null" expr="cast 0x40000101" line="222" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000101</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MODE>
	<AUDIO_NEXT public="1" get="inline" set="null" expr="cast 0x40000102" line="223" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000102</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_NEXT>
	<AUDIO_PREVIOUS public="1" get="inline" set="null" expr="cast 0x40000103" line="224" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000103</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_PREVIOUS>
	<AUDIO_STOP public="1" get="inline" set="null" expr="cast 0x40000104" line="225" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000104</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_STOP>
	<AUDIO_PLAY public="1" get="inline" set="null" expr="cast 0x40000105" line="226" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000105</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_PLAY>
	<AUDIO_MUTE public="1" get="inline" set="null" expr="cast 0x40000106" line="227" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000106</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_MUTE>
	<MEDIA_SELECT public="1" get="inline" set="null" expr="cast 0x40000107" line="228" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000107</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEDIA_SELECT>
	<WWW public="1" get="inline" set="null" expr="cast 0x40000108" line="229" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000108</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WWW>
	<MAIL public="1" get="inline" set="null" expr="cast 0x40000109" line="230" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000109</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MAIL>
	<CALCULATOR public="1" get="inline" set="null" expr="cast 0x4000010A" line="231" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CALCULATOR>
	<COMPUTER public="1" get="inline" set="null" expr="cast 0x4000010B" line="232" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMPUTER>
	<APP_CONTROL_SEARCH public="1" get="inline" set="null" expr="cast 0x4000010C" line="233" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_SEARCH>
	<APP_CONTROL_HOME public="1" get="inline" set="null" expr="cast 0x4000010D" line="234" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_HOME>
	<APP_CONTROL_BACK public="1" get="inline" set="null" expr="cast 0x4000010E" line="235" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_BACK>
	<APP_CONTROL_FORWARD public="1" get="inline" set="null" expr="cast 0x4000010F" line="236" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_FORWARD>
	<APP_CONTROL_STOP public="1" get="inline" set="null" expr="cast 0x40000110" line="237" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000110</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_STOP>
	<APP_CONTROL_REFRESH public="1" get="inline" set="null" expr="cast 0x40000111" line="238" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000111</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_REFRESH>
	<APP_CONTROL_BOOKMARKS public="1" get="inline" set="null" expr="cast 0x40000112" line="239" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000112</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_BOOKMARKS>
	<BRIGHTNESS_DOWN public="1" get="inline" set="null" expr="cast 0x40000113" line="240" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000113</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRIGHTNESS_DOWN>
	<BRIGHTNESS_UP public="1" get="inline" set="null" expr="cast 0x40000114" line="241" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000114</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRIGHTNESS_UP>
	<DISPLAY_SWITCH public="1" get="inline" set="null" expr="cast 0x40000115" line="242" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000115</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DISPLAY_SWITCH>
	<BACKLIGHT_TOGGLE public="1" get="inline" set="null" expr="cast 0x40000116" line="243" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000116</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_TOGGLE>
	<BACKLIGHT_DOWN public="1" get="inline" set="null" expr="cast 0x40000117" line="244" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000117</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_DOWN>
	<BACKLIGHT_UP public="1" get="inline" set="null" expr="cast 0x40000118" line="245" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000118</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_UP>
	<EJECT public="1" get="inline" set="null" expr="cast 0x40000119" line="246" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000119</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EJECT>
	<SLEEP public="1" get="inline" set="null" expr="cast 0x4000011A" line="247" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000011A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLEEP>
	<fromScanCode public="1" set="method" line="249" static="1">
		<f a="scanCode">
			<x path="lime.ui.ScanCode"/>
			<x path="lime.ui.KeyCode"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromScanCode>
	<toScanCode set="method" line="260" static="1"><f a="keyCode">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.ScanCode"/>
</f></toScanCode>
	<gt get="inline" set="null" line="271" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.KeyCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</gt>
	<gte get="inline" set="null" line="272" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.KeyCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</gte>
	<lt get="inline" set="null" line="273" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.KeyCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</lt>
	<lte get="inline" set="null" line="274" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.KeyCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</lte>
	<plus get="inline" set="null" line="275" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="Int"/>
			<x path="lime.ui.KeyCode"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</plus>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.ui._KeyCode.KeyCode_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/KeyCode.hx" private="1" module="lime.ui.KeyCode">
		<UNKNOWN public="1" get="inline" set="null" expr="cast 0x00" line="12" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x00</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNKNOWN>
		<BACKSPACE public="1" get="inline" set="null" expr="cast 0x08" line="13" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x08</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSPACE>
		<TAB public="1" get="inline" set="null" expr="cast 0x09" line="14" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x09</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAB>
		<RETURN public="1" get="inline" set="null" expr="cast 0x0D" line="15" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x0D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RETURN>
		<ESCAPE public="1" get="inline" set="null" expr="cast 0x1B" line="16" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x1B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ESCAPE>
		<SPACE public="1" get="inline" set="null" expr="cast 0x20" line="17" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SPACE>
		<EXCLAMATION public="1" get="inline" set="null" expr="cast 0x21" line="18" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x21</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXCLAMATION>
		<QUOTE public="1" get="inline" set="null" expr="cast 0x22" line="19" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x22</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</QUOTE>
		<HASH public="1" get="inline" set="null" expr="cast 0x23" line="20" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x23</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HASH>
		<DOLLAR public="1" get="inline" set="null" expr="cast 0x24" line="21" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x24</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOLLAR>
		<PERCENT public="1" get="inline" set="null" expr="cast 0x25" line="22" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x25</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PERCENT>
		<AMPERSAND public="1" get="inline" set="null" expr="cast 0x26" line="23" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x26</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AMPERSAND>
		<SINGLE_QUOTE public="1" get="inline" set="null" expr="cast 0x27" line="24" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x27</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SINGLE_QUOTE>
		<LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x28" line="25" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x28</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_PARENTHESIS>
		<RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x29" line="26" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x29</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_PARENTHESIS>
		<ASTERISK public="1" get="inline" set="null" expr="cast 0x2A" line="27" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ASTERISK>
		<PLUS public="1" get="inline" set="null" expr="cast 0x2B" line="28" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PLUS>
		<COMMA public="1" get="inline" set="null" expr="cast 0x2C" line="29" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMMA>
		<MINUS public="1" get="inline" set="null" expr="cast 0x2D" line="30" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MINUS>
		<PERIOD public="1" get="inline" set="null" expr="cast 0x2E" line="31" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PERIOD>
		<SLASH public="1" get="inline" set="null" expr="cast 0x2F" line="32" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLASH>
		<NUMBER_0 public="1" get="inline" set="null" expr="cast 0x30" line="33" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x30</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_0>
		<NUMBER_1 public="1" get="inline" set="null" expr="cast 0x31" line="34" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x31</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_1>
		<NUMBER_2 public="1" get="inline" set="null" expr="cast 0x32" line="35" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x32</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_2>
		<NUMBER_3 public="1" get="inline" set="null" expr="cast 0x33" line="36" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x33</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_3>
		<NUMBER_4 public="1" get="inline" set="null" expr="cast 0x34" line="37" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x34</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_4>
		<NUMBER_5 public="1" get="inline" set="null" expr="cast 0x35" line="38" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x35</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_5>
		<NUMBER_6 public="1" get="inline" set="null" expr="cast 0x36" line="39" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x36</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_6>
		<NUMBER_7 public="1" get="inline" set="null" expr="cast 0x37" line="40" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x37</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_7>
		<NUMBER_8 public="1" get="inline" set="null" expr="cast 0x38" line="41" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x38</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_8>
		<NUMBER_9 public="1" get="inline" set="null" expr="cast 0x39" line="42" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x39</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_9>
		<COLON public="1" get="inline" set="null" expr="cast 0x3A" line="43" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COLON>
		<SEMICOLON public="1" get="inline" set="null" expr="cast 0x3B" line="44" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEMICOLON>
		<LESS_THAN public="1" get="inline" set="null" expr="cast 0x3C" line="45" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LESS_THAN>
		<EQUALS public="1" get="inline" set="null" expr="cast 0x3D" line="46" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EQUALS>
		<GREATER_THAN public="1" get="inline" set="null" expr="cast 0x3E" line="47" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREATER_THAN>
		<QUESTION public="1" get="inline" set="null" expr="cast 0x3F" line="48" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</QUESTION>
		<AT public="1" get="inline" set="null" expr="cast 0x40" line="49" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AT>
		<LEFT_BRACKET public="1" get="inline" set="null" expr="cast 0x5B" line="50" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_BRACKET>
		<BACKSLASH public="1" get="inline" set="null" expr="cast 0x5C" line="51" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSLASH>
		<RIGHT_BRACKET public="1" get="inline" set="null" expr="cast 0x5D" line="52" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_BRACKET>
		<CARET public="1" get="inline" set="null" expr="cast 0x5E" line="53" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CARET>
		<UNDERSCORE public="1" get="inline" set="null" expr="cast 0x5F" line="54" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNDERSCORE>
		<GRAVE public="1" get="inline" set="null" expr="cast 0x60" line="55" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x60</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRAVE>
		<A public="1" get="inline" set="null" expr="cast 0x61" line="56" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x61</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A>
		<B public="1" get="inline" set="null" expr="cast 0x62" line="57" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x62</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</B>
		<C public="1" get="inline" set="null" expr="cast 0x63" line="58" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x63</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</C>
		<D public="1" get="inline" set="null" expr="cast 0x64" line="59" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x64</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</D>
		<E public="1" get="inline" set="null" expr="cast 0x65" line="60" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x65</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</E>
		<F public="1" get="inline" set="null" expr="cast 0x66" line="61" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x66</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F>
		<G public="1" get="inline" set="null" expr="cast 0x67" line="62" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x67</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</G>
		<H public="1" get="inline" set="null" expr="cast 0x68" line="63" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x68</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</H>
		<I public="1" get="inline" set="null" expr="cast 0x69" line="64" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x69</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</I>
		<J public="1" get="inline" set="null" expr="cast 0x6A" line="65" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</J>
		<K public="1" get="inline" set="null" expr="cast 0x6B" line="66" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</K>
		<L public="1" get="inline" set="null" expr="cast 0x6C" line="67" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</L>
		<M public="1" get="inline" set="null" expr="cast 0x6D" line="68" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</M>
		<N public="1" get="inline" set="null" expr="cast 0x6E" line="69" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</N>
		<O public="1" get="inline" set="null" expr="cast 0x6F" line="70" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</O>
		<P public="1" get="inline" set="null" expr="cast 0x70" line="71" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x70</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</P>
		<Q public="1" get="inline" set="null" expr="cast 0x71" line="72" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x71</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Q>
		<R public="1" get="inline" set="null" expr="cast 0x72" line="73" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x72</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</R>
		<S public="1" get="inline" set="null" expr="cast 0x73" line="74" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x73</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</S>
		<T public="1" get="inline" set="null" expr="cast 0x74" line="75" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x74</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</T>
		<U public="1" get="inline" set="null" expr="cast 0x75" line="76" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x75</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</U>
		<V public="1" get="inline" set="null" expr="cast 0x76" line="77" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x76</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</V>
		<W public="1" get="inline" set="null" expr="cast 0x77" line="78" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x77</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</W>
		<X public="1" get="inline" set="null" expr="cast 0x78" line="79" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x78</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</X>
		<Y public="1" get="inline" set="null" expr="cast 0x79" line="80" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x79</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Y>
		<Z public="1" get="inline" set="null" expr="cast 0x7A" line="81" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x7A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Z>
		<DELETE public="1" get="inline" set="null" expr="cast 0x7F" line="82" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x7F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DELETE>
		<CAPS_LOCK public="1" get="inline" set="null" expr="cast 0x40000039" line="83" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000039</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CAPS_LOCK>
		<F1 public="1" get="inline" set="null" expr="cast 0x4000003A" line="84" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F1>
		<F2 public="1" get="inline" set="null" expr="cast 0x4000003B" line="85" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F2>
		<F3 public="1" get="inline" set="null" expr="cast 0x4000003C" line="86" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F3>
		<F4 public="1" get="inline" set="null" expr="cast 0x4000003D" line="87" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F4>
		<F5 public="1" get="inline" set="null" expr="cast 0x4000003E" line="88" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F5>
		<F6 public="1" get="inline" set="null" expr="cast 0x4000003F" line="89" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F6>
		<F7 public="1" get="inline" set="null" expr="cast 0x40000040" line="90" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000040</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F7>
		<F8 public="1" get="inline" set="null" expr="cast 0x40000041" line="91" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000041</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F8>
		<F9 public="1" get="inline" set="null" expr="cast 0x40000042" line="92" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000042</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F9>
		<F10 public="1" get="inline" set="null" expr="cast 0x40000043" line="93" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000043</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F10>
		<F11 public="1" get="inline" set="null" expr="cast 0x40000044" line="94" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000044</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F11>
		<F12 public="1" get="inline" set="null" expr="cast 0x40000045" line="95" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000045</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F12>
		<PRINT_SCREEN public="1" get="inline" set="null" expr="cast 0x40000046" line="96" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000046</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRINT_SCREEN>
		<SCROLL_LOCK public="1" get="inline" set="null" expr="cast 0x40000047" line="97" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000047</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SCROLL_LOCK>
		<PAUSE public="1" get="inline" set="null" expr="cast 0x40000048" line="98" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000048</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAUSE>
		<INSERT public="1" get="inline" set="null" expr="cast 0x40000049" line="99" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000049</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INSERT>
		<HOME public="1" get="inline" set="null" expr="cast 0x4000004A" line="100" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HOME>
		<PAGE_UP public="1" get="inline" set="null" expr="cast 0x4000004B" line="101" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGE_UP>
		<END public="1" get="inline" set="null" expr="cast 0x4000004D" line="102" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</END>
		<PAGE_DOWN public="1" get="inline" set="null" expr="cast 0x4000004E" line="103" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGE_DOWN>
		<RIGHT public="1" get="inline" set="null" expr="cast 0x4000004F" line="104" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<LEFT public="1" get="inline" set="null" expr="cast 0x40000050" line="105" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000050</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<DOWN public="1" get="inline" set="null" expr="cast 0x40000051" line="106" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000051</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOWN>
		<UP public="1" get="inline" set="null" expr="cast 0x40000052" line="107" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000052</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UP>
		<NUM_LOCK public="1" get="inline" set="null" expr="cast 0x40000053" line="108" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000053</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUM_LOCK>
		<NUMPAD_DIVIDE public="1" get="inline" set="null" expr="cast 0x40000054" line="109" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000054</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DIVIDE>
		<NUMPAD_MULTIPLY public="1" get="inline" set="null" expr="cast 0x40000055" line="110" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000055</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MULTIPLY>
		<NUMPAD_MINUS public="1" get="inline" set="null" expr="cast 0x40000056" line="111" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000056</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MINUS>
		<NUMPAD_PLUS public="1" get="inline" set="null" expr="cast 0x40000057" line="112" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000057</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PLUS>
		<NUMPAD_ENTER public="1" get="inline" set="null" expr="cast 0x40000058" line="113" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000058</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_ENTER>
		<NUMPAD_1 public="1" get="inline" set="null" expr="cast 0x40000059" line="114" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000059</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_1>
		<NUMPAD_2 public="1" get="inline" set="null" expr="cast 0x4000005A" line="115" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_2>
		<NUMPAD_3 public="1" get="inline" set="null" expr="cast 0x4000005B" line="116" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_3>
		<NUMPAD_4 public="1" get="inline" set="null" expr="cast 0x4000005C" line="117" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_4>
		<NUMPAD_5 public="1" get="inline" set="null" expr="cast 0x4000005D" line="118" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_5>
		<NUMPAD_6 public="1" get="inline" set="null" expr="cast 0x4000005E" line="119" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_6>
		<NUMPAD_7 public="1" get="inline" set="null" expr="cast 0x4000005F" line="120" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_7>
		<NUMPAD_8 public="1" get="inline" set="null" expr="cast 0x40000060" line="121" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000060</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_8>
		<NUMPAD_9 public="1" get="inline" set="null" expr="cast 0x40000061" line="122" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000061</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_9>
		<NUMPAD_0 public="1" get="inline" set="null" expr="cast 0x40000062" line="123" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000062</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_0>
		<NUMPAD_PERIOD public="1" get="inline" set="null" expr="cast 0x40000063" line="124" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000063</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PERIOD>
		<APPLICATION public="1" get="inline" set="null" expr="cast 0x40000065" line="125" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000065</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APPLICATION>
		<POWER public="1" get="inline" set="null" expr="cast 0x40000066" line="126" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000066</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</POWER>
		<NUMPAD_EQUALS public="1" get="inline" set="null" expr="cast 0x40000067" line="127" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000067</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_EQUALS>
		<F13 public="1" get="inline" set="null" expr="cast 0x40000068" line="128" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000068</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F13>
		<F14 public="1" get="inline" set="null" expr="cast 0x40000069" line="129" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000069</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F14>
		<F15 public="1" get="inline" set="null" expr="cast 0x4000006A" line="130" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F15>
		<F16 public="1" get="inline" set="null" expr="cast 0x4000006B" line="131" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F16>
		<F17 public="1" get="inline" set="null" expr="cast 0x4000006C" line="132" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F17>
		<F18 public="1" get="inline" set="null" expr="cast 0x4000006D" line="133" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F18>
		<F19 public="1" get="inline" set="null" expr="cast 0x4000006E" line="134" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F19>
		<F20 public="1" get="inline" set="null" expr="cast 0x4000006F" line="135" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F20>
		<F21 public="1" get="inline" set="null" expr="cast 0x40000070" line="136" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000070</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F21>
		<F22 public="1" get="inline" set="null" expr="cast 0x40000071" line="137" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000071</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F22>
		<F23 public="1" get="inline" set="null" expr="cast 0x40000072" line="138" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000072</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F23>
		<F24 public="1" get="inline" set="null" expr="cast 0x40000073" line="139" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000073</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F24>
		<EXECUTE public="1" get="inline" set="null" expr="cast 0x40000074" line="140" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000074</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXECUTE>
		<HELP public="1" get="inline" set="null" expr="cast 0x40000075" line="141" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000075</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HELP>
		<MENU public="1" get="inline" set="null" expr="cast 0x40000076" line="142" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000076</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MENU>
		<SELECT public="1" get="inline" set="null" expr="cast 0x40000077" line="143" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000077</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SELECT>
		<STOP public="1" get="inline" set="null" expr="cast 0x40000078" line="144" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000078</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STOP>
		<AGAIN public="1" get="inline" set="null" expr="cast 0x40000079" line="145" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000079</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AGAIN>
		<UNDO public="1" get="inline" set="null" expr="cast 0x4000007A" line="146" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNDO>
		<CUT public="1" get="inline" set="null" expr="cast 0x4000007B" line="147" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CUT>
		<COPY public="1" get="inline" set="null" expr="cast 0x4000007C" line="148" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COPY>
		<PASTE public="1" get="inline" set="null" expr="cast 0x4000007D" line="149" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PASTE>
		<FIND public="1" get="inline" set="null" expr="cast 0x4000007E" line="150" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIND>
		<MUTE public="1" get="inline" set="null" expr="cast 0x4000007F" line="151" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MUTE>
		<VOLUME_UP public="1" get="inline" set="null" expr="cast 0x40000080" line="152" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000080</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOLUME_UP>
		<VOLUME_DOWN public="1" get="inline" set="null" expr="cast 0x40000081" line="153" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000081</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOLUME_DOWN>
		<NUMPAD_COMMA public="1" get="inline" set="null" expr="cast 0x40000085" line="154" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000085</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_COMMA>
		<ALT_ERASE public="1" get="inline" set="null" expr="cast 0x40000099" line="156" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000099</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALT_ERASE>
		<SYSTEM_REQUEST public="1" get="inline" set="null" expr="cast 0x4000009A" line="157" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SYSTEM_REQUEST>
		<CANCEL public="1" get="inline" set="null" expr="cast 0x4000009B" line="158" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CANCEL>
		<CLEAR public="1" get="inline" set="null" expr="cast 0x4000009C" line="159" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLEAR>
		<PRIOR public="1" get="inline" set="null" expr="cast 0x4000009D" line="160" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRIOR>
		<RETURN2 public="1" get="inline" set="null" expr="cast 0x4000009E" line="161" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RETURN2>
		<SEPARATOR public="1" get="inline" set="null" expr="cast 0x4000009F" line="162" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEPARATOR>
		<OUT public="1" get="inline" set="null" expr="cast 0x400000A0" line="163" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OUT>
		<OPER public="1" get="inline" set="null" expr="cast 0x400000A1" line="164" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OPER>
		<CLEAR_AGAIN public="1" get="inline" set="null" expr="cast 0x400000A2" line="165" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLEAR_AGAIN>
		<CRSEL public="1" get="inline" set="null" expr="cast 0x400000A3" line="166" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CRSEL>
		<EXSEL public="1" get="inline" set="null" expr="cast 0x400000A4" line="167" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXSEL>
		<NUMPAD_00 public="1" get="inline" set="null" expr="cast 0x400000B0" line="168" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_00>
		<NUMPAD_000 public="1" get="inline" set="null" expr="cast 0x400000B1" line="169" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_000>
		<THOUSAND_SEPARATOR public="1" get="inline" set="null" expr="cast 0x400000B2" line="170" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</THOUSAND_SEPARATOR>
		<DECIMAL_SEPARATOR public="1" get="inline" set="null" expr="cast 0x400000B3" line="171" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DECIMAL_SEPARATOR>
		<CURRENCY_UNIT public="1" get="inline" set="null" expr="cast 0x400000B4" line="172" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURRENCY_UNIT>
		<CURRENCY_SUBUNIT public="1" get="inline" set="null" expr="cast 0x400000B5" line="173" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURRENCY_SUBUNIT>
		<NUMPAD_LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x400000B6" line="174" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LEFT_PARENTHESIS>
		<NUMPAD_RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x400000B7" line="175" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_RIGHT_PARENTHESIS>
		<NUMPAD_LEFT_BRACE public="1" get="inline" set="null" expr="cast 0x400000B8" line="176" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LEFT_BRACE>
		<NUMPAD_RIGHT_BRACE public="1" get="inline" set="null" expr="cast 0x400000B9" line="177" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_RIGHT_BRACE>
		<NUMPAD_TAB public="1" get="inline" set="null" expr="cast 0x400000BA" line="178" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_TAB>
		<NUMPAD_BACKSPACE public="1" get="inline" set="null" expr="cast 0x400000BB" line="179" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BB</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_BACKSPACE>
		<NUMPAD_A public="1" get="inline" set="null" expr="cast 0x400000BC" line="180" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BC</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_A>
		<NUMPAD_B public="1" get="inline" set="null" expr="cast 0x400000BD" line="181" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BD</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_B>
		<NUMPAD_C public="1" get="inline" set="null" expr="cast 0x400000BE" line="182" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BE</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_C>
		<NUMPAD_D public="1" get="inline" set="null" expr="cast 0x400000BF" line="183" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BF</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_D>
		<NUMPAD_E public="1" get="inline" set="null" expr="cast 0x400000C0" line="184" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_E>
		<NUMPAD_F public="1" get="inline" set="null" expr="cast 0x400000C1" line="185" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_F>
		<NUMPAD_XOR public="1" get="inline" set="null" expr="cast 0x400000C2" line="186" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_XOR>
		<NUMPAD_POWER public="1" get="inline" set="null" expr="cast 0x400000C3" line="187" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_POWER>
		<NUMPAD_PERCENT public="1" get="inline" set="null" expr="cast 0x400000C4" line="188" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PERCENT>
		<NUMPAD_LESS_THAN public="1" get="inline" set="null" expr="cast 0x400000C5" line="189" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LESS_THAN>
		<NUMPAD_GREATER_THAN public="1" get="inline" set="null" expr="cast 0x400000C6" line="190" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_GREATER_THAN>
		<NUMPAD_AMPERSAND public="1" get="inline" set="null" expr="cast 0x400000C7" line="191" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_AMPERSAND>
		<NUMPAD_DOUBLE_AMPERSAND public="1" get="inline" set="null" expr="cast 0x400000C8" line="192" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DOUBLE_AMPERSAND>
		<NUMPAD_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 0x400000C9" line="193" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_VERTICAL_BAR>
		<NUMPAD_DOUBLE_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 0x400000CA" line="194" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DOUBLE_VERTICAL_BAR>
		<NUMPAD_COLON public="1" get="inline" set="null" expr="cast 0x400000CB" line="195" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CB</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_COLON>
		<NUMPAD_HASH public="1" get="inline" set="null" expr="cast 0x400000CC" line="196" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CC</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_HASH>
		<NUMPAD_SPACE public="1" get="inline" set="null" expr="cast 0x400000CD" line="197" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CD</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_SPACE>
		<NUMPAD_AT public="1" get="inline" set="null" expr="cast 0x400000CE" line="198" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CE</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_AT>
		<NUMPAD_EXCLAMATION public="1" get="inline" set="null" expr="cast 0x400000CF" line="199" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CF</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_EXCLAMATION>
		<NUMPAD_MEM_STORE public="1" get="inline" set="null" expr="cast 0x400000D0" line="200" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_STORE>
		<NUMPAD_MEM_RECALL public="1" get="inline" set="null" expr="cast 0x400000D1" line="201" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_RECALL>
		<NUMPAD_MEM_CLEAR public="1" get="inline" set="null" expr="cast 0x400000D2" line="202" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_CLEAR>
		<NUMPAD_MEM_ADD public="1" get="inline" set="null" expr="cast 0x400000D3" line="203" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_ADD>
		<NUMPAD_MEM_SUBTRACT public="1" get="inline" set="null" expr="cast 0x400000D4" line="204" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_SUBTRACT>
		<NUMPAD_MEM_MULTIPLY public="1" get="inline" set="null" expr="cast 0x400000D5" line="205" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_MULTIPLY>
		<NUMPAD_MEM_DIVIDE public="1" get="inline" set="null" expr="cast 0x400000D6" line="206" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_DIVIDE>
		<NUMPAD_PLUS_MINUS public="1" get="inline" set="null" expr="cast 0x400000D7" line="207" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PLUS_MINUS>
		<NUMPAD_CLEAR public="1" get="inline" set="null" expr="cast 0x400000D8" line="208" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_CLEAR>
		<NUMPAD_CLEAR_ENTRY public="1" get="inline" set="null" expr="cast 0x400000D9" line="209" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_CLEAR_ENTRY>
		<NUMPAD_BINARY public="1" get="inline" set="null" expr="cast 0x400000DA" line="210" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000DA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_BINARY>
		<NUMPAD_OCTAL public="1" get="inline" set="null" expr="cast 0x400000DB" line="211" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000DB</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_OCTAL>
		<NUMPAD_DECIMAL public="1" get="inline" set="null" expr="cast 0x400000DC" line="212" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000DC</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DECIMAL>
		<NUMPAD_HEXADECIMAL public="1" get="inline" set="null" expr="cast 0x400000DD" line="213" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000DD</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_HEXADECIMAL>
		<LEFT_CTRL public="1" get="inline" set="null" expr="cast 0x400000E0" line="214" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_CTRL>
		<LEFT_SHIFT public="1" get="inline" set="null" expr="cast 0x400000E1" line="215" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_SHIFT>
		<LEFT_ALT public="1" get="inline" set="null" expr="cast 0x400000E2" line="216" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_ALT>
		<LEFT_META public="1" get="inline" set="null" expr="cast 0x400000E3" line="217" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_META>
		<RIGHT_CTRL public="1" get="inline" set="null" expr="cast 0x400000E4" line="218" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_CTRL>
		<RIGHT_SHIFT public="1" get="inline" set="null" expr="cast 0x400000E5" line="219" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_SHIFT>
		<RIGHT_ALT public="1" get="inline" set="null" expr="cast 0x400000E6" line="220" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_ALT>
		<RIGHT_META public="1" get="inline" set="null" expr="cast 0x400000E7" line="221" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_META>
		<MODE public="1" get="inline" set="null" expr="cast 0x40000101" line="222" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000101</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MODE>
		<AUDIO_NEXT public="1" get="inline" set="null" expr="cast 0x40000102" line="223" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000102</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_NEXT>
		<AUDIO_PREVIOUS public="1" get="inline" set="null" expr="cast 0x40000103" line="224" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000103</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_PREVIOUS>
		<AUDIO_STOP public="1" get="inline" set="null" expr="cast 0x40000104" line="225" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000104</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_STOP>
		<AUDIO_PLAY public="1" get="inline" set="null" expr="cast 0x40000105" line="226" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000105</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_PLAY>
		<AUDIO_MUTE public="1" get="inline" set="null" expr="cast 0x40000106" line="227" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000106</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_MUTE>
		<MEDIA_SELECT public="1" get="inline" set="null" expr="cast 0x40000107" line="228" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000107</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEDIA_SELECT>
		<WWW public="1" get="inline" set="null" expr="cast 0x40000108" line="229" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000108</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WWW>
		<MAIL public="1" get="inline" set="null" expr="cast 0x40000109" line="230" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000109</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MAIL>
		<CALCULATOR public="1" get="inline" set="null" expr="cast 0x4000010A" line="231" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CALCULATOR>
		<COMPUTER public="1" get="inline" set="null" expr="cast 0x4000010B" line="232" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMPUTER>
		<APP_CONTROL_SEARCH public="1" get="inline" set="null" expr="cast 0x4000010C" line="233" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_SEARCH>
		<APP_CONTROL_HOME public="1" get="inline" set="null" expr="cast 0x4000010D" line="234" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_HOME>
		<APP_CONTROL_BACK public="1" get="inline" set="null" expr="cast 0x4000010E" line="235" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_BACK>
		<APP_CONTROL_FORWARD public="1" get="inline" set="null" expr="cast 0x4000010F" line="236" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_FORWARD>
		<APP_CONTROL_STOP public="1" get="inline" set="null" expr="cast 0x40000110" line="237" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000110</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_STOP>
		<APP_CONTROL_REFRESH public="1" get="inline" set="null" expr="cast 0x40000111" line="238" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000111</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_REFRESH>
		<APP_CONTROL_BOOKMARKS public="1" get="inline" set="null" expr="cast 0x40000112" line="239" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000112</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_BOOKMARKS>
		<BRIGHTNESS_DOWN public="1" get="inline" set="null" expr="cast 0x40000113" line="240" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000113</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRIGHTNESS_DOWN>
		<BRIGHTNESS_UP public="1" get="inline" set="null" expr="cast 0x40000114" line="241" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000114</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRIGHTNESS_UP>
		<DISPLAY_SWITCH public="1" get="inline" set="null" expr="cast 0x40000115" line="242" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000115</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DISPLAY_SWITCH>
		<BACKLIGHT_TOGGLE public="1" get="inline" set="null" expr="cast 0x40000116" line="243" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000116</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_TOGGLE>
		<BACKLIGHT_DOWN public="1" get="inline" set="null" expr="cast 0x40000117" line="244" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000117</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_DOWN>
		<BACKLIGHT_UP public="1" get="inline" set="null" expr="cast 0x40000118" line="245" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000118</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_UP>
		<EJECT public="1" get="inline" set="null" expr="cast 0x40000119" line="246" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000119</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EJECT>
		<SLEEP public="1" get="inline" set="null" expr="cast 0x4000011A" line="247" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000011A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLEEP>
		<fromScanCode public="1" set="method" line="249" static="1">
			<f a="scanCode">
				<x path="lime.ui.ScanCode"/>
				<x path="lime.ui.KeyCode"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromScanCode>
		<toScanCode set="method" line="260" static="1"><f a="keyCode">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.ScanCode"/>
</f></toScanCode>
		<gt get="inline" set="null" line="271" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</gt>
		<gte get="inline" set="null" line="272" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</gte>
		<lt get="inline" set="null" line="273" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</lt>
		<lte get="inline" set="null" line="274" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</lte>
		<plus get="inline" set="null" line="275" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="Int"/>
				<x path="lime.ui.KeyCode"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</plus>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<abstract path="lime.ui.KeyModifier" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/KeyModifier.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<impl><class path="lime.ui._KeyModifier.KeyModifier_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/KeyModifier.hx" private="1" module="lime.ui.KeyModifier">
	<NONE public="1" get="inline" set="null" expr="0x0000" line="7" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0000</e></m></meta>
	</NONE>
	<LEFT_SHIFT public="1" get="inline" set="null" expr="0x0001" line="8" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0001</e></m></meta>
	</LEFT_SHIFT>
	<RIGHT_SHIFT public="1" get="inline" set="null" expr="0x0002" line="9" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0002</e></m></meta>
	</RIGHT_SHIFT>
	<LEFT_CTRL public="1" get="inline" set="null" expr="0x0040" line="10" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0040</e></m></meta>
	</LEFT_CTRL>
	<RIGHT_CTRL public="1" get="inline" set="null" expr="0x0080" line="11" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0080</e></m></meta>
	</RIGHT_CTRL>
	<LEFT_ALT public="1" get="inline" set="null" expr="0x0100" line="12" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0100</e></m></meta>
	</LEFT_ALT>
	<RIGHT_ALT public="1" get="inline" set="null" expr="0x0200" line="13" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0200</e></m></meta>
	</RIGHT_ALT>
	<LEFT_META public="1" get="inline" set="null" expr="0x0400" line="14" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0400</e></m></meta>
	</LEFT_META>
	<RIGHT_META public="1" get="inline" set="null" expr="0x0800" line="15" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0800</e></m></meta>
	</RIGHT_META>
	<NUM_LOCK public="1" get="inline" set="null" expr="0x1000" line="16" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x1000</e></m></meta>
	</NUM_LOCK>
	<CAPS_LOCK public="1" get="inline" set="null" expr="0x2000" line="17" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x2000</e></m></meta>
	</CAPS_LOCK>
	<MODE public="1" get="inline" set="null" expr="0x4000" line="18" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x4000</e></m></meta>
	</MODE>
	<CTRL public="1" get="inline" set="null" expr="(0x0040 | 0x0080)" line="20" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>(0x0040 | 0x0080)</e></m></meta>
	</CTRL>
	<SHIFT public="1" get="inline" set="null" expr="(0x001 | 0x0002)" line="21" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>(0x001 | 0x0002)</e></m></meta>
	</SHIFT>
	<ALT public="1" get="inline" set="null" expr="(0x0100 | 0x0200)" line="22" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>(0x0100 | 0x0200)</e></m></meta>
	</ALT>
	<META public="1" get="inline" set="null" expr="(0x0400 | 0x0800)" line="23" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>(0x0400 | 0x0800)</e></m></meta>
	</META>
	<altKey public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</altKey>
	<capsLock public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</capsLock>
	<ctrlKey public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</ctrlKey>
	<metaKey public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</metaKey>
	<numLock public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</numLock>
	<shiftKey public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</shiftKey>
	<get_altKey set="method" line="33" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_altKey>
	<set_altKey get="inline" set="null" line="40" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_altKey>
	<get_capsLock set="method" line="57" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_capsLock>
	<set_capsLock get="inline" set="null" line="64" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_capsLock>
	<get_ctrlKey set="method" line="81" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_ctrlKey>
	<set_ctrlKey get="inline" set="null" line="88" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_ctrlKey>
	<get_metaKey set="method" line="105" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_metaKey>
	<set_metaKey get="inline" set="null" line="112" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_metaKey>
	<get_numLock set="method" line="129" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_numLock>
	<set_numLock get="inline" set="null" line="136" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_numLock>
	<get_shiftKey set="method" line="153" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_shiftKey>
	<set_shiftKey get="inline" set="null" line="160" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_shiftKey>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.ui._KeyModifier.KeyModifier_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/KeyModifier.hx" private="1" module="lime.ui.KeyModifier">
		<NONE public="1" get="inline" set="null" expr="0x0000" line="7" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0000</e></m></meta>
		</NONE>
		<LEFT_SHIFT public="1" get="inline" set="null" expr="0x0001" line="8" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</LEFT_SHIFT>
		<RIGHT_SHIFT public="1" get="inline" set="null" expr="0x0002" line="9" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</RIGHT_SHIFT>
		<LEFT_CTRL public="1" get="inline" set="null" expr="0x0040" line="10" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0040</e></m></meta>
		</LEFT_CTRL>
		<RIGHT_CTRL public="1" get="inline" set="null" expr="0x0080" line="11" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0080</e></m></meta>
		</RIGHT_CTRL>
		<LEFT_ALT public="1" get="inline" set="null" expr="0x0100" line="12" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0100</e></m></meta>
		</LEFT_ALT>
		<RIGHT_ALT public="1" get="inline" set="null" expr="0x0200" line="13" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0200</e></m></meta>
		</RIGHT_ALT>
		<LEFT_META public="1" get="inline" set="null" expr="0x0400" line="14" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0400</e></m></meta>
		</LEFT_META>
		<RIGHT_META public="1" get="inline" set="null" expr="0x0800" line="15" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0800</e></m></meta>
		</RIGHT_META>
		<NUM_LOCK public="1" get="inline" set="null" expr="0x1000" line="16" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x1000</e></m></meta>
		</NUM_LOCK>
		<CAPS_LOCK public="1" get="inline" set="null" expr="0x2000" line="17" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x2000</e></m></meta>
		</CAPS_LOCK>
		<MODE public="1" get="inline" set="null" expr="0x4000" line="18" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x4000</e></m></meta>
		</MODE>
		<CTRL public="1" get="inline" set="null" expr="(0x0040 | 0x0080)" line="20" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>(0x0040 | 0x0080)</e></m></meta>
		</CTRL>
		<SHIFT public="1" get="inline" set="null" expr="(0x001 | 0x0002)" line="21" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>(0x001 | 0x0002)</e></m></meta>
		</SHIFT>
		<ALT public="1" get="inline" set="null" expr="(0x0100 | 0x0200)" line="22" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>(0x0100 | 0x0200)</e></m></meta>
		</ALT>
		<META public="1" get="inline" set="null" expr="(0x0400 | 0x0800)" line="23" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>(0x0400 | 0x0800)</e></m></meta>
		</META>
		<altKey public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</altKey>
		<capsLock public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</capsLock>
		<ctrlKey public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</ctrlKey>
		<metaKey public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</metaKey>
		<numLock public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</numLock>
		<shiftKey public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</shiftKey>
		<get_altKey set="method" line="33" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_altKey>
		<set_altKey get="inline" set="null" line="40" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_altKey>
		<get_capsLock set="method" line="57" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_capsLock>
		<set_capsLock get="inline" set="null" line="64" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_capsLock>
		<get_ctrlKey set="method" line="81" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_ctrlKey>
		<set_ctrlKey get="inline" set="null" line="88" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_ctrlKey>
		<get_metaKey set="method" line="105" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_metaKey>
		<set_metaKey get="inline" set="null" line="112" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_metaKey>
		<get_numLock set="method" line="129" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_numLock>
		<set_numLock get="inline" set="null" line="136" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_numLock>
		<get_shiftKey set="method" line="153" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_shiftKey>
		<set_shiftKey get="inline" set="null" line="160" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_shiftKey>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.ui.MouseButton" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/MouseButton.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._MouseButton.MouseButton_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/MouseButton.hx" private="1" module="lime.ui.MouseButton" extern="1">
	<LEFT public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
		<x path="lime.ui.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<MIDDLE public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
		<x path="lime.ui.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MIDDLE>
	<RIGHT public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
		<x path="lime.ui.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.ui._MouseButton.MouseButton_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/MouseButton.hx" private="1" module="lime.ui.MouseButton" extern="1">
		<LEFT public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
			<x path="lime.ui.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<MIDDLE public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
			<x path="lime.ui.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MIDDLE>
		<RIGHT public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
			<x path="lime.ui.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<enum path="lime.ui.MouseCursor" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/MouseCursor.hx">
		<ARROW/>
		<CROSSHAIR/>
		<DEFAULT/>
		<MOVE/>
		<POINTER/>
		<RESIZE_NESW/>
		<RESIZE_NS/>
		<RESIZE_NWSE/>
		<RESIZE_WE/>
		<TEXT/>
		<WAIT/>
		<WAIT_ARROW/>
		<CUSTOM/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="lime.ui.MouseWheelMode" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/MouseWheelMode.hx">
		<PIXELS/>
		<LINES/>
		<PAGES/>
		<UNKNOWN/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="lime.ui.ScanCode" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/ScanCode.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
			<icast field="fromKeyCode"><x path="lime.ui.KeyCode"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.ui.KeyCode</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="lime.ui._ScanCode.ScanCode_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/ScanCode.hx" private="1" module="lime.ui.ScanCode">
	<UNKNOWN public="1" get="inline" set="null" expr="cast 0" line="13" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNKNOWN>
	<BACKSPACE public="1" get="inline" set="null" expr="cast 42" line="14" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 42</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSPACE>
	<TAB public="1" get="inline" set="null" expr="cast 43" line="15" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 43</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAB>
	<RETURN public="1" get="inline" set="null" expr="cast 40" line="16" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 40</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RETURN>
	<ESCAPE public="1" get="inline" set="null" expr="cast 41" line="17" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 41</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ESCAPE>
	<SPACE public="1" get="inline" set="null" expr="cast 44" line="18" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 44</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SPACE>
	<SINGLE_QUOTE public="1" get="inline" set="null" expr="cast 52" line="25" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 52</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SINGLE_QUOTE>
	<COMMA public="1" get="inline" set="null" expr="cast 54" line="30" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 54</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMMA>
	<MINUS public="1" get="inline" set="null" expr="cast 45" line="31" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 45</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MINUS>
	<PERIOD public="1" get="inline" set="null" expr="cast 55" line="32" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 55</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PERIOD>
	<SLASH public="1" get="inline" set="null" expr="cast 56" line="33" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 56</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLASH>
	<NUMBER_0 public="1" get="inline" set="null" expr="cast 39" line="34" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 39</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_0>
	<NUMBER_1 public="1" get="inline" set="null" expr="cast 30" line="35" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 30</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_1>
	<NUMBER_2 public="1" get="inline" set="null" expr="cast 31" line="36" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 31</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_2>
	<NUMBER_3 public="1" get="inline" set="null" expr="cast 32" line="37" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 32</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_3>
	<NUMBER_4 public="1" get="inline" set="null" expr="cast 33" line="38" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 33</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_4>
	<NUMBER_5 public="1" get="inline" set="null" expr="cast 34" line="39" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 34</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_5>
	<NUMBER_6 public="1" get="inline" set="null" expr="cast 35" line="40" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 35</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_6>
	<NUMBER_7 public="1" get="inline" set="null" expr="cast 36" line="41" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 36</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_7>
	<NUMBER_8 public="1" get="inline" set="null" expr="cast 37" line="42" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 37</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_8>
	<NUMBER_9 public="1" get="inline" set="null" expr="cast 38" line="43" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 38</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_9>
	<SEMICOLON public="1" get="inline" set="null" expr="cast 51" line="45" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 51</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEMICOLON>
	<EQUALS public="1" get="inline" set="null" expr="cast 46" line="47" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 46</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EQUALS>
	<LEFT_BRACKET public="1" get="inline" set="null" expr="cast 47" line="51" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 47</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_BRACKET>
	<BACKSLASH public="1" get="inline" set="null" expr="cast 49" line="52" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 49</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSLASH>
	<RIGHT_BRACKET public="1" get="inline" set="null" expr="cast 48" line="53" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 48</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_BRACKET>
	<GRAVE public="1" get="inline" set="null" expr="cast 53" line="56" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 53</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRAVE>
	<A public="1" get="inline" set="null" expr="cast 4" line="57" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A>
	<B public="1" get="inline" set="null" expr="cast 5" line="58" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</B>
	<C public="1" get="inline" set="null" expr="cast 6" line="59" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</C>
	<D public="1" get="inline" set="null" expr="cast 7" line="60" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</D>
	<E public="1" get="inline" set="null" expr="cast 8" line="61" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</E>
	<F public="1" get="inline" set="null" expr="cast 9" line="62" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F>
	<G public="1" get="inline" set="null" expr="cast 10" line="63" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</G>
	<H public="1" get="inline" set="null" expr="cast 11" line="64" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</H>
	<I public="1" get="inline" set="null" expr="cast 12" line="65" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</I>
	<J public="1" get="inline" set="null" expr="cast 13" line="66" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</J>
	<K public="1" get="inline" set="null" expr="cast 14" line="67" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</K>
	<L public="1" get="inline" set="null" expr="cast 15" line="68" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</L>
	<M public="1" get="inline" set="null" expr="cast 16" line="69" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</M>
	<N public="1" get="inline" set="null" expr="cast 17" line="70" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 17</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</N>
	<O public="1" get="inline" set="null" expr="cast 18" line="71" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 18</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</O>
	<P public="1" get="inline" set="null" expr="cast 19" line="72" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 19</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</P>
	<Q public="1" get="inline" set="null" expr="cast 20" line="73" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Q>
	<R public="1" get="inline" set="null" expr="cast 21" line="74" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 21</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</R>
	<S public="1" get="inline" set="null" expr="cast 22" line="75" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 22</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</S>
	<T public="1" get="inline" set="null" expr="cast 23" line="76" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 23</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</T>
	<U public="1" get="inline" set="null" expr="cast 24" line="77" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 24</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</U>
	<V public="1" get="inline" set="null" expr="cast 25" line="78" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 25</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</V>
	<W public="1" get="inline" set="null" expr="cast 26" line="79" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 26</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</W>
	<X public="1" get="inline" set="null" expr="cast 27" line="80" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 27</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</X>
	<Y public="1" get="inline" set="null" expr="cast 28" line="81" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 28</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Y>
	<Z public="1" get="inline" set="null" expr="cast 29" line="82" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 29</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Z>
	<DELETE public="1" get="inline" set="null" expr="cast 76" line="83" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 76</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DELETE>
	<CAPS_LOCK public="1" get="inline" set="null" expr="cast 57" line="84" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 57</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CAPS_LOCK>
	<F1 public="1" get="inline" set="null" expr="cast 58" line="85" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 58</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F1>
	<F2 public="1" get="inline" set="null" expr="cast 59" line="86" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 59</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F2>
	<F3 public="1" get="inline" set="null" expr="cast 60" line="87" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 60</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F3>
	<F4 public="1" get="inline" set="null" expr="cast 61" line="88" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 61</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F4>
	<F5 public="1" get="inline" set="null" expr="cast 62" line="89" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 62</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F5>
	<F6 public="1" get="inline" set="null" expr="cast 63" line="90" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 63</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F6>
	<F7 public="1" get="inline" set="null" expr="cast 64" line="91" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 64</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F7>
	<F8 public="1" get="inline" set="null" expr="cast 65" line="92" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 65</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F8>
	<F9 public="1" get="inline" set="null" expr="cast 66" line="93" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 66</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F9>
	<F10 public="1" get="inline" set="null" expr="cast 67" line="94" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 67</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F10>
	<F11 public="1" get="inline" set="null" expr="cast 68" line="95" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 68</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F11>
	<F12 public="1" get="inline" set="null" expr="cast 69" line="96" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 69</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F12>
	<PRINT_SCREEN public="1" get="inline" set="null" expr="cast 70" line="97" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 70</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRINT_SCREEN>
	<SCROLL_LOCK public="1" get="inline" set="null" expr="cast 71" line="98" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 71</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SCROLL_LOCK>
	<PAUSE public="1" get="inline" set="null" expr="cast 72" line="99" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 72</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAUSE>
	<INSERT public="1" get="inline" set="null" expr="cast 73" line="100" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 73</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INSERT>
	<HOME public="1" get="inline" set="null" expr="cast 74" line="101" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 74</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HOME>
	<PAGE_UP public="1" get="inline" set="null" expr="cast 75" line="102" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 75</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGE_UP>
	<END public="1" get="inline" set="null" expr="cast 77" line="103" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 77</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</END>
	<PAGE_DOWN public="1" get="inline" set="null" expr="cast 78" line="104" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 78</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGE_DOWN>
	<RIGHT public="1" get="inline" set="null" expr="cast 79" line="105" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 79</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<LEFT public="1" get="inline" set="null" expr="cast 80" line="106" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 80</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<DOWN public="1" get="inline" set="null" expr="cast 81" line="107" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 81</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOWN>
	<UP public="1" get="inline" set="null" expr="cast 82" line="108" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 82</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UP>
	<NUM_LOCK public="1" get="inline" set="null" expr="cast 83" line="109" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 83</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUM_LOCK>
	<NUMPAD_DIVIDE public="1" get="inline" set="null" expr="cast 84" line="110" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 84</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DIVIDE>
	<NUMPAD_MULTIPLY public="1" get="inline" set="null" expr="cast 85" line="111" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 85</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MULTIPLY>
	<NUMPAD_MINUS public="1" get="inline" set="null" expr="cast 86" line="112" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 86</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MINUS>
	<NUMPAD_PLUS public="1" get="inline" set="null" expr="cast 87" line="113" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 87</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PLUS>
	<NUMPAD_ENTER public="1" get="inline" set="null" expr="cast 88" line="114" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 88</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_ENTER>
	<NUMPAD_1 public="1" get="inline" set="null" expr="cast 89" line="115" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 89</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_1>
	<NUMPAD_2 public="1" get="inline" set="null" expr="cast 90" line="116" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 90</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_2>
	<NUMPAD_3 public="1" get="inline" set="null" expr="cast 91" line="117" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 91</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_3>
	<NUMPAD_4 public="1" get="inline" set="null" expr="cast 92" line="118" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 92</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_4>
	<NUMPAD_5 public="1" get="inline" set="null" expr="cast 93" line="119" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 93</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_5>
	<NUMPAD_6 public="1" get="inline" set="null" expr="cast 94" line="120" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 94</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_6>
	<NUMPAD_7 public="1" get="inline" set="null" expr="cast 95" line="121" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 95</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_7>
	<NUMPAD_8 public="1" get="inline" set="null" expr="cast 96" line="122" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 96</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_8>
	<NUMPAD_9 public="1" get="inline" set="null" expr="cast 97" line="123" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 97</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_9>
	<NUMPAD_0 public="1" get="inline" set="null" expr="cast 98" line="124" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 98</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_0>
	<NUMPAD_PERIOD public="1" get="inline" set="null" expr="cast 99" line="125" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 99</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PERIOD>
	<APPLICATION public="1" get="inline" set="null" expr="cast 101" line="126" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 101</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APPLICATION>
	<POWER public="1" get="inline" set="null" expr="cast 102" line="127" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 102</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</POWER>
	<NUMPAD_EQUALS public="1" get="inline" set="null" expr="cast 103" line="128" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 103</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_EQUALS>
	<F13 public="1" get="inline" set="null" expr="cast 104" line="129" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 104</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F13>
	<F14 public="1" get="inline" set="null" expr="cast 105" line="130" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 105</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F14>
	<F15 public="1" get="inline" set="null" expr="cast 106" line="131" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 106</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F15>
	<F16 public="1" get="inline" set="null" expr="cast 107" line="132" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 107</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F16>
	<F17 public="1" get="inline" set="null" expr="cast 108" line="133" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 108</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F17>
	<F18 public="1" get="inline" set="null" expr="cast 109" line="134" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 109</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F18>
	<F19 public="1" get="inline" set="null" expr="cast 110" line="135" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 110</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F19>
	<F20 public="1" get="inline" set="null" expr="cast 111" line="136" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 111</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F20>
	<F21 public="1" get="inline" set="null" expr="cast 112" line="137" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 112</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F21>
	<F22 public="1" get="inline" set="null" expr="cast 113" line="138" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 113</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F22>
	<F23 public="1" get="inline" set="null" expr="cast 114" line="139" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 114</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F23>
	<F24 public="1" get="inline" set="null" expr="cast 115" line="140" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 115</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F24>
	<EXECUTE public="1" get="inline" set="null" expr="cast 116" line="141" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 116</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXECUTE>
	<HELP public="1" get="inline" set="null" expr="cast 117" line="142" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 117</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HELP>
	<MENU public="1" get="inline" set="null" expr="cast 118" line="143" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 118</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MENU>
	<SELECT public="1" get="inline" set="null" expr="cast 119" line="144" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 119</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SELECT>
	<STOP public="1" get="inline" set="null" expr="cast 120" line="145" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 120</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STOP>
	<AGAIN public="1" get="inline" set="null" expr="cast 121" line="146" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 121</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AGAIN>
	<UNDO public="1" get="inline" set="null" expr="cast 122" line="147" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 122</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNDO>
	<CUT public="1" get="inline" set="null" expr="cast 123" line="148" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 123</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CUT>
	<COPY public="1" get="inline" set="null" expr="cast 124" line="149" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 124</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COPY>
	<PASTE public="1" get="inline" set="null" expr="cast 125" line="150" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 125</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PASTE>
	<FIND public="1" get="inline" set="null" expr="cast 126" line="151" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 126</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIND>
	<MUTE public="1" get="inline" set="null" expr="cast 127" line="152" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 127</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MUTE>
	<VOLUME_UP public="1" get="inline" set="null" expr="cast 128" line="153" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 128</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOLUME_UP>
	<VOLUME_DOWN public="1" get="inline" set="null" expr="cast 129" line="154" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 129</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOLUME_DOWN>
	<NUMPAD_COMMA public="1" get="inline" set="null" expr="cast 133" line="155" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 133</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_COMMA>
	<ALT_ERASE public="1" get="inline" set="null" expr="cast 153" line="157" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 153</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALT_ERASE>
	<SYSTEM_REQUEST public="1" get="inline" set="null" expr="cast 154" line="158" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 154</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SYSTEM_REQUEST>
	<CANCEL public="1" get="inline" set="null" expr="cast 155" line="159" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 155</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CANCEL>
	<CLEAR public="1" get="inline" set="null" expr="cast 156" line="160" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 156</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLEAR>
	<PRIOR public="1" get="inline" set="null" expr="cast 157" line="161" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 157</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRIOR>
	<RETURN2 public="1" get="inline" set="null" expr="cast 158" line="162" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 158</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RETURN2>
	<SEPARATOR public="1" get="inline" set="null" expr="cast 159" line="163" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 159</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEPARATOR>
	<OUT public="1" get="inline" set="null" expr="cast 160" line="164" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 160</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OUT>
	<OPER public="1" get="inline" set="null" expr="cast 161" line="165" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 161</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OPER>
	<CLEAR_AGAIN public="1" get="inline" set="null" expr="cast 162" line="166" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 162</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLEAR_AGAIN>
	<CRSEL public="1" get="inline" set="null" expr="cast 163" line="167" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 163</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CRSEL>
	<EXSEL public="1" get="inline" set="null" expr="cast 164" line="168" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 164</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXSEL>
	<NUMPAD_00 public="1" get="inline" set="null" expr="cast 176" line="169" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 176</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_00>
	<NUMPAD_000 public="1" get="inline" set="null" expr="cast 177" line="170" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 177</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_000>
	<THOUSAND_SEPARATOR public="1" get="inline" set="null" expr="cast 178" line="171" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 178</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</THOUSAND_SEPARATOR>
	<DECIMAL_SEPARATOR public="1" get="inline" set="null" expr="cast 179" line="172" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 179</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DECIMAL_SEPARATOR>
	<CURRENCY_UNIT public="1" get="inline" set="null" expr="cast 180" line="173" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 180</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURRENCY_UNIT>
	<CURRENCY_SUBUNIT public="1" get="inline" set="null" expr="cast 181" line="174" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 181</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURRENCY_SUBUNIT>
	<NUMPAD_LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 182" line="175" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 182</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LEFT_PARENTHESIS>
	<NUMPAD_RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 183" line="176" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 183</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_RIGHT_PARENTHESIS>
	<NUMPAD_LEFT_BRACE public="1" get="inline" set="null" expr="cast 184" line="177" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 184</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LEFT_BRACE>
	<NUMPAD_RIGHT_BRACE public="1" get="inline" set="null" expr="cast 185" line="178" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 185</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_RIGHT_BRACE>
	<NUMPAD_TAB public="1" get="inline" set="null" expr="cast 186" line="179" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 186</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_TAB>
	<NUMPAD_BACKSPACE public="1" get="inline" set="null" expr="cast 187" line="180" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 187</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_BACKSPACE>
	<NUMPAD_A public="1" get="inline" set="null" expr="cast 188" line="181" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 188</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_A>
	<NUMPAD_B public="1" get="inline" set="null" expr="cast 189" line="182" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 189</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_B>
	<NUMPAD_C public="1" get="inline" set="null" expr="cast 190" line="183" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 190</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_C>
	<NUMPAD_D public="1" get="inline" set="null" expr="cast 191" line="184" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 191</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_D>
	<NUMPAD_E public="1" get="inline" set="null" expr="cast 192" line="185" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 192</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_E>
	<NUMPAD_F public="1" get="inline" set="null" expr="cast 193" line="186" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 193</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_F>
	<NUMPAD_XOR public="1" get="inline" set="null" expr="cast 194" line="187" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 194</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_XOR>
	<NUMPAD_POWER public="1" get="inline" set="null" expr="cast 195" line="188" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 195</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_POWER>
	<NUMPAD_PERCENT public="1" get="inline" set="null" expr="cast 196" line="189" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 196</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PERCENT>
	<NUMPAD_LESS_THAN public="1" get="inline" set="null" expr="cast 197" line="190" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 197</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LESS_THAN>
	<NUMPAD_GREATER_THAN public="1" get="inline" set="null" expr="cast 198" line="191" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 198</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_GREATER_THAN>
	<NUMPAD_AMPERSAND public="1" get="inline" set="null" expr="cast 199" line="192" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 199</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_AMPERSAND>
	<NUMPAD_DOUBLE_AMPERSAND public="1" get="inline" set="null" expr="cast 200" line="193" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 200</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DOUBLE_AMPERSAND>
	<NUMPAD_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 201" line="194" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 201</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_VERTICAL_BAR>
	<NUMPAD_DOUBLE_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 202" line="195" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 202</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DOUBLE_VERTICAL_BAR>
	<NUMPAD_COLON public="1" get="inline" set="null" expr="cast 203" line="196" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 203</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_COLON>
	<NUMPAD_HASH public="1" get="inline" set="null" expr="cast 204" line="197" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 204</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_HASH>
	<NUMPAD_SPACE public="1" get="inline" set="null" expr="cast 205" line="198" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 205</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_SPACE>
	<NUMPAD_AT public="1" get="inline" set="null" expr="cast 206" line="199" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 206</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_AT>
	<NUMPAD_EXCLAMATION public="1" get="inline" set="null" expr="cast 207" line="200" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 207</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_EXCLAMATION>
	<NUMPAD_MEM_STORE public="1" get="inline" set="null" expr="cast 208" line="201" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 208</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_STORE>
	<NUMPAD_MEM_RECALL public="1" get="inline" set="null" expr="cast 209" line="202" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 209</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_RECALL>
	<NUMPAD_MEM_CLEAR public="1" get="inline" set="null" expr="cast 210" line="203" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 210</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_CLEAR>
	<NUMPAD_MEM_ADD public="1" get="inline" set="null" expr="cast 211" line="204" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 211</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_ADD>
	<NUMPAD_MEM_SUBTRACT public="1" get="inline" set="null" expr="cast 212" line="205" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 212</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_SUBTRACT>
	<NUMPAD_MEM_MULTIPLY public="1" get="inline" set="null" expr="cast 213" line="206" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 213</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_MULTIPLY>
	<NUMPAD_MEM_DIVIDE public="1" get="inline" set="null" expr="cast 214" line="207" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 214</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_DIVIDE>
	<NUMPAD_PLUS_MINUS public="1" get="inline" set="null" expr="cast 215" line="208" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 215</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PLUS_MINUS>
	<NUMPAD_CLEAR public="1" get="inline" set="null" expr="cast 216" line="209" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 216</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_CLEAR>
	<NUMPAD_CLEAR_ENTRY public="1" get="inline" set="null" expr="cast 217" line="210" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 217</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_CLEAR_ENTRY>
	<NUMPAD_BINARY public="1" get="inline" set="null" expr="cast 218" line="211" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 218</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_BINARY>
	<NUMPAD_OCTAL public="1" get="inline" set="null" expr="cast 219" line="212" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 219</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_OCTAL>
	<NUMPAD_DECIMAL public="1" get="inline" set="null" expr="cast 220" line="213" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 220</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DECIMAL>
	<NUMPAD_HEXADECIMAL public="1" get="inline" set="null" expr="cast 221" line="214" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 221</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_HEXADECIMAL>
	<LEFT_CTRL public="1" get="inline" set="null" expr="cast 224" line="215" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 224</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_CTRL>
	<LEFT_SHIFT public="1" get="inline" set="null" expr="cast 225" line="216" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 225</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_SHIFT>
	<LEFT_ALT public="1" get="inline" set="null" expr="cast 226" line="217" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 226</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_ALT>
	<LEFT_META public="1" get="inline" set="null" expr="cast 227" line="218" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 227</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_META>
	<RIGHT_CTRL public="1" get="inline" set="null" expr="cast 228" line="219" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 228</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_CTRL>
	<RIGHT_SHIFT public="1" get="inline" set="null" expr="cast 229" line="220" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 229</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_SHIFT>
	<RIGHT_ALT public="1" get="inline" set="null" expr="cast 230" line="221" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 230</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_ALT>
	<RIGHT_META public="1" get="inline" set="null" expr="cast 231" line="222" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 231</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_META>
	<MODE public="1" get="inline" set="null" expr="cast 257" line="223" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 257</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MODE>
	<AUDIO_NEXT public="1" get="inline" set="null" expr="cast 258" line="224" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 258</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_NEXT>
	<AUDIO_PREVIOUS public="1" get="inline" set="null" expr="cast 259" line="225" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 259</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_PREVIOUS>
	<AUDIO_STOP public="1" get="inline" set="null" expr="cast 260" line="226" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 260</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_STOP>
	<AUDIO_PLAY public="1" get="inline" set="null" expr="cast 261" line="227" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 261</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_PLAY>
	<AUDIO_MUTE public="1" get="inline" set="null" expr="cast 262" line="228" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 262</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_MUTE>
	<MEDIA_SELECT public="1" get="inline" set="null" expr="cast 263" line="229" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 263</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEDIA_SELECT>
	<WWW public="1" get="inline" set="null" expr="cast 264" line="230" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 264</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WWW>
	<MAIL public="1" get="inline" set="null" expr="cast 265" line="231" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 265</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MAIL>
	<CALCULATOR public="1" get="inline" set="null" expr="cast 266" line="232" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 266</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CALCULATOR>
	<COMPUTER public="1" get="inline" set="null" expr="cast 267" line="233" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 267</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMPUTER>
	<APP_CONTROL_SEARCH public="1" get="inline" set="null" expr="cast 268" line="234" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 268</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_SEARCH>
	<APP_CONTROL_HOME public="1" get="inline" set="null" expr="cast 269" line="235" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 269</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_HOME>
	<APP_CONTROL_BACK public="1" get="inline" set="null" expr="cast 270" line="236" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 270</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_BACK>
	<APP_CONTROL_FORWARD public="1" get="inline" set="null" expr="cast 271" line="237" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 271</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_FORWARD>
	<APP_CONTROL_STOP public="1" get="inline" set="null" expr="cast 272" line="238" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 272</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_STOP>
	<APP_CONTROL_REFRESH public="1" get="inline" set="null" expr="cast 273" line="239" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 273</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_REFRESH>
	<APP_CONTROL_BOOKMARKS public="1" get="inline" set="null" expr="cast 274" line="240" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 274</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_BOOKMARKS>
	<BRIGHTNESS_DOWN public="1" get="inline" set="null" expr="cast 275" line="241" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 275</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRIGHTNESS_DOWN>
	<BRIGHTNESS_UP public="1" get="inline" set="null" expr="cast 276" line="242" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 276</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRIGHTNESS_UP>
	<DISPLAY_SWITCH public="1" get="inline" set="null" expr="cast 277" line="243" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 277</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DISPLAY_SWITCH>
	<BACKLIGHT_TOGGLE public="1" get="inline" set="null" expr="cast 278" line="244" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 278</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_TOGGLE>
	<BACKLIGHT_DOWN public="1" get="inline" set="null" expr="cast 279" line="245" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 279</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_DOWN>
	<BACKLIGHT_UP public="1" get="inline" set="null" expr="cast 280" line="246" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 280</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_UP>
	<EJECT public="1" get="inline" set="null" expr="cast 281" line="247" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 281</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EJECT>
	<SLEEP public="1" get="inline" set="null" expr="cast 282" line="248" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 282</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLEEP>
	<fromKeyCode public="1" set="method" line="250" static="1">
		<f a="keyCode">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.ScanCode"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromKeyCode>
	<toKeyCode set="method" line="256" static="1"><f a="scanCode">
	<x path="lime.ui.ScanCode"/>
	<x path="lime.ui.KeyCode"/>
</f></toKeyCode>
	<gt get="inline" set="null" line="262" static="1">
		<f a="a:b">
			<x path="lime.ui.ScanCode"/>
			<x path="lime.ui.ScanCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</gt>
	<gte get="inline" set="null" line="263" static="1">
		<f a="a:b">
			<x path="lime.ui.ScanCode"/>
			<x path="lime.ui.ScanCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</gte>
	<lt get="inline" set="null" line="264" static="1">
		<f a="a:b">
			<x path="lime.ui.ScanCode"/>
			<x path="lime.ui.ScanCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</lt>
	<lte get="inline" set="null" line="265" static="1">
		<f a="a:b">
			<x path="lime.ui.ScanCode"/>
			<x path="lime.ui.ScanCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</lte>
	<plus get="inline" set="null" line="266" static="1">
		<f a="a:b">
			<x path="lime.ui.ScanCode"/>
			<x path="Int"/>
			<x path="lime.ui.ScanCode"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</plus>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":access"><e>lime.ui.KeyCode</e></m>
		<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.ui._ScanCode.ScanCode_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/ScanCode.hx" private="1" module="lime.ui.ScanCode">
		<UNKNOWN public="1" get="inline" set="null" expr="cast 0" line="13" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNKNOWN>
		<BACKSPACE public="1" get="inline" set="null" expr="cast 42" line="14" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 42</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSPACE>
		<TAB public="1" get="inline" set="null" expr="cast 43" line="15" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 43</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAB>
		<RETURN public="1" get="inline" set="null" expr="cast 40" line="16" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 40</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RETURN>
		<ESCAPE public="1" get="inline" set="null" expr="cast 41" line="17" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 41</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ESCAPE>
		<SPACE public="1" get="inline" set="null" expr="cast 44" line="18" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 44</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SPACE>
		<SINGLE_QUOTE public="1" get="inline" set="null" expr="cast 52" line="25" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 52</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SINGLE_QUOTE>
		<COMMA public="1" get="inline" set="null" expr="cast 54" line="30" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 54</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMMA>
		<MINUS public="1" get="inline" set="null" expr="cast 45" line="31" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 45</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MINUS>
		<PERIOD public="1" get="inline" set="null" expr="cast 55" line="32" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 55</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PERIOD>
		<SLASH public="1" get="inline" set="null" expr="cast 56" line="33" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 56</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLASH>
		<NUMBER_0 public="1" get="inline" set="null" expr="cast 39" line="34" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 39</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_0>
		<NUMBER_1 public="1" get="inline" set="null" expr="cast 30" line="35" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 30</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_1>
		<NUMBER_2 public="1" get="inline" set="null" expr="cast 31" line="36" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 31</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_2>
		<NUMBER_3 public="1" get="inline" set="null" expr="cast 32" line="37" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 32</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_3>
		<NUMBER_4 public="1" get="inline" set="null" expr="cast 33" line="38" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 33</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_4>
		<NUMBER_5 public="1" get="inline" set="null" expr="cast 34" line="39" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 34</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_5>
		<NUMBER_6 public="1" get="inline" set="null" expr="cast 35" line="40" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 35</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_6>
		<NUMBER_7 public="1" get="inline" set="null" expr="cast 36" line="41" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 36</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_7>
		<NUMBER_8 public="1" get="inline" set="null" expr="cast 37" line="42" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 37</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_8>
		<NUMBER_9 public="1" get="inline" set="null" expr="cast 38" line="43" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 38</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_9>
		<SEMICOLON public="1" get="inline" set="null" expr="cast 51" line="45" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 51</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEMICOLON>
		<EQUALS public="1" get="inline" set="null" expr="cast 46" line="47" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 46</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EQUALS>
		<LEFT_BRACKET public="1" get="inline" set="null" expr="cast 47" line="51" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 47</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_BRACKET>
		<BACKSLASH public="1" get="inline" set="null" expr="cast 49" line="52" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 49</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSLASH>
		<RIGHT_BRACKET public="1" get="inline" set="null" expr="cast 48" line="53" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 48</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_BRACKET>
		<GRAVE public="1" get="inline" set="null" expr="cast 53" line="56" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 53</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRAVE>
		<A public="1" get="inline" set="null" expr="cast 4" line="57" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A>
		<B public="1" get="inline" set="null" expr="cast 5" line="58" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</B>
		<C public="1" get="inline" set="null" expr="cast 6" line="59" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</C>
		<D public="1" get="inline" set="null" expr="cast 7" line="60" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</D>
		<E public="1" get="inline" set="null" expr="cast 8" line="61" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</E>
		<F public="1" get="inline" set="null" expr="cast 9" line="62" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F>
		<G public="1" get="inline" set="null" expr="cast 10" line="63" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</G>
		<H public="1" get="inline" set="null" expr="cast 11" line="64" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</H>
		<I public="1" get="inline" set="null" expr="cast 12" line="65" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</I>
		<J public="1" get="inline" set="null" expr="cast 13" line="66" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</J>
		<K public="1" get="inline" set="null" expr="cast 14" line="67" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</K>
		<L public="1" get="inline" set="null" expr="cast 15" line="68" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</L>
		<M public="1" get="inline" set="null" expr="cast 16" line="69" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</M>
		<N public="1" get="inline" set="null" expr="cast 17" line="70" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 17</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</N>
		<O public="1" get="inline" set="null" expr="cast 18" line="71" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 18</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</O>
		<P public="1" get="inline" set="null" expr="cast 19" line="72" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 19</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</P>
		<Q public="1" get="inline" set="null" expr="cast 20" line="73" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Q>
		<R public="1" get="inline" set="null" expr="cast 21" line="74" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 21</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</R>
		<S public="1" get="inline" set="null" expr="cast 22" line="75" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 22</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</S>
		<T public="1" get="inline" set="null" expr="cast 23" line="76" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 23</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</T>
		<U public="1" get="inline" set="null" expr="cast 24" line="77" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 24</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</U>
		<V public="1" get="inline" set="null" expr="cast 25" line="78" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 25</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</V>
		<W public="1" get="inline" set="null" expr="cast 26" line="79" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 26</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</W>
		<X public="1" get="inline" set="null" expr="cast 27" line="80" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 27</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</X>
		<Y public="1" get="inline" set="null" expr="cast 28" line="81" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 28</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Y>
		<Z public="1" get="inline" set="null" expr="cast 29" line="82" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 29</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Z>
		<DELETE public="1" get="inline" set="null" expr="cast 76" line="83" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 76</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DELETE>
		<CAPS_LOCK public="1" get="inline" set="null" expr="cast 57" line="84" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 57</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CAPS_LOCK>
		<F1 public="1" get="inline" set="null" expr="cast 58" line="85" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 58</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F1>
		<F2 public="1" get="inline" set="null" expr="cast 59" line="86" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 59</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F2>
		<F3 public="1" get="inline" set="null" expr="cast 60" line="87" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 60</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F3>
		<F4 public="1" get="inline" set="null" expr="cast 61" line="88" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 61</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F4>
		<F5 public="1" get="inline" set="null" expr="cast 62" line="89" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 62</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F5>
		<F6 public="1" get="inline" set="null" expr="cast 63" line="90" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 63</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F6>
		<F7 public="1" get="inline" set="null" expr="cast 64" line="91" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 64</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F7>
		<F8 public="1" get="inline" set="null" expr="cast 65" line="92" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 65</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F8>
		<F9 public="1" get="inline" set="null" expr="cast 66" line="93" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 66</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F9>
		<F10 public="1" get="inline" set="null" expr="cast 67" line="94" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 67</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F10>
		<F11 public="1" get="inline" set="null" expr="cast 68" line="95" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 68</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F11>
		<F12 public="1" get="inline" set="null" expr="cast 69" line="96" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 69</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F12>
		<PRINT_SCREEN public="1" get="inline" set="null" expr="cast 70" line="97" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 70</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRINT_SCREEN>
		<SCROLL_LOCK public="1" get="inline" set="null" expr="cast 71" line="98" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 71</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SCROLL_LOCK>
		<PAUSE public="1" get="inline" set="null" expr="cast 72" line="99" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 72</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAUSE>
		<INSERT public="1" get="inline" set="null" expr="cast 73" line="100" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 73</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INSERT>
		<HOME public="1" get="inline" set="null" expr="cast 74" line="101" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 74</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HOME>
		<PAGE_UP public="1" get="inline" set="null" expr="cast 75" line="102" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 75</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGE_UP>
		<END public="1" get="inline" set="null" expr="cast 77" line="103" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 77</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</END>
		<PAGE_DOWN public="1" get="inline" set="null" expr="cast 78" line="104" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 78</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGE_DOWN>
		<RIGHT public="1" get="inline" set="null" expr="cast 79" line="105" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 79</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<LEFT public="1" get="inline" set="null" expr="cast 80" line="106" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 80</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<DOWN public="1" get="inline" set="null" expr="cast 81" line="107" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 81</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOWN>
		<UP public="1" get="inline" set="null" expr="cast 82" line="108" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 82</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UP>
		<NUM_LOCK public="1" get="inline" set="null" expr="cast 83" line="109" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 83</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUM_LOCK>
		<NUMPAD_DIVIDE public="1" get="inline" set="null" expr="cast 84" line="110" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 84</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DIVIDE>
		<NUMPAD_MULTIPLY public="1" get="inline" set="null" expr="cast 85" line="111" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 85</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MULTIPLY>
		<NUMPAD_MINUS public="1" get="inline" set="null" expr="cast 86" line="112" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 86</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MINUS>
		<NUMPAD_PLUS public="1" get="inline" set="null" expr="cast 87" line="113" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 87</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PLUS>
		<NUMPAD_ENTER public="1" get="inline" set="null" expr="cast 88" line="114" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 88</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_ENTER>
		<NUMPAD_1 public="1" get="inline" set="null" expr="cast 89" line="115" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 89</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_1>
		<NUMPAD_2 public="1" get="inline" set="null" expr="cast 90" line="116" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 90</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_2>
		<NUMPAD_3 public="1" get="inline" set="null" expr="cast 91" line="117" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 91</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_3>
		<NUMPAD_4 public="1" get="inline" set="null" expr="cast 92" line="118" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 92</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_4>
		<NUMPAD_5 public="1" get="inline" set="null" expr="cast 93" line="119" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 93</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_5>
		<NUMPAD_6 public="1" get="inline" set="null" expr="cast 94" line="120" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 94</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_6>
		<NUMPAD_7 public="1" get="inline" set="null" expr="cast 95" line="121" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 95</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_7>
		<NUMPAD_8 public="1" get="inline" set="null" expr="cast 96" line="122" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 96</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_8>
		<NUMPAD_9 public="1" get="inline" set="null" expr="cast 97" line="123" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 97</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_9>
		<NUMPAD_0 public="1" get="inline" set="null" expr="cast 98" line="124" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 98</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_0>
		<NUMPAD_PERIOD public="1" get="inline" set="null" expr="cast 99" line="125" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 99</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PERIOD>
		<APPLICATION public="1" get="inline" set="null" expr="cast 101" line="126" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 101</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APPLICATION>
		<POWER public="1" get="inline" set="null" expr="cast 102" line="127" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 102</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</POWER>
		<NUMPAD_EQUALS public="1" get="inline" set="null" expr="cast 103" line="128" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 103</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_EQUALS>
		<F13 public="1" get="inline" set="null" expr="cast 104" line="129" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 104</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F13>
		<F14 public="1" get="inline" set="null" expr="cast 105" line="130" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 105</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F14>
		<F15 public="1" get="inline" set="null" expr="cast 106" line="131" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 106</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F15>
		<F16 public="1" get="inline" set="null" expr="cast 107" line="132" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 107</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F16>
		<F17 public="1" get="inline" set="null" expr="cast 108" line="133" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 108</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F17>
		<F18 public="1" get="inline" set="null" expr="cast 109" line="134" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 109</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F18>
		<F19 public="1" get="inline" set="null" expr="cast 110" line="135" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 110</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F19>
		<F20 public="1" get="inline" set="null" expr="cast 111" line="136" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 111</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F20>
		<F21 public="1" get="inline" set="null" expr="cast 112" line="137" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 112</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F21>
		<F22 public="1" get="inline" set="null" expr="cast 113" line="138" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 113</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F22>
		<F23 public="1" get="inline" set="null" expr="cast 114" line="139" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 114</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F23>
		<F24 public="1" get="inline" set="null" expr="cast 115" line="140" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 115</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F24>
		<EXECUTE public="1" get="inline" set="null" expr="cast 116" line="141" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 116</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXECUTE>
		<HELP public="1" get="inline" set="null" expr="cast 117" line="142" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 117</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HELP>
		<MENU public="1" get="inline" set="null" expr="cast 118" line="143" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 118</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MENU>
		<SELECT public="1" get="inline" set="null" expr="cast 119" line="144" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 119</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SELECT>
		<STOP public="1" get="inline" set="null" expr="cast 120" line="145" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 120</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STOP>
		<AGAIN public="1" get="inline" set="null" expr="cast 121" line="146" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 121</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AGAIN>
		<UNDO public="1" get="inline" set="null" expr="cast 122" line="147" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 122</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNDO>
		<CUT public="1" get="inline" set="null" expr="cast 123" line="148" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 123</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CUT>
		<COPY public="1" get="inline" set="null" expr="cast 124" line="149" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 124</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COPY>
		<PASTE public="1" get="inline" set="null" expr="cast 125" line="150" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 125</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PASTE>
		<FIND public="1" get="inline" set="null" expr="cast 126" line="151" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 126</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIND>
		<MUTE public="1" get="inline" set="null" expr="cast 127" line="152" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 127</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MUTE>
		<VOLUME_UP public="1" get="inline" set="null" expr="cast 128" line="153" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 128</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOLUME_UP>
		<VOLUME_DOWN public="1" get="inline" set="null" expr="cast 129" line="154" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 129</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOLUME_DOWN>
		<NUMPAD_COMMA public="1" get="inline" set="null" expr="cast 133" line="155" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 133</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_COMMA>
		<ALT_ERASE public="1" get="inline" set="null" expr="cast 153" line="157" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 153</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALT_ERASE>
		<SYSTEM_REQUEST public="1" get="inline" set="null" expr="cast 154" line="158" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 154</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SYSTEM_REQUEST>
		<CANCEL public="1" get="inline" set="null" expr="cast 155" line="159" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 155</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CANCEL>
		<CLEAR public="1" get="inline" set="null" expr="cast 156" line="160" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 156</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLEAR>
		<PRIOR public="1" get="inline" set="null" expr="cast 157" line="161" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 157</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRIOR>
		<RETURN2 public="1" get="inline" set="null" expr="cast 158" line="162" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 158</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RETURN2>
		<SEPARATOR public="1" get="inline" set="null" expr="cast 159" line="163" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 159</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEPARATOR>
		<OUT public="1" get="inline" set="null" expr="cast 160" line="164" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 160</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OUT>
		<OPER public="1" get="inline" set="null" expr="cast 161" line="165" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 161</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OPER>
		<CLEAR_AGAIN public="1" get="inline" set="null" expr="cast 162" line="166" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 162</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLEAR_AGAIN>
		<CRSEL public="1" get="inline" set="null" expr="cast 163" line="167" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 163</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CRSEL>
		<EXSEL public="1" get="inline" set="null" expr="cast 164" line="168" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 164</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXSEL>
		<NUMPAD_00 public="1" get="inline" set="null" expr="cast 176" line="169" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 176</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_00>
		<NUMPAD_000 public="1" get="inline" set="null" expr="cast 177" line="170" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 177</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_000>
		<THOUSAND_SEPARATOR public="1" get="inline" set="null" expr="cast 178" line="171" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 178</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</THOUSAND_SEPARATOR>
		<DECIMAL_SEPARATOR public="1" get="inline" set="null" expr="cast 179" line="172" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 179</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DECIMAL_SEPARATOR>
		<CURRENCY_UNIT public="1" get="inline" set="null" expr="cast 180" line="173" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 180</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURRENCY_UNIT>
		<CURRENCY_SUBUNIT public="1" get="inline" set="null" expr="cast 181" line="174" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 181</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURRENCY_SUBUNIT>
		<NUMPAD_LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 182" line="175" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 182</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LEFT_PARENTHESIS>
		<NUMPAD_RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 183" line="176" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 183</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_RIGHT_PARENTHESIS>
		<NUMPAD_LEFT_BRACE public="1" get="inline" set="null" expr="cast 184" line="177" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 184</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LEFT_BRACE>
		<NUMPAD_RIGHT_BRACE public="1" get="inline" set="null" expr="cast 185" line="178" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 185</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_RIGHT_BRACE>
		<NUMPAD_TAB public="1" get="inline" set="null" expr="cast 186" line="179" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 186</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_TAB>
		<NUMPAD_BACKSPACE public="1" get="inline" set="null" expr="cast 187" line="180" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 187</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_BACKSPACE>
		<NUMPAD_A public="1" get="inline" set="null" expr="cast 188" line="181" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 188</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_A>
		<NUMPAD_B public="1" get="inline" set="null" expr="cast 189" line="182" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 189</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_B>
		<NUMPAD_C public="1" get="inline" set="null" expr="cast 190" line="183" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 190</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_C>
		<NUMPAD_D public="1" get="inline" set="null" expr="cast 191" line="184" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 191</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_D>
		<NUMPAD_E public="1" get="inline" set="null" expr="cast 192" line="185" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 192</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_E>
		<NUMPAD_F public="1" get="inline" set="null" expr="cast 193" line="186" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 193</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_F>
		<NUMPAD_XOR public="1" get="inline" set="null" expr="cast 194" line="187" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 194</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_XOR>
		<NUMPAD_POWER public="1" get="inline" set="null" expr="cast 195" line="188" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 195</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_POWER>
		<NUMPAD_PERCENT public="1" get="inline" set="null" expr="cast 196" line="189" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 196</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PERCENT>
		<NUMPAD_LESS_THAN public="1" get="inline" set="null" expr="cast 197" line="190" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 197</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LESS_THAN>
		<NUMPAD_GREATER_THAN public="1" get="inline" set="null" expr="cast 198" line="191" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 198</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_GREATER_THAN>
		<NUMPAD_AMPERSAND public="1" get="inline" set="null" expr="cast 199" line="192" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 199</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_AMPERSAND>
		<NUMPAD_DOUBLE_AMPERSAND public="1" get="inline" set="null" expr="cast 200" line="193" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 200</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DOUBLE_AMPERSAND>
		<NUMPAD_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 201" line="194" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 201</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_VERTICAL_BAR>
		<NUMPAD_DOUBLE_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 202" line="195" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 202</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DOUBLE_VERTICAL_BAR>
		<NUMPAD_COLON public="1" get="inline" set="null" expr="cast 203" line="196" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 203</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_COLON>
		<NUMPAD_HASH public="1" get="inline" set="null" expr="cast 204" line="197" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 204</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_HASH>
		<NUMPAD_SPACE public="1" get="inline" set="null" expr="cast 205" line="198" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 205</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_SPACE>
		<NUMPAD_AT public="1" get="inline" set="null" expr="cast 206" line="199" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 206</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_AT>
		<NUMPAD_EXCLAMATION public="1" get="inline" set="null" expr="cast 207" line="200" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 207</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_EXCLAMATION>
		<NUMPAD_MEM_STORE public="1" get="inline" set="null" expr="cast 208" line="201" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 208</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_STORE>
		<NUMPAD_MEM_RECALL public="1" get="inline" set="null" expr="cast 209" line="202" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 209</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_RECALL>
		<NUMPAD_MEM_CLEAR public="1" get="inline" set="null" expr="cast 210" line="203" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 210</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_CLEAR>
		<NUMPAD_MEM_ADD public="1" get="inline" set="null" expr="cast 211" line="204" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 211</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_ADD>
		<NUMPAD_MEM_SUBTRACT public="1" get="inline" set="null" expr="cast 212" line="205" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 212</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_SUBTRACT>
		<NUMPAD_MEM_MULTIPLY public="1" get="inline" set="null" expr="cast 213" line="206" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 213</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_MULTIPLY>
		<NUMPAD_MEM_DIVIDE public="1" get="inline" set="null" expr="cast 214" line="207" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 214</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_DIVIDE>
		<NUMPAD_PLUS_MINUS public="1" get="inline" set="null" expr="cast 215" line="208" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 215</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PLUS_MINUS>
		<NUMPAD_CLEAR public="1" get="inline" set="null" expr="cast 216" line="209" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 216</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_CLEAR>
		<NUMPAD_CLEAR_ENTRY public="1" get="inline" set="null" expr="cast 217" line="210" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 217</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_CLEAR_ENTRY>
		<NUMPAD_BINARY public="1" get="inline" set="null" expr="cast 218" line="211" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 218</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_BINARY>
		<NUMPAD_OCTAL public="1" get="inline" set="null" expr="cast 219" line="212" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 219</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_OCTAL>
		<NUMPAD_DECIMAL public="1" get="inline" set="null" expr="cast 220" line="213" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 220</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DECIMAL>
		<NUMPAD_HEXADECIMAL public="1" get="inline" set="null" expr="cast 221" line="214" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 221</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_HEXADECIMAL>
		<LEFT_CTRL public="1" get="inline" set="null" expr="cast 224" line="215" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 224</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_CTRL>
		<LEFT_SHIFT public="1" get="inline" set="null" expr="cast 225" line="216" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 225</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_SHIFT>
		<LEFT_ALT public="1" get="inline" set="null" expr="cast 226" line="217" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 226</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_ALT>
		<LEFT_META public="1" get="inline" set="null" expr="cast 227" line="218" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 227</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_META>
		<RIGHT_CTRL public="1" get="inline" set="null" expr="cast 228" line="219" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 228</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_CTRL>
		<RIGHT_SHIFT public="1" get="inline" set="null" expr="cast 229" line="220" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 229</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_SHIFT>
		<RIGHT_ALT public="1" get="inline" set="null" expr="cast 230" line="221" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 230</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_ALT>
		<RIGHT_META public="1" get="inline" set="null" expr="cast 231" line="222" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 231</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_META>
		<MODE public="1" get="inline" set="null" expr="cast 257" line="223" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 257</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MODE>
		<AUDIO_NEXT public="1" get="inline" set="null" expr="cast 258" line="224" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 258</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_NEXT>
		<AUDIO_PREVIOUS public="1" get="inline" set="null" expr="cast 259" line="225" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 259</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_PREVIOUS>
		<AUDIO_STOP public="1" get="inline" set="null" expr="cast 260" line="226" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 260</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_STOP>
		<AUDIO_PLAY public="1" get="inline" set="null" expr="cast 261" line="227" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 261</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_PLAY>
		<AUDIO_MUTE public="1" get="inline" set="null" expr="cast 262" line="228" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 262</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_MUTE>
		<MEDIA_SELECT public="1" get="inline" set="null" expr="cast 263" line="229" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 263</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEDIA_SELECT>
		<WWW public="1" get="inline" set="null" expr="cast 264" line="230" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 264</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WWW>
		<MAIL public="1" get="inline" set="null" expr="cast 265" line="231" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 265</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MAIL>
		<CALCULATOR public="1" get="inline" set="null" expr="cast 266" line="232" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 266</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CALCULATOR>
		<COMPUTER public="1" get="inline" set="null" expr="cast 267" line="233" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 267</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMPUTER>
		<APP_CONTROL_SEARCH public="1" get="inline" set="null" expr="cast 268" line="234" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 268</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_SEARCH>
		<APP_CONTROL_HOME public="1" get="inline" set="null" expr="cast 269" line="235" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 269</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_HOME>
		<APP_CONTROL_BACK public="1" get="inline" set="null" expr="cast 270" line="236" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 270</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_BACK>
		<APP_CONTROL_FORWARD public="1" get="inline" set="null" expr="cast 271" line="237" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 271</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_FORWARD>
		<APP_CONTROL_STOP public="1" get="inline" set="null" expr="cast 272" line="238" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 272</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_STOP>
		<APP_CONTROL_REFRESH public="1" get="inline" set="null" expr="cast 273" line="239" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 273</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_REFRESH>
		<APP_CONTROL_BOOKMARKS public="1" get="inline" set="null" expr="cast 274" line="240" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 274</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_BOOKMARKS>
		<BRIGHTNESS_DOWN public="1" get="inline" set="null" expr="cast 275" line="241" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 275</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRIGHTNESS_DOWN>
		<BRIGHTNESS_UP public="1" get="inline" set="null" expr="cast 276" line="242" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 276</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRIGHTNESS_UP>
		<DISPLAY_SWITCH public="1" get="inline" set="null" expr="cast 277" line="243" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 277</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DISPLAY_SWITCH>
		<BACKLIGHT_TOGGLE public="1" get="inline" set="null" expr="cast 278" line="244" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 278</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_TOGGLE>
		<BACKLIGHT_DOWN public="1" get="inline" set="null" expr="cast 279" line="245" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 279</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_DOWN>
		<BACKLIGHT_UP public="1" get="inline" set="null" expr="cast 280" line="246" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 280</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_UP>
		<EJECT public="1" get="inline" set="null" expr="cast 281" line="247" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 281</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EJECT>
		<SLEEP public="1" get="inline" set="null" expr="cast 282" line="248" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 282</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLEEP>
		<fromKeyCode public="1" set="method" line="250" static="1">
			<f a="keyCode">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.ScanCode"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromKeyCode>
		<toKeyCode set="method" line="256" static="1"><f a="scanCode">
	<x path="lime.ui.ScanCode"/>
	<x path="lime.ui.KeyCode"/>
</f></toKeyCode>
		<gt get="inline" set="null" line="262" static="1">
			<f a="a:b">
				<x path="lime.ui.ScanCode"/>
				<x path="lime.ui.ScanCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</gt>
		<gte get="inline" set="null" line="263" static="1">
			<f a="a:b">
				<x path="lime.ui.ScanCode"/>
				<x path="lime.ui.ScanCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</gte>
		<lt get="inline" set="null" line="264" static="1">
			<f a="a:b">
				<x path="lime.ui.ScanCode"/>
				<x path="lime.ui.ScanCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</lt>
		<lte get="inline" set="null" line="265" static="1">
			<f a="a:b">
				<x path="lime.ui.ScanCode"/>
				<x path="lime.ui.ScanCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</lte>
		<plus get="inline" set="null" line="266" static="1">
			<f a="a:b">
				<x path="lime.ui.ScanCode"/>
				<x path="Int"/>
				<x path="lime.ui.ScanCode"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</plus>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":access"><e>lime.ui.KeyCode</e></m>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime.ui.Touch" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Touch.hx">
		<onCancel public="1" expr="new Event&lt;Touch&gt;()" line="15" static="1">
			<c path="lime.app._Event_lime_ui_Touch_Void"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Touch>()]]></e></m></meta>
		</onCancel>
		<onEnd public="1" expr="new Event&lt;Touch&gt;()" line="16" static="1">
			<c path="lime.app._Event_lime_ui_Touch_Void"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Touch>()]]></e></m></meta>
		</onEnd>
		<onMove public="1" expr="new Event&lt;Touch&gt;()" line="17" static="1">
			<c path="lime.app._Event_lime_ui_Touch_Void"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Touch>()]]></e></m></meta>
		</onMove>
		<onStart public="1" expr="new Event&lt;Touch&gt;()" line="18" static="1">
			<c path="lime.app._Event_lime_ui_Touch_Void"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Touch>()]]></e></m></meta>
		</onStart>
		<device public="1"><x path="Int"/></device>
		<dx public="1"><x path="Float"/></dx>
		<dy public="1"><x path="Float"/></dy>
		<id public="1"><x path="Int"/></id>
		<pressure public="1"><x path="Float"/></pressure>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<new public="1" set="method" line="29"><f a="x:y:id:dx:dy:pressure:device">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.ui.Window" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Window.hx">
		<application public="1" set="null"><c path="lime.app.Application"/></application>
		<borderless public="1" get="accessor" set="accessor"><x path="Bool"/></borderless>
		<context public="1" set="null"><c path="lime.graphics.RenderContext"/></context>
		<cursor public="1" get="accessor" set="accessor"><e path="lime.ui.MouseCursor"/></cursor>
		<display public="1" get="accessor" set="null"><c path="lime.system.Display"/></display>
		<displayMode public="1" get="accessor" set="accessor"><c path="lime.system.DisplayMode"/></displayMode>
		<frameRate public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The current frame rate (measured in frames-per-second) of the window.
	 *
	 * On some platforms, a frame rate of 60 or greater may imply vsync, which will
	 * perform more quickly on displays with a higher refresh rate</haxe_doc>
		</frameRate>
		<fullscreen public="1" get="accessor" set="accessor"><x path="Bool"/></fullscreen>
		<height public="1" get="accessor" set="accessor"><x path="Int"/></height>
		<hidden public="1" get="accessor" set="null"><x path="Bool"/></hidden>
		<id public="1" set="null"><x path="Int"/></id>
		<maximized public="1" get="accessor" set="accessor"><x path="Bool"/></maximized>
		<minimized public="1" get="accessor" set="accessor"><x path="Bool"/></minimized>
		<mouseLock public="1" get="accessor" set="accessor"><x path="Bool"/></mouseLock>
		<onActivate public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onActivate>
		<onClose public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onClose>
		<onDeactivate public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onDeactivate>
		<onDropFile public="1" set="null" expr="new Event&lt;String&gt;()">
			<c path="lime.app._Event_String_Void"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<String>()]]></e></m></meta>
		</onDropFile>
		<onEnter public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onEnter>
		<onExpose public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onExpose>
		<onFocusIn public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onFocusIn>
		<onFocusOut public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onFocusOut>
		<onFullscreen public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onFullscreen>
		<onKeyDown public="1" set="null" expr="new Event&lt;KeyCode -&gt; KeyModifier&gt;()">
			<c path="lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void"><f a=":">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<KeyCode -> KeyModifier>()]]></e></m></meta>
		</onKeyDown>
		<onKeyUp public="1" set="null" expr="new Event&lt;KeyCode -&gt; KeyModifier&gt;()">
			<c path="lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void"><f a=":">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<KeyCode -> KeyModifier>()]]></e></m></meta>
		</onKeyUp>
		<onLeave public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onLeave>
		<onMaximize public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onMaximize>
		<onMinimize public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onMinimize>
		<onMouseDown public="1" set="null" expr="new Event&lt;Float -&gt; Float -&gt; MouseButton&gt;()">
			<c path="lime.app._Event_Float_Float_lime_ui_MouseButton_Void"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.ui.MouseButton"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float -> MouseButton>()]]></e></m></meta>
		</onMouseDown>
		<onMouseMove public="1" set="null" expr="new Event&lt;Float -&gt; Float&gt;()">
			<c path="lime.app._Event_Float_Float_Void"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float>()]]></e></m></meta>
		</onMouseMove>
		<onMouseMoveRelative public="1" set="null" expr="new Event&lt;Float -&gt; Float&gt;()">
			<c path="lime.app._Event_Float_Float_Void"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float>()]]></e></m></meta>
		</onMouseMoveRelative>
		<onMouseUp public="1" set="null" expr="new Event&lt;Float -&gt; Float -&gt; Int&gt;()">
			<c path="lime.app._Event_Float_Float_Int_Void"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float -> Int>()]]></e></m></meta>
		</onMouseUp>
		<onMouseWheel public="1" set="null" expr="new Event&lt;Float -&gt; Float -&gt; MouseWheelMode&gt;()">
			<c path="lime.app._Event_Float_Float_lime_ui_MouseWheelMode_Void"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<e path="lime.ui.MouseWheelMode"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float -> MouseWheelMode>()]]></e></m></meta>
		</onMouseWheel>
		<onMove public="1" set="null" expr="new Event&lt;Float -&gt; Float&gt;()">
			<c path="lime.app._Event_Float_Float_Void"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float>()]]></e></m></meta>
		</onMove>
		<onRender public="1" set="null" expr="new Event&lt;RenderContext&gt;()">
			<c path="lime.app._Event_lime_graphics_RenderContext_Void"><f a="">
	<c path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<RenderContext>()]]></e></m></meta>
		</onRender>
		<onRenderContextLost public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onRenderContextLost>
		<onRenderContextRestored public="1" set="null" expr="new Event&lt;RenderContext&gt;()">
			<c path="lime.app._Event_lime_graphics_RenderContext_Void"><f a="">
	<c path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<RenderContext>()]]></e></m></meta>
		</onRenderContextRestored>
		<onResize public="1" set="null" expr="new Event&lt;Int -&gt; Int&gt;()">
			<c path="lime.app._Event_Int_Int_Void"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> Int>()]]></e></m></meta>
		</onResize>
		<onRestore public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onRestore>
		<onTextEdit public="1" set="null" expr="new Event&lt;String -&gt; Int -&gt; Int&gt;()">
			<c path="lime.app._Event_String_Int_Int_Void"><f a="::">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<String -> Int -> Int>()]]></e></m></meta>
		</onTextEdit>
		<onTextInput public="1" set="null" expr="new Event&lt;String&gt;()">
			<c path="lime.app._Event_String_Void"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<String>()]]></e></m></meta>
		</onTextInput>
		<parameters public="1"><d/></parameters>
		<resizable public="1" get="accessor" set="accessor"><x path="Bool"/></resizable>
		<scale public="1" get="accessor" set="null"><x path="Float"/></scale>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<textInputEnabled public="1" get="accessor" set="accessor"><x path="Bool"/></textInputEnabled>
		<title public="1" get="accessor" set="accessor"><c path="String"/></title>
		<width public="1" get="accessor" set="accessor"><x path="Int"/></width>
		<x public="1" get="accessor" set="accessor"><x path="Int"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Int"/></y>
		<__attributes>
			<t path="lime.ui.WindowAttributes"/>
			<meta><m n=":noCompletion"/></meta>
		</__attributes>
		<__backend>
			<t path="lime.ui._Window.WindowBackend"/>
			<meta><m n=":noCompletion"/></meta>
		</__backend>
		<__borderless>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__borderless>
		<__fullscreen>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__fullscreen>
		<__height>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__height>
		<__hidden>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__hidden>
		<__maximized>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__maximized>
		<__minimized>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__minimized>
		<__resizable>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__resizable>
		<__scale>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__scale>
		<__title>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__title>
		<__width>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__width>
		<__x>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__x>
		<__y>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__y>
		<alert public="1" set="method" line="380">
			<f a="?message:?title" v="null:null">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ title : null, message : null }</e></m></meta>
		</alert>
		<close public="1" set="method" line="387"><f a=""><x path="Void"/></f></close>
		<focus public="1" set="method" line="394"><f a=""><x path="Void"/></f></focus>
		<move public="1" set="method" line="401"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></move>
		<readPixels public="1" set="method" line="411">
			<f a="?rect" v="null">
				<c path="lime.math.Rectangle"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ rect : null }</e></m></meta>
		</readPixels>
		<resize public="1" set="method" line="418"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setIcon public="1" set="method" line="428"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></setIcon>
		<toString public="1" set="method" line="441"><f a=""><c path="String"/></f></toString>
		<warpMouse public="1" set="method" line="448"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></warpMouse>
		<get_cursor set="method" line="462">
			<f a=""><e path="lime.ui.MouseCursor"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cursor>
		<set_cursor set="method" line="469">
			<f a="value">
				<e path="lime.ui.MouseCursor"/>
				<e path="lime.ui.MouseCursor"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cursor>
		<get_display set="method" line="476">
			<f a=""><c path="lime.system.Display"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_display>
		<get_displayMode set="method" line="483">
			<f a=""><c path="lime.system.DisplayMode"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_displayMode>
		<set_displayMode set="method" line="490">
			<f a="value">
				<c path="lime.system.DisplayMode"/>
				<c path="lime.system.DisplayMode"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_displayMode>
		<get_borderless get="inline" set="null" line="497">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_borderless>
		<set_borderless set="method" line="504">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_borderless>
		<get_frameRate get="inline" set="null" line="511">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_frameRate>
		<set_frameRate get="inline" set="null" line="518">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_frameRate>
		<get_fullscreen get="inline" set="null" line="525">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_fullscreen>
		<set_fullscreen set="method" line="532">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_fullscreen>
		<get_height get="inline" set="null" line="539">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_height>
		<set_height set="method" line="546">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_height>
		<get_hidden get="inline" set="null" line="554">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_hidden>
		<get_maximized get="inline" set="null" line="561">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_maximized>
		<set_maximized get="inline" set="null" line="568">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_maximized>
		<get_minimized get="inline" set="null" line="576">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_minimized>
		<set_minimized set="method" line="583">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_minimized>
		<get_mouseLock set="method" line="591">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mouseLock>
		<set_mouseLock set="method" line="598">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_mouseLock>
		<get_resizable get="inline" set="null" line="606">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_resizable>
		<set_resizable set="method" line="613">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_resizable>
		<get_scale get="inline" set="null" line="621">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_scale>
		<get_textInputEnabled get="inline" set="null" line="628">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_textInputEnabled>
		<set_textInputEnabled get="inline" set="null" line="635">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_textInputEnabled>
		<get_title get="inline" set="null" line="642">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_title>
		<set_title set="method" line="649">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_title>
		<get_width get="inline" set="null" line="656">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_width>
		<set_width set="method" line="663">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_width>
		<get_x get="inline" set="null" line="671">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_x>
		<set_x set="method" line="678">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_x>
		<get_y get="inline" set="null" line="686">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_y>
		<set_y set="method" line="693">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_y>
		<new set="method" line="149">
			<f a="application:attributes">
				<c path="lime.app.Application"/>
				<t path="lime.ui.WindowAttributes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<typedef path="lime.ui._Window.WindowBackend" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/Window.hx" private="1" module="lime.ui.Window">
		<c path="lime._internal.backend.flash.FlashWindow"/>
		<meta><m n=":noCompletion"/></meta>
	</typedef>
	<typedef path="lime.ui.WindowAttributes" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/ui/WindowAttributes.hx"><a>
	<y>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</y>
	<x>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</x>
	<width>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</width>
	<title>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</title>
	<resizable>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</resizable>
	<parameters>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</parameters>
	<minimized>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</minimized>
	<maximized>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</maximized>
	<hidden>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</hidden>
	<height>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</height>
	<fullscreen>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</fullscreen>
	<frameRate>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</frameRate>
	<element>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</element>
	<context>
		<x path="Null"><t path="lime.graphics.RenderContextAttributes"/></x>
		<meta><m n=":optional"/></meta>
	</context>
	<borderless>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</borderless>
	<alwaysOnTop>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</alwaysOnTop>
	<allowHighDPI>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</allowHighDPI>
</a></typedef>
	<abstract path="lime.utils.ArrayBuffer" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/ArrayBuffer.hx">
		<from><icast><c path="haxe.io.Bytes"/></icast></from>
		<this><c path="haxe.io.Bytes"/></this>
		<to><icast><c path="haxe.io.Bytes"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._ArrayBuffer.ArrayBuffer_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/ArrayBuffer.hx" private="1" module="lime.utils.ArrayBuffer">
	<_new public="1" get="inline" set="null" line="13" static="1">
		<f a="byteLength">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._ArrayBuffer.ArrayBuffer_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/ArrayBuffer.hx" private="1" module="lime.utils.ArrayBuffer">
		<_new public="1" get="inline" set="null" line="13" static="1">
			<f a="byteLength">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.TypedArrayType" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/ArrayBufferView.hx" module="lime.utils.ArrayBufferView">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="lime.utils._ArrayBufferView.TypedArrayType_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/ArrayBufferView.hx" private="1" module="lime.utils.ArrayBufferView" extern="1">
	<None public="1" get="inline" set="null" expr="cast 0" line="409" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</None>
	<Int8 public="1" get="inline" set="null" expr="cast 1" line="410" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Int8>
	<Int16 public="1" get="inline" set="null" expr="cast 2" line="411" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Int16>
	<Int32 public="1" get="inline" set="null" expr="cast 3" line="412" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Int32>
	<Uint8 public="1" get="inline" set="null" expr="cast 4" line="413" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint8>
	<Uint8Clamped public="1" get="inline" set="null" expr="cast 5" line="414" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint8Clamped>
	<Uint16 public="1" get="inline" set="null" expr="cast 6" line="415" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint16>
	<Uint32 public="1" get="inline" set="null" expr="cast 7" line="416" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint32>
	<Float32 public="1" get="inline" set="null" expr="cast 8" line="417" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Float32>
	<Float64 public="1" get="inline" set="null" expr="cast 9" line="418" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Float64>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.utils._ArrayBufferView.TypedArrayType_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/ArrayBufferView.hx" private="1" module="lime.utils.ArrayBufferView" extern="1">
		<None public="1" get="inline" set="null" expr="cast 0" line="409" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</None>
		<Int8 public="1" get="inline" set="null" expr="cast 1" line="410" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Int8>
		<Int16 public="1" get="inline" set="null" expr="cast 2" line="411" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Int16>
		<Int32 public="1" get="inline" set="null" expr="cast 3" line="412" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Int32>
		<Uint8 public="1" get="inline" set="null" expr="cast 4" line="413" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint8>
		<Uint8Clamped public="1" get="inline" set="null" expr="cast 5" line="414" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint8Clamped>
		<Uint16 public="1" get="inline" set="null" expr="cast 6" line="415" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint16>
		<Uint32 public="1" get="inline" set="null" expr="cast 7" line="416" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint32>
		<Float32 public="1" get="inline" set="null" expr="cast 8" line="417" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Float32>
		<Float64 public="1" get="inline" set="null" expr="cast 9" line="418" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Float64>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.utils.ArrayBufferIO" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/ArrayBufferView.hx" module="lime.utils.ArrayBufferView">
		<getInt8 public="1" get="inline" set="null" line="428" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getInt8>
		<setInt8 public="1" get="inline" set="null" line="440" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setInt8>
		<getUint8 public="1" get="inline" set="null" line="454" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta><m n=":extern"/></meta>
		</getUint8>
		<setUint8Clamped public="1" get="inline" set="null" line="465" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setUint8Clamped>
		<setUint8 public="1" get="inline" set="null" line="472" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setUint8>
		<getInt16 public="1" set="method" line="488" static="1"><f a="buffer:byteOffset">
	<x path="lime.utils.ArrayBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getInt16>
		<getInt16_BE public="1" set="method" line="505" static="1"><f a="buffer:byteOffset">
	<x path="lime.utils.ArrayBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getInt16_BE>
		<setInt16 public="1" set="method" line="523" static="1"><f a="buffer:byteOffset:value">
	<x path="lime.utils.ArrayBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt16>
		<setInt16_BE public="1" set="method" line="539" static="1"><f a="buffer:byteOffset:value">
	<x path="lime.utils.ArrayBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt16_BE>
		<getUint16 public="1" get="inline" set="null" line="555" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta><m n=":extern"/></meta>
		</getUint16>
		<getUint16_BE public="1" get="inline" set="null" line="571" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta><m n=":extern"/></meta>
		</getUint16_BE>
		<setUint16 public="1" get="inline" set="null" line="587" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setUint16>
		<setUint16_BE public="1" get="inline" set="null" line="598" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setUint16_BE>
		<getInt32 public="1" get="inline" set="null" line="612" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getInt32>
		<getInt32_BE public="1" get="inline" set="null" line="623" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getInt32_BE>
		<setInt32 public="1" get="inline" set="null" line="634" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setInt32>
		<setInt32_BE public="1" get="inline" set="null" line="649" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setInt32_BE>
		<getUint32 public="1" get="inline" set="null" line="664" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta><m n=":extern"/></meta>
		</getUint32>
		<getUint32_BE public="1" get="inline" set="null" line="675" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta><m n=":extern"/></meta>
		</getUint32_BE>
		<setUint32 public="1" get="inline" set="null" line="686" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setUint32>
		<setUint32_BE public="1" get="inline" set="null" line="696" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setUint32_BE>
		<getFloat32 public="1" get="inline" set="null" line="709" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getFloat32>
		<getFloat32_BE public="1" get="inline" set="null" line="720" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getFloat32_BE>
		<setFloat32 public="1" get="inline" set="null" line="731" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setFloat32>
		<setFloat32_BE public="1" get="inline" set="null" line="745" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setFloat32_BE>
		<getFloat64 public="1" get="inline" set="null" line="759" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getFloat64>
		<getFloat64_BE public="1" get="inline" set="null" line="770" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getFloat64_BE>
		<setFloat64 public="1" get="inline" set="null" line="781" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setFloat64>
		<setFloat64_BE public="1" get="inline" set="null" line="795" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setFloat64_BE>
		<_clamp get="inline" set="null" line="811" static="1">
			<f a="_in">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</_clamp>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="lime.utils.AssetCache" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/AssetCache.hx">
		<audio public="1"><t path="Map">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</t></audio>
		<enabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</enabled>
		<image public="1"><t path="Map">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</t></image>
		<font public="1"><t path="Map">
	<c path="String"/>
	<d/>
</t></font>
		<version public="1"><x path="Int"/></version>
		<exists public="1" set="method" line="37"><f a="id:?type">
	<c path="String"/>
	<x path="lime.utils.AssetType"/>
	<x path="Bool"/>
</f></exists>
		<set public="1" set="method" line="62"><f a="id:type:asset">
	<c path="String"/>
	<x path="lime.utils.AssetType"/>
	<d/>
	<x path="Void"/>
</f></set>
		<clear public="1" set="method" line="89">
			<f a="?prefix" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ prefix : null }</e></m></meta>
		</clear>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.utils.AssetLibrary" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/AssetLibrary.hx">
		<fromBytes public="1" set="method" line="106" static="1">
			<f a="bytes:?rootPath" v=":null">
				<x path="lime.utils.Bytes"/>
				<c path="String"/>
				<c path="lime.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</fromBytes>
		<fromFile public="1" set="method" line="113" static="1">
			<f a="path:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</fromFile>
		<fromManifest public="1" set="method" line="120" static="1"><f a="manifest">
	<c path="lime.utils.AssetManifest"/>
	<c path="lime.utils.AssetLibrary"/>
</f></fromManifest>
		<loadFromBytes public="1" set="method" line="595" static="1">
			<f a="bytes:?rootPath" v=":null">
				<x path="lime.utils.Bytes"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.utils.AssetLibrary"/></c>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</loadFromBytes>
		<loadFromFile public="1" set="method" line="606" static="1">
			<f a="path:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.utils.AssetLibrary"/></c>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</loadFromFile>
		<loadFromManifest public="1" set="method" line="617" static="1"><f a="manifest">
	<c path="lime.utils.AssetManifest"/>
	<c path="lime.app.Future"><c path="lime.utils.AssetLibrary"/></c>
</f></loadFromManifest>
		<onChange public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onChange>
		<assetsLoaded>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</assetsLoaded>
		<assetsTotal>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</assetsTotal>
		<bytesLoaded>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</bytesLoaded>
		<bytesLoadedCache>
			<t path="Map">
				<c path="String"/>
				<x path="Int"/>
			</t>
			<meta><m n=":noCompletion"/></meta>
		</bytesLoadedCache>
		<bytesTotal>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</bytesTotal>
		<cachedAudioBuffers expr="new Map&lt;String,AudioBuffer&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="lime.media.AudioBuffer"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,AudioBuffer>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</cachedAudioBuffers>
		<cachedBytes expr="new Map&lt;String,Bytes&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="lime.utils.Bytes"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Bytes>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</cachedBytes>
		<cachedFonts expr="new Map&lt;String,Font&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="lime.text.Font"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Font>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</cachedFonts>
		<cachedImages expr="new Map&lt;String,Image&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="lime.graphics.Image"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Image>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</cachedImages>
		<cachedText expr="new Map&lt;String,String&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,String>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</cachedText>
		<classTypes expr="new Map&lt;String,Class&lt;Dynamic&gt;&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Class"><d/></x>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Class<Dynamic>>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</classTypes>
		<loaded>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</loaded>
		<pathGroups expr="new Map&lt;String,Array&lt;String&gt;&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Array<String>>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</pathGroups>
		<paths expr="new Map&lt;String,String&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,String>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</paths>
		<preload expr="new Map&lt;String,Bool&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Bool"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Bool>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</preload>
		<promise>
			<c path="lime.app.Promise_lime_utils_AssetLibrary"/>
			<meta><m n=":noCompletion"/></meta>
		</promise>
		<sizes expr="new Map&lt;String,Int&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Int>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</sizes>
		<types expr="new Map&lt;String,AssetType&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="lime.utils.AssetType"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,AssetType>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</types>
		<exists public="1" set="method" line="60"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getAsset public="1" set="method" line="154"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></getAsset>
		<getAudioBuffer public="1" set="method" line="172"><f a="id">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></getAudioBuffer>
		<getBytes public="1" set="method" line="201"><f a="id">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></getBytes>
		<getFont public="1" set="method" line="251"><f a="id">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></getFont>
		<getImage public="1" set="method" line="282"><f a="id">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</f></getImage>
		<getPath public="1" set="method" line="309"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<getText public="1" set="method" line="328"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getText>
		<isLocal public="1" set="method" line="353"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></isLocal>
		<list public="1" set="method" line="394"><f a="type">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></list>
		<loadAsset public="1" set="method" line="414"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<c path="lime.app.Future"><d/></c>
</f></loadAsset>
		<load public="1" set="method" line="432"><f a=""><c path="lime.app.Future"><c path="lime.utils.AssetLibrary"/></c></f></load>
		<loadAudioBuffer public="1" set="method" line="516"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.media.AudioBuffer"/></c>
</f></loadAudioBuffer>
		<loadBytes public="1" set="method" line="543"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadBytes>
		<loadFont public="1" set="method" line="566"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.text.Font"/></c>
</f></loadFont>
		<loadImage public="1" set="method" line="634"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
</f></loadImage>
		<loadText public="1" set="method" line="653"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="String"/></c>
</f></loadText>
		<unload public="1" set="method" line="685"><f a=""><x path="Void"/></f></unload>
		<__assetLoaded set="method" line="692">
			<f a="id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__assetLoaded>
		<__cacheBreak set="method" line="741">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__cacheBreak>
		<__fromManifest set="method" line="760">
			<f a="manifest">
				<c path="lime.utils.AssetManifest"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromManifest>
		<loadAudioBuffer_onComplete set="method" line="845">
			<f a="id:audioBuffer">
				<c path="String"/>
				<c path="lime.media.AudioBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loadAudioBuffer_onComplete>
		<loadAudioBuffer_onError set="method" line="877">
			<f a="id:message">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loadAudioBuffer_onError>
		<loadBytes_onComplete set="method" line="902">
			<f a="id:bytes">
				<c path="String"/>
				<x path="lime.utils.Bytes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loadBytes_onComplete>
		<loadFont_onComplete set="method" line="910">
			<f a="id:font">
				<c path="String"/>
				<c path="lime.text.Font"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loadFont_onComplete>
		<loadImage_onComplete set="method" line="918">
			<f a="id:image">
				<c path="String"/>
				<c path="lime.graphics.Image"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loadImage_onComplete>
		<loadText_onComplete set="method" line="926">
			<f a="id:text">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loadText_onComplete>
		<load_onError set="method" line="934">
			<f a="id:message">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</load_onError>
		<load_onProgress set="method" line="950">
			<f a="id:bytesLoaded:bytesTotal">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</load_onProgress>
		<new public="1" set="method" line="52"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime.text.Font</e></m>
		</meta>
	</class>
	<class path="lime.utils.AssetManifest" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/AssetManifest.hx">
		<fromBytes public="1" set="method" line="40" static="1">
			<f a="bytes:?rootPath" v=":null">
				<x path="lime.utils.Bytes"/>
				<c path="String"/>
				<c path="lime.utils.AssetManifest"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</fromBytes>
		<fromFile public="1" set="method" line="55" static="1">
			<f a="path:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.utils.AssetManifest"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</fromFile>
		<loadFromBytes public="1" set="method" line="67" static="1">
			<f a="bytes:?rootPath" v=":null">
				<x path="lime.utils.Bytes"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.utils.AssetManifest"/></c>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</loadFromBytes>
		<loadFromFile public="1" set="method" line="74" static="1">
			<f a="path:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.utils.AssetManifest"/></c>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</loadFromFile>
		<parse public="1" set="method" line="90" static="1">
			<f a="data:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.utils.AssetManifest"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</parse>
		<__resolvePath set="method" line="158" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></__resolvePath>
		<__resolveRootPath set="method" line="204" static="1"><f a="rootPath:path">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></__resolveRootPath>
		<assets public="1"><c path="Array"><d/></c></assets>
		<libraryArgs public="1"><c path="Array"><c path="String"/></c></libraryArgs>
		<libraryType public="1"><c path="String"/></libraryType>
		<name public="1"><c path="String"/></name>
		<rootPath public="1"><c path="String"/></rootPath>
		<version public="1"><x path="Int"/></version>
		<serialize public="1" set="method" line="135"><f a=""><c path="String"/></f></serialize>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.utils.AssetType" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/AssetType.hx">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.utils._AssetType.AssetType_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/AssetType.hx" private="1" module="lime.utils.AssetType" extern="1">
	<BINARY public="1" get="inline" set="null" expr="cast &quot;BINARY&quot;" line="6" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "BINARY"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BINARY>
	<FONT public="1" get="inline" set="null" expr="cast &quot;FONT&quot;" line="7" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "FONT"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FONT>
	<IMAGE public="1" get="inline" set="null" expr="cast &quot;IMAGE&quot;" line="8" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "IMAGE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</IMAGE>
	<MANIFEST public="1" get="inline" set="null" expr="cast &quot;MANIFEST&quot;" line="9" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "MANIFEST"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MANIFEST>
	<MUSIC public="1" get="inline" set="null" expr="cast &quot;MUSIC&quot;" line="10" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "MUSIC"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MUSIC>
	<SOUND public="1" get="inline" set="null" expr="cast &quot;SOUND&quot;" line="11" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "SOUND"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SOUND>
	<TEMPLATE public="1" get="inline" set="null" expr="cast &quot;TEMPLATE&quot;" line="12" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "TEMPLATE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEMPLATE>
	<TEXT public="1" get="inline" set="null" expr="cast &quot;TEXT&quot;" line="13" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "TEXT"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEXT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.utils._AssetType.AssetType_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/AssetType.hx" private="1" module="lime.utils.AssetType" extern="1">
		<BINARY public="1" get="inline" set="null" expr="cast &quot;BINARY&quot;" line="6" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "BINARY"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BINARY>
		<FONT public="1" get="inline" set="null" expr="cast &quot;FONT&quot;" line="7" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "FONT"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FONT>
		<IMAGE public="1" get="inline" set="null" expr="cast &quot;IMAGE&quot;" line="8" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "IMAGE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</IMAGE>
		<MANIFEST public="1" get="inline" set="null" expr="cast &quot;MANIFEST&quot;" line="9" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "MANIFEST"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MANIFEST>
		<MUSIC public="1" get="inline" set="null" expr="cast &quot;MUSIC&quot;" line="10" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "MUSIC"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MUSIC>
		<SOUND public="1" get="inline" set="null" expr="cast &quot;SOUND&quot;" line="11" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "SOUND"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SOUND>
		<TEMPLATE public="1" get="inline" set="null" expr="cast &quot;TEMPLATE&quot;" line="12" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "TEMPLATE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEMPLATE>
		<TEXT public="1" get="inline" set="null" expr="cast &quot;TEXT&quot;" line="13" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "TEXT"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEXT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.utils.Assets" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Assets.hx">
		<cache public="1" expr="new AssetCache()" line="47" static="1">
			<c path="lime.utils.AssetCache"/>
			<meta><m n=":value"><e>new AssetCache()</e></m></meta>
		</cache>
		<onChange public="1" expr="new Event&lt;Void&gt;()" line="48" static="1">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onChange>
		<defaultRootPath static="1"><c path="String"/></defaultRootPath>
		<libraries set="null" expr="new Map&lt;String,AssetLibrary&gt;()" line="51" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="lime.utils.AssetLibrary"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,AssetLibrary>()]]></e></m></meta>
		</libraries>
		<libraryPaths expr="new Map&lt;String,String&gt;()" line="52" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,String>()]]></e></m></meta>
		</libraryPaths>
		<exists public="1" set="method" line="55" static="1">
			<f a="id:?type" v=":null">
				<c path="String"/>
				<x path="lime.utils.AssetType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</exists>
		<getAsset public="1" set="method" line="86" static="1">
			<f a="id:type:useCache">
				<c path="String"/>
				<x path="lime.utils.AssetType"/>
				<x path="Bool"/>
				<d/>
			</f>
			<haxe_doc>* Gets an instance of a cached or embedded asset
	 * @usage		var sound = Assets.getAsset("sound.wav", SOUND);
	 * @param	id		The ID or asset path for the asset
	 * @return		An Asset object, or null.</haxe_doc>
		</getAsset>
		<getAudioBuffer public="1" set="method" line="189" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.media.AudioBuffer"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object</haxe_doc>
		</getAudioBuffer>
		<getBytes public="1" set="method" line="202" static="1">
			<f a="id">
				<c path="String"/>
				<x path="lime.utils.Bytes"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new Bytes object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="215" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.text.Font"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getImage public="1" set="method" line="229" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap(Assets.getBitmapData("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache(Default: true)
	 * @return		A new BitmapData object</haxe_doc>
		</getImage>
		<getLibrary public="1" set="method" line="236" static="1"><f a="name">
	<c path="String"/>
	<c path="lime.utils.AssetLibrary"/>
</f></getLibrary>
		<getPath public="1" set="method" line="255" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets the file path (if available) for an asset
	 * @usage		var path = Assets.getPath("image.jpg");
	 * @param	id		The ID or asset path for the asset
	 * @return		The path to the asset (or null)</haxe_doc>
		</getPath>
		<getText public="1" set="method" line="292" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object</haxe_doc>
		</getText>
		<hasLibrary public="1" set="method" line="299" static="1"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasLibrary>
		<isLocal public="1" set="method" line="312" static="1">
			<f a="id:?type:?useCache" v=":null:true">
				<c path="String"/>
				<x path="lime.utils.AssetType"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true, type : null }</e></m></meta>
		</isLocal>
		<isValidAudio set="method" line="334" static="1"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="Bool"/>
</f></isValidAudio>
		<isValidImage set="method" line="343" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Bool"/>
</f></isValidImage>
		<list public="1" set="method" line="352" static="1">
			<f a="?type" v="null">
				<x path="lime.utils.AssetType"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</list>
		<loadAsset public="1" set="method" line="373" static="1"><f a="id:type:useCache">
	<c path="String"/>
	<x path="lime.utils.AssetType"/>
	<x path="Bool"/>
	<c path="lime.app.Future"><d/></c>
</f></loadAsset>
		<loadAudioBuffer public="1" set="method" line="464" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.app.Future"><c path="lime.media.AudioBuffer"/></c>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
		</loadAudioBuffer>
		<loadBytes public="1" set="method" line="471" static="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadBytes>
		<loadFont public="1" set="method" line="478" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.app.Future"><c path="lime.text.Font"/></c>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
		</loadFont>
		<loadImage public="1" set="method" line="485" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
		</loadImage>
		<loadLibrary public="1" set="method" line="492" static="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.utils.AssetLibrary"/></c>
</f></loadLibrary>
		<loadText public="1" set="method" line="556" static="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="String"/></c>
</f></loadText>
		<registerLibrary public="1" set="method" line="563" static="1"><f a="name:library">
	<c path="String"/>
	<c path="lime.utils.AssetLibrary"/>
	<x path="Void"/>
</f></registerLibrary>
		<unloadLibrary public="1" set="method" line="590" static="1"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></unloadLibrary>
		<__libraryNotFound set="method" line="611" static="1"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></__libraryNotFound>
		<library_onChange set="method" line="639" static="1"><f a=""><x path="Void"/></f></library_onChange>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access
 * embedded images, fonts, sounds and other resource files.</p>
 *
 * <p>The contents are populated automatically when an application
 * is compiled using the Lime command-line tools, based on the
 * contents of the project file.</p>
 *
 * <p>For most platforms, the assets are included in the same directory
 * or package as the application, and the paths are handled
 * automatically. For web content, the assets are preloaded before
 * the start of the rest of the application.</p>]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime.utils.AssetLibrary</e></m>
		</meta>
	</class>
	<class path="lime.utils._Assets.LibrarySymbol" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Assets.hx" private="1" module="lime.utils.Assets">
		<library public="1" set="null"><c path="lime.utils.AssetLibrary"/></library>
		<libraryName public="1" set="null"><c path="String"/></libraryName>
		<symbolName public="1" set="null"><c path="String"/></symbolName>
		<isLocal public="1" get="inline" set="null" line="674"><f a="?type">
	<c path="String"/>
	<x path="Bool"/>
</f></isLocal>
		<exists public="1" get="inline" set="null" line="675"><f a="?type">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<new public="1" get="inline" set="null" line="664"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.utils.BytePointer" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/BytePointer.hx">
		<from>
			<icast><c path="lime.utils.BytePointerData"/></icast>
			<icast field="fromArrayBufferView"><c path="lime.utils.ArrayBufferView"/></icast>
			<icast field="fromArrayBuffer"><x path="lime.utils.ArrayBuffer"/></icast>
			<icast field="fromBytes"><c path="haxe.io.Bytes"/></icast>
			<icast field="fromBytesData"><t path="haxe.io.BytesData"/></icast>
			<icast field="fromLimeBytes"><t path="lime.utils._Bytes.LimeBytes"/></icast>
		</from>
		<this><c path="lime.utils.BytePointerData"/></this>
		<to>
			<icast><c path="lime.utils.BytePointerData"/></icast>
			<icast field="toUInt8Array"><x path="lime.utils.UInt8Array"/></icast>
			<icast field="toUInt8ClampedArray"><x path="lime.utils.UInt8ClampedArray"/></icast>
			<icast field="toInt8Array"><x path="lime.utils.Int8Array"/></icast>
			<icast field="toUInt16Array"><x path="lime.utils.UInt16Array"/></icast>
			<icast field="toInt16Array"><x path="lime.utils.Int16Array"/></icast>
			<icast field="toUInt32Array"><x path="lime.utils.UInt32Array"/></icast>
			<icast field="toInt32Array"><x path="lime.utils.Int32Array"/></icast>
			<icast field="toFloat32Array"><x path="lime.utils.Float32Array"/></icast>
			<icast field="toFloat64Array"><x path="lime.utils.Float64Array"/></icast>
		</to>
		<meta>
			<m n=":access"><e>haxe.io.Bytes</e></m>
			<m n=":access"><e>lime.utils.BytePointerData</e></m>
			<m n=":forward"/>
		</meta>
		<impl><class path="lime.utils._BytePointer.BytePointer_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/BytePointer.hx" private="1" module="lime.utils.BytePointer">
	<_new public="1" get="inline" set="null" line="16" static="1">
		<f a="?bytes:?offset" v="null:0">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="lime.utils.BytePointer"/>
		</f>
		<meta>
			<m n=":value"><e>{ offset : 0, bytes : null }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<set public="1" set="method" line="23" static="1">
		<f a="this:?bytes:?bufferView:?buffer:?offset">
			<c path="lime.utils.BytePointerData"/>
			<c path="haxe.io.Bytes"/>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.ArrayBuffer"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<__arrayGet get="inline" set="null" line="55" static="1">
		<f a="this:index">
			<c path="lime.utils.BytePointerData"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
			<m n=":noCompletion"/>
		</meta>
	</__arrayGet>
	<__arraySet get="inline" set="null" line="62" static="1">
		<f a="this:index:value">
			<c path="lime.utils.BytePointerData"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
			<m n=":noCompletion"/>
		</meta>
	</__arraySet>
	<fromArrayBufferView public="1" set="method" line="70" static="1">
		<f a="arrayBufferView">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.BytePointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromArrayBufferView>
	<fromArrayBuffer public="1" set="method" line="83" static="1">
		<f a="buffer">
			<x path="lime.utils.ArrayBuffer"/>
			<x path="lime.utils.BytePointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromArrayBuffer>
	<fromBytes public="1" set="method" line="96" static="1">
		<f a="bytes">
			<c path="haxe.io.Bytes"/>
			<x path="lime.utils.BytePointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromBytes>
	<fromBytesData public="1" set="method" line="103" static="1">
		<f a="bytesData">
			<t path="haxe.io.BytesData"/>
			<x path="lime.utils.BytePointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromBytesData>
	<fromFile public="1" set="method" line="111" static="1"><f a="path">
	<c path="String"/>
	<x path="lime.utils.BytePointer"/>
</f></fromFile>
	<fromLimeBytes public="1" set="method" line="118" static="1">
		<f a="bytes">
			<t path="lime.utils._Bytes.LimeBytes"/>
			<x path="lime.utils.BytePointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromLimeBytes>
	<toUInt8Array public="1" set="method" line="125" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toUInt8Array>
	<toUInt8ClampedArray public="1" set="method" line="136" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toUInt8ClampedArray>
	<toInt8Array public="1" set="method" line="149" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toInt8Array>
	<toUInt16Array public="1" set="method" line="162" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toUInt16Array>
	<toInt16Array public="1" set="method" line="175" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toInt16Array>
	<toUInt32Array public="1" set="method" line="188" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toUInt32Array>
	<toInt32Array public="1" set="method" line="201" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toInt32Array>
	<toFloat32Array public="1" set="method" line="214" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toFloat32Array>
	<toFloat64Array public="1" set="method" line="227" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toFloat64Array>
	<meta>
		<m n=":final"/>
		<m n=":access"><e>lime.utils.BytePointerData</e></m>
		<m n=":access"><e>haxe.io.Bytes</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.utils._BytePointer.BytePointer_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/BytePointer.hx" private="1" module="lime.utils.BytePointer">
		<_new public="1" get="inline" set="null" line="16" static="1">
			<f a="?bytes:?offset" v="null:0">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="lime.utils.BytePointer"/>
			</f>
			<meta>
				<m n=":value"><e>{ offset : 0, bytes : null }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<set public="1" set="method" line="23" static="1">
			<f a="this:?bytes:?bufferView:?buffer:?offset">
				<c path="lime.utils.BytePointerData"/>
				<c path="haxe.io.Bytes"/>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<__arrayGet get="inline" set="null" line="55" static="1">
			<f a="this:index">
				<c path="lime.utils.BytePointerData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
				<m n=":noCompletion"/>
			</meta>
		</__arrayGet>
		<__arraySet get="inline" set="null" line="62" static="1">
			<f a="this:index:value">
				<c path="lime.utils.BytePointerData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
				<m n=":noCompletion"/>
			</meta>
		</__arraySet>
		<fromArrayBufferView public="1" set="method" line="70" static="1">
			<f a="arrayBufferView">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.BytePointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromArrayBufferView>
		<fromArrayBuffer public="1" set="method" line="83" static="1">
			<f a="buffer">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="lime.utils.BytePointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromArrayBuffer>
		<fromBytes public="1" set="method" line="96" static="1">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<x path="lime.utils.BytePointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromBytes>
		<fromBytesData public="1" set="method" line="103" static="1">
			<f a="bytesData">
				<t path="haxe.io.BytesData"/>
				<x path="lime.utils.BytePointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromBytesData>
		<fromFile public="1" set="method" line="111" static="1"><f a="path">
	<c path="String"/>
	<x path="lime.utils.BytePointer"/>
</f></fromFile>
		<fromLimeBytes public="1" set="method" line="118" static="1">
			<f a="bytes">
				<t path="lime.utils._Bytes.LimeBytes"/>
				<x path="lime.utils.BytePointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromLimeBytes>
		<toUInt8Array public="1" set="method" line="125" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toUInt8Array>
		<toUInt8ClampedArray public="1" set="method" line="136" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toUInt8ClampedArray>
		<toInt8Array public="1" set="method" line="149" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toInt8Array>
		<toUInt16Array public="1" set="method" line="162" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toUInt16Array>
		<toInt16Array public="1" set="method" line="175" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toInt16Array>
		<toUInt32Array public="1" set="method" line="188" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toUInt32Array>
		<toInt32Array public="1" set="method" line="201" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toInt32Array>
		<toFloat32Array public="1" set="method" line="214" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toFloat32Array>
		<toFloat64Array public="1" set="method" line="227" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toFloat64Array>
		<meta>
			<m n=":final"/>
			<m n=":access"><e>lime.utils.BytePointerData</e></m>
			<m n=":access"><e>haxe.io.Bytes</e></m>
		</meta>
	</class>
	<class path="lime.utils.BytePointerData" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/BytePointer.hx" module="lime.utils.BytePointer">
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<offset public="1"><x path="Int"/></offset>
		<new public="1" set="method" line="250"><f a="bytes:offset">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<abstract path="lime.utils.Bytes" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Bytes.hx">
		<from><icast><t path="haxe.io._Bytes.HaxeBytes"/></icast></from>
		<this><t path="haxe.io._Bytes.HaxeBytes"/></this>
		<to><icast><t path="haxe.io._Bytes.HaxeBytes"/></icast></to>
		<meta>
			<m n=":access"><e>haxe.io.Bytes</e></m>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":forward"/>
		</meta>
		<impl><class path="lime.utils._Bytes.Bytes_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Bytes.hx" private="1" module="lime.utils.Bytes">
	<_new public="1" set="method" line="22" static="1">
		<f a="length:bytesData">
			<x path="Int"/>
			<t path="haxe.io.BytesData"/>
			<x path="lime.utils.Bytes"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<alloc public="1" set="method" line="35" static="1"><f a="length">
	<x path="Int"/>
	<x path="lime.utils.Bytes"/>
</f></alloc>
	<compress public="1" set="method" line="45" static="1">
		<f a="this:algorithm">
			<t path="haxe.io._Bytes.HaxeBytes"/>
			<e path="lime.utils.CompressionAlgorithm"/>
			<x path="lime.utils.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</compress>
	<decompress public="1" set="method" line="72" static="1">
		<f a="this:algorithm">
			<t path="haxe.io._Bytes.HaxeBytes"/>
			<e path="lime.utils.CompressionAlgorithm"/>
			<x path="lime.utils.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</decompress>
	<fastGet public="1" get="inline" set="null" line="99" static="1"><f a="b:pos">
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
</f></fastGet>
	<fromBytes public="1" set="method" line="106" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="lime.utils.Bytes"/>
</f></fromBytes>
	<fromFile public="1" set="method" line="115" static="1"><f a="path">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></fromFile>
	<loadFromBytes public="1" set="method" line="132" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadFromBytes>
	<loadFromFile public="1" set="method" line="139" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadFromFile>
	<ofData public="1" set="method" line="147" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<x path="lime.utils.Bytes"/>
</f></ofData>
	<ofString public="1" set="method" line="155" static="1"><f a="s">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></ofString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		<m n=":access"><e>haxe.io.Bytes</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.utils._Bytes.Bytes_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Bytes.hx" private="1" module="lime.utils.Bytes">
		<_new public="1" set="method" line="22" static="1">
			<f a="length:bytesData">
				<x path="Int"/>
				<t path="haxe.io.BytesData"/>
				<x path="lime.utils.Bytes"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<alloc public="1" set="method" line="35" static="1"><f a="length">
	<x path="Int"/>
	<x path="lime.utils.Bytes"/>
</f></alloc>
		<compress public="1" set="method" line="45" static="1">
			<f a="this:algorithm">
				<t path="haxe.io._Bytes.HaxeBytes"/>
				<e path="lime.utils.CompressionAlgorithm"/>
				<x path="lime.utils.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</compress>
		<decompress public="1" set="method" line="72" static="1">
			<f a="this:algorithm">
				<t path="haxe.io._Bytes.HaxeBytes"/>
				<e path="lime.utils.CompressionAlgorithm"/>
				<x path="lime.utils.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</decompress>
		<fastGet public="1" get="inline" set="null" line="99" static="1"><f a="b:pos">
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
</f></fastGet>
		<fromBytes public="1" set="method" line="106" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="lime.utils.Bytes"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="115" static="1"><f a="path">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></fromFile>
		<loadFromBytes public="1" set="method" line="132" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadFromBytes>
		<loadFromFile public="1" set="method" line="139" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadFromFile>
		<ofData public="1" set="method" line="147" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<x path="lime.utils.Bytes"/>
</f></ofData>
		<ofString public="1" set="method" line="155" static="1"><f a="s">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></ofString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>haxe.io.Bytes</e></m>
		</meta>
	</class>
	<enum path="lime.utils.CompressionAlgorithm" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/CompressionAlgorithm.hx">
		<DEFLATE/>
		<GZIP/>
		<LZMA/>
		<ZLIB/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="lime.utils.DataPointer" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/DataPointer.hx">
		<from>
			<icast field="fromInt"><x path="Int"/></icast>
			<icast field="fromFloat"><x path="Float"/></icast>
			<icast field="fromBytesPointer"><x path="lime.utils.BytePointer"/></icast>
			<icast field="fromArrayBufferView"><c path="lime.utils.ArrayBufferView"/></icast>
			<icast field="fromArrayBuffer"><x path="lime.utils.ArrayBuffer"/></icast>
			<icast field="fromBytes"><c path="haxe.io.Bytes"/></icast>
			<icast field="fromBytesData"><t path="haxe.io.BytesData"/></icast>
			<icast field="fromLimeBytes"><t path="lime.utils._Bytes.LimeBytes"/></icast>
		</from>
		<this><t path="lime.utils._DataPointer.DataPointerType"/></this>
		<to><icast><t path="lime.utils._DataPointer.DataPointerType"/></icast></to>
		<impl><class path="lime.utils._DataPointer.DataPointer_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/DataPointer.hx" private="1" module="lime.utils.DataPointer">
	<_new set="method" line="18" static="1">
		<f a="data">
			<t path="lime.utils._DataPointer.DataPointerType"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<fromInt set="method" line="25" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromInt>
	<fromFloat set="method" line="39" static="1">
		<f a="value">
			<x path="Float"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromFloat>
	<fromBytesPointer public="1" set="method" line="52" static="1">
		<f a="pointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromBytesPointer>
	<fromArrayBufferView public="1" set="method" line="67" static="1">
		<f a="arrayBufferView">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromArrayBufferView>
	<fromArrayBuffer public="1" set="method" line="82" static="1">
		<f a="buffer">
			<x path="lime.utils.ArrayBuffer"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromArrayBuffer>
	<fromBytes public="1" set="method" line="96" static="1">
		<f a="bytes">
			<c path="haxe.io.Bytes"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromBytes>
	<fromBytesData public="1" set="method" line="111" static="1">
		<f a="bytesData">
			<t path="haxe.io.BytesData"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromBytesData>
	<fromLimeBytes public="1" set="method" line="125" static="1">
		<f a="bytes">
			<t path="lime.utils._Bytes.LimeBytes"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromLimeBytes>
	<fromFile public="1" set="method" line="146" static="1"><f a="path">
	<c path="String"/>
	<x path="lime.utils.DataPointer"/>
</f></fromFile>
	<__withOffset set="method" line="396" static="1"><f a="data:offset">
	<x path="lime.utils.DataPointer"/>
	<x path="Int"/>
	<x path="lime.utils.DataPointer"/>
</f></__withOffset>
	<equals get="inline" set="null" line="409" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A == B</e></m>
		</meta>
	</equals>
	<equalsPointer get="inline" set="null" line="410" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="lime.utils.DataPointer"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A == B</e></m>
		</meta>
	</equalsPointer>
	<greaterThan get="inline" set="null" line="411" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A > B]]></e></m>
		</meta>
	</greaterThan>
	<greaterThanOrEqual get="inline" set="null" line="415" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A >= B]]></e></m>
		</meta>
	</greaterThanOrEqual>
	<lessThan get="inline" set="null" line="419" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A < B]]></e></m>
		</meta>
	</lessThan>
	<lessThanOrEqual get="inline" set="null" line="423" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A <= B]]></e></m>
		</meta>
	</lessThanOrEqual>
	<notEquals get="inline" set="null" line="427" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A != B</e></m>
		</meta>
	</notEquals>
	<notEqualsPointer get="inline" set="null" line="428" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="lime.utils.DataPointer"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A != B</e></m>
		</meta>
	</notEqualsPointer>
	<plus get="inline" set="null" line="429" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A + B</e></m>
		</meta>
	</plus>
	<plusPointer get="inline" set="null" line="430" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="lime.utils.DataPointer"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A + B</e></m>
		</meta>
	</plusPointer>
	<minus get="inline" set="null" line="431" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A - B</e></m>
		</meta>
	</minus>
	<minusPointer get="inline" set="null" line="432" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="lime.utils.DataPointer"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A - B</e></m>
		</meta>
	</minusPointer>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._DataPointer.DataPointer_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/DataPointer.hx" private="1" module="lime.utils.DataPointer">
		<_new set="method" line="18" static="1">
			<f a="data">
				<t path="lime.utils._DataPointer.DataPointerType"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<fromInt set="method" line="25" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromInt>
		<fromFloat set="method" line="39" static="1">
			<f a="value">
				<x path="Float"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromFloat>
		<fromBytesPointer public="1" set="method" line="52" static="1">
			<f a="pointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromBytesPointer>
		<fromArrayBufferView public="1" set="method" line="67" static="1">
			<f a="arrayBufferView">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromArrayBufferView>
		<fromArrayBuffer public="1" set="method" line="82" static="1">
			<f a="buffer">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromArrayBuffer>
		<fromBytes public="1" set="method" line="96" static="1">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromBytes>
		<fromBytesData public="1" set="method" line="111" static="1">
			<f a="bytesData">
				<t path="haxe.io.BytesData"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromBytesData>
		<fromLimeBytes public="1" set="method" line="125" static="1">
			<f a="bytes">
				<t path="lime.utils._Bytes.LimeBytes"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromLimeBytes>
		<fromFile public="1" set="method" line="146" static="1"><f a="path">
	<c path="String"/>
	<x path="lime.utils.DataPointer"/>
</f></fromFile>
		<__withOffset set="method" line="396" static="1"><f a="data:offset">
	<x path="lime.utils.DataPointer"/>
	<x path="Int"/>
	<x path="lime.utils.DataPointer"/>
</f></__withOffset>
		<equals get="inline" set="null" line="409" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A == B</e></m>
			</meta>
		</equals>
		<equalsPointer get="inline" set="null" line="410" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="lime.utils.DataPointer"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A == B</e></m>
			</meta>
		</equalsPointer>
		<greaterThan get="inline" set="null" line="411" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A > B]]></e></m>
			</meta>
		</greaterThan>
		<greaterThanOrEqual get="inline" set="null" line="415" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A >= B]]></e></m>
			</meta>
		</greaterThanOrEqual>
		<lessThan get="inline" set="null" line="419" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A < B]]></e></m>
			</meta>
		</lessThan>
		<lessThanOrEqual get="inline" set="null" line="423" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A <= B]]></e></m>
			</meta>
		</lessThanOrEqual>
		<notEquals get="inline" set="null" line="427" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A != B</e></m>
			</meta>
		</notEquals>
		<notEqualsPointer get="inline" set="null" line="428" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="lime.utils.DataPointer"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A != B</e></m>
			</meta>
		</notEqualsPointer>
		<plus get="inline" set="null" line="429" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A + B</e></m>
			</meta>
		</plus>
		<plusPointer get="inline" set="null" line="430" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="lime.utils.DataPointer"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A + B</e></m>
			</meta>
		</plusPointer>
		<minus get="inline" set="null" line="431" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A - B</e></m>
			</meta>
		</minus>
		<minusPointer get="inline" set="null" line="432" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="lime.utils.DataPointer"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A - B</e></m>
			</meta>
		</minusPointer>
		<meta><m n=":final"/></meta>
	</class>
	<typedef path="lime.utils._DataPointer.DataPointerType" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/DataPointer.hx" private="1" module="lime.utils.DataPointer"><d/></typedef>
	<class path="lime.utils.DataPointerObject" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/DataPointer.hx" module="lime.utils.DataPointer">
		<buffer public="1"><x path="lime.utils.ArrayBuffer"/></buffer>
		<bufferView public="1"><c path="lime.utils.ArrayBufferView"/></bufferView>
		<offset public="1"><x path="Int"/></offset>
		<type public="1"><e path="lime.utils.DataPointerObjectType"/></type>
		<new public="1" set="method" line="452">
			<f a="?bufferView:?buffer:?offset" v="::0">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<enum path="lime.utils.DataPointerObjectType" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/DataPointer.hx" module="lime.utils.DataPointer">
		<BUFFER/>
		<BUFFER_VIEW/>
		<VALUE/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</enum>
	<class path="lime.utils.DataView" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/DataView.hx">
		<buffer public="1"><x path="lime.utils.ArrayBuffer"/></buffer>
		<byteLength public="1"><x path="Int"/></byteLength>
		<byteOffset public="1"><x path="Int"/></byteOffset>
		<getInt8 public="1" get="inline" set="null" line="146"><f a="byteOffset">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt8>
		<getInt16 public="1" get="inline" set="null" line="151">
			<f a="byteOffset:?littleEndian" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getInt16>
		<getInt32 public="1" get="inline" set="null" line="158">
			<f a="byteOffset:?littleEndian" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getInt32>
		<getUint8 public="1" get="inline" set="null" line="165"><f a="byteOffset">
	<x path="Int"/>
	<x path="UInt"/>
</f></getUint8>
		<getUint16 public="1" get="inline" set="null" line="170">
			<f a="byteOffset:?littleEndian" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getUint16>
		<getUint32 public="1" get="inline" set="null" line="177">
			<f a="byteOffset:?littleEndian" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getUint32>
		<getFloat32 public="1" get="inline" set="null" line="184">
			<f a="byteOffset:?littleEndian" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getFloat32>
		<getFloat64 public="1" get="inline" set="null" line="191">
			<f a="byteOffset:?littleEndian" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getFloat64>
		<setInt8 public="1" get="inline" set="null" line="201"><f a="byteOffset:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt8>
		<setInt16 public="1" get="inline" set="null" line="206">
			<f a="byteOffset:value:?littleEndian" v="::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setInt16>
		<setInt32 public="1" get="inline" set="null" line="213">
			<f a="byteOffset:value:?littleEndian" v="::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setInt32>
		<setUint8 public="1" get="inline" set="null" line="220"><f a="byteOffset:value">
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setUint8>
		<setUint16 public="1" get="inline" set="null" line="225">
			<f a="byteOffset:value:?littleEndian" v="::true">
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setUint16>
		<setUint32 public="1" get="inline" set="null" line="232">
			<f a="byteOffset:value:?littleEndian" v="::true">
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setUint32>
		<setFloat32 public="1" get="inline" set="null" line="239">
			<f a="byteOffset:value:?littleEndian" v="::true">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setFloat32>
		<setFloat64 public="1" get="inline" set="null" line="246">
			<f a="byteOffset:value:?littleEndian" v="::true">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setFloat64>
		<new public="1" get="inline" set="null" line="119">
			<f a="buffer:?byteOffset:?byteLength" v=":0:null">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ byteLength : null, byteOffset : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.utils.Float32Array" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Float32Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Float32Array.Float32Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Float32Array.hx" private="1" module="lime.utils.Float32Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="67" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</BYTES_PER_ELEMENT>
	<hello public="1" static="1"><x path="Int"/></hello>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="72" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="97" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="101" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="105" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<toString get="inline" set="null" line="111" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<get_length get="inline" set="null" line="113" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":extern"/>
		</meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="118" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="124" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._Float32Array.Float32Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Float32Array.hx" private="1" module="lime.utils.Float32Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="67" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<hello public="1" static="1"><x path="Int"/></hello>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="72" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="97" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="101" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="105" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<toString get="inline" set="null" line="111" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<get_length get="inline" set="null" line="113" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":extern"/>
			</meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="118" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="124" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.Float64Array" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Float64Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Float64Array.Float64Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Float64Array.hx" private="1" module="lime.utils.Float64Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="8" line="65" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>8</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="70" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="95" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="99" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="114" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="120" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="125" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._Float64Array.Float64Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Float64Array.hx" private="1" module="lime.utils.Float64Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="8" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="95" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="99" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="114" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="120" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="125" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.Int16Array" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Int16Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Int16Array.Int16Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Int16Array.hx" private="1" module="lime.utils.Int16Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="65" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>2</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="70" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="95" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="99" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="114" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="120" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="125" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._Int16Array.Int16Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Int16Array.hx" private="1" module="lime.utils.Int16Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="95" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="99" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="114" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="120" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="125" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.Int32Array" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Int32Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Int32Array.Int32Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Int32Array.hx" private="1" module="lime.utils.Int32Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="65" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="70" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="95" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="99" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="114" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="120" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="125" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._Int32Array.Int32Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Int32Array.hx" private="1" module="lime.utils.Int32Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="95" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="99" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="114" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="120" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="125" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.Int8Array" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Int8Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Int8Array.Int8Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Int8Array.hx" private="1" module="lime.utils.Int8Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="63" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="68" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="93" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="97" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="114" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="120" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="125" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._Int8Array.Int8Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Int8Array.hx" private="1" module="lime.utils.Int8Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="68" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="93" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="97" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="114" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="120" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="125" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
	<class path="lime.utils.Log" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Log.hx">
		<level public="1" static="1"><x path="lime.utils.LogLevel"/></level>
		<throwErrors public="1" expr="true" line="16" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</throwErrors>
		<debug public="1" set="method" line="19" static="1"><f a="message:?info">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></debug>
		<error public="1" set="method" line="34" static="1"><f a="message:?info">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></error>
		<info public="1" set="method" line="59" static="1"><f a="message:?info">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></info>
		<print public="1" get="inline" set="null" line="74" static="1">
			<f a="message">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</print>
		<println public="1" get="inline" set="null" line="89" static="1">
			<f a="message">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</println>
		<verbose public="1" set="method" line="104" static="1"><f a="message:?info">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></verbose>
		<warn public="1" set="method" line="115" static="1"><f a="message:?info">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></warn>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.utils.LogLevel" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/LogLevel.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.utils._LogLevel.LogLevel_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/LogLevel.hx" private="1" module="lime.utils.LogLevel">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="lime.utils.LogLevel"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<ERROR public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="lime.utils.LogLevel"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ERROR>
	<WARN public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="lime.utils.LogLevel"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WARN>
	<INFO public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="lime.utils.LogLevel"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INFO>
	<DEBUG public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
		<x path="lime.utils.LogLevel"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEBUG>
	<VERBOSE public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
		<x path="lime.utils.LogLevel"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VERBOSE>
	<gt get="inline" set="null" line="13" static="1">
		<f a="a:b">
			<x path="lime.utils.LogLevel"/>
			<x path="lime.utils.LogLevel"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</gt>
	<gte get="inline" set="null" line="14" static="1">
		<f a="a:b">
			<x path="lime.utils.LogLevel"/>
			<x path="lime.utils.LogLevel"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</gte>
	<lt get="inline" set="null" line="15" static="1">
		<f a="a:b">
			<x path="lime.utils.LogLevel"/>
			<x path="lime.utils.LogLevel"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</lt>
	<lte get="inline" set="null" line="16" static="1">
		<f a="a:b">
			<x path="lime.utils.LogLevel"/>
			<x path="lime.utils.LogLevel"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</lte>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.utils._LogLevel.LogLevel_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/LogLevel.hx" private="1" module="lime.utils.LogLevel">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="lime.utils.LogLevel"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<ERROR public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="lime.utils.LogLevel"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ERROR>
		<WARN public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="lime.utils.LogLevel"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WARN>
		<INFO public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="lime.utils.LogLevel"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INFO>
		<DEBUG public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
			<x path="lime.utils.LogLevel"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEBUG>
		<VERBOSE public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
			<x path="lime.utils.LogLevel"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VERBOSE>
		<gt get="inline" set="null" line="13" static="1">
			<f a="a:b">
				<x path="lime.utils.LogLevel"/>
				<x path="lime.utils.LogLevel"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</gt>
		<gte get="inline" set="null" line="14" static="1">
			<f a="a:b">
				<x path="lime.utils.LogLevel"/>
				<x path="lime.utils.LogLevel"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</gte>
		<lt get="inline" set="null" line="15" static="1">
			<f a="a:b">
				<x path="lime.utils.LogLevel"/>
				<x path="lime.utils.LogLevel"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</lt>
		<lte get="inline" set="null" line="16" static="1">
			<f a="a:b">
				<x path="lime.utils.LogLevel"/>
				<x path="lime.utils.LogLevel"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</lte>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.utils.ObjectPool" params="T" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/ObjectPool.hx">
		<activeObjects public="1" set="null"><x path="Int"/></activeObjects>
		<inactiveObjects public="1" set="null"><x path="Int"/></inactiveObjects>
		<size public="1" get="accessor" set="accessor"><x path="Null"><x path="Int"/></x></size>
		<__inactiveObject0>
			<c path="lime.utils.ObjectPool.T"/>
			<meta><m n=":noCompletion"/></meta>
		</__inactiveObject0>
		<__inactiveObject1>
			<c path="lime.utils.ObjectPool.T"/>
			<meta><m n=":noCompletion"/></meta>
		</__inactiveObject1>
		<__inactiveObjectList>
			<t path="List"><c path="lime.utils.ObjectPool.T"/></t>
			<meta><m n=":noCompletion"/></meta>
		</__inactiveObjectList>
		<__pool>
			<t path="Map">
				<c path="lime.utils.ObjectPool.T"/>
				<x path="Bool"/>
			</t>
			<meta><m n=":noCompletion"/></meta>
		</__pool>
		<__size>
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__size>
		<add public="1" set="method" line="49"><f a="object">
	<c path="lime.utils.ObjectPool.T"/>
	<x path="Void"/>
</f></add>
		<clean public="1" set="dynamic" line="62"><f a="object">
	<c path="lime.utils.ObjectPool.T"/>
	<x path="Void"/>
</f></clean>
		<clear public="1" set="method" line="69"><f a=""><x path="Void"/></f></clear>
		<create public="1" set="dynamic" line="83"><f a=""><c path="lime.utils.ObjectPool.T"/></f></create>
		<get public="1" set="method" line="90"><f a=""><c path="lime.utils.ObjectPool.T"/></f></get>
		<release public="1" set="method" line="116"><f a="object">
	<c path="lime.utils.ObjectPool.T"/>
	<x path="Void"/>
</f></release>
		<__addInactive get="inline" set="null" line="146">
			<f a="object">
				<c path="lime.utils.ObjectPool.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__addInactive>
		<__getInactive get="inline" set="null" line="171">
			<f a=""><c path="lime.utils.ObjectPool.T"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__getInactive>
		<__removeInactive set="method" line="215">
			<f a="count">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__removeInactive>
		<get_size set="method" line="262">
			<f a=""><x path="Null"><x path="Int"/></x></f>
			<meta><m n=":noCompletion"/></meta>
		</get_size>
		<set_size set="method" line="269">
			<f a="value">
				<x path="Null"><x path="Int"/></x>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_size>
		<new public="1" set="method" line="26">
			<f a="?create:?clean:?size" v="null:null:null">
				<f a=""><c path="lime.utils.ObjectPool.T"/></f>
				<f a="">
					<c path="lime.utils.ObjectPool.T"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ size : null, clean : null, create : null }</e></m></meta>
		</new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":generic"/>
		</meta>
	</class>
	<class path="lime.utils.PackedAssetLibrary" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/PackedAssetLibrary.hx">
		<extends path="lime.utils.AssetLibrary"/>
		<fromBytes public="1" set="method" line="48" static="1">
			<f a="bytes:?rootPath" v=":null">
				<x path="lime.utils.Bytes"/>
				<c path="String"/>
				<c path="lime.utils.PackedAssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</fromBytes>
		<fromFile public="1" set="method" line="55" static="1">
			<f a="path:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.utils.PackedAssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</fromFile>
		<fromManifest public="1" set="method" line="62" static="1"><f a="manifest">
	<c path="lime.utils.AssetManifest"/>
	<c path="lime.utils.PackedAssetLibrary"/>
</f></fromManifest>
		<loadFromBytes public="1" set="method" line="386" static="1">
			<f a="bytes:?rootPath" v=":null">
				<x path="lime.utils.Bytes"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.utils.PackedAssetLibrary"/></c>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</loadFromBytes>
		<loadFromFile public="1" set="method" line="398" static="1">
			<f a="path:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.utils.PackedAssetLibrary"/></c>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</loadFromFile>
		<loadFromManifest public="1" set="method" line="410" static="1"><f a="manifest">
	<c path="lime.utils.AssetManifest"/>
	<c path="lime.app.Future"><c path="lime.utils.PackedAssetLibrary"/></c>
</f></loadFromManifest>
		<id>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</id>
		<lengths expr="new Map&lt;String,Int&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Int>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</lengths>
		<packedData>
			<x path="lime.utils.Bytes"/>
			<meta><m n=":noCompletion"/></meta>
		</packedData>
		<positions expr="new Map&lt;String,Int&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Int>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</positions>
		<type>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</type>
		<rootPath>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</rootPath>
		<getAudioBuffer public="1" set="method" line="69" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></getAudioBuffer>
		<getBytes public="1" set="method" line="97" override="1"><f a="id">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></getBytes>
		<getFont public="1" set="method" line="122" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></getFont>
		<getImage public="1" set="method" line="150" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</f></getImage>
		<getText public="1" set="method" line="170" override="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getText>
		<isLocal public="1" set="method" line="193" override="1"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></isLocal>
		<load public="1" set="method" line="200" override="1"><f a=""><c path="lime.app.Future"><c path="lime.utils.AssetLibrary"/></c></f></load>
		<loadAudioBuffer public="1" set="method" line="310" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.media.AudioBuffer"/></c>
</f></loadAudioBuffer>
		<loadBytes public="1" set="method" line="338" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadBytes>
		<loadFont public="1" set="method" line="358" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.text.Font"/></c>
</f></loadFont>
		<loadImage public="1" set="method" line="422" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
</f></loadImage>
		<loadText public="1" set="method" line="442" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="String"/></c>
</f></loadText>
		<unload public="1" set="method" line="481" override="1"><f a=""><x path="Void"/></f></unload>
		<__fromManifest set="method" line="488" override="1">
			<f a="manifest">
				<c path="lime.utils.AssetManifest"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromManifest>
		<__assetLoaded set="method" line="512" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__assetLoaded>
		<new public="1" set="method" line="38"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="lime.utils.Preloader" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Preloader.hx">
		<extends path="flash.display.Sprite"/>
		<complete public="1" set="null"><x path="Bool"/></complete>
		<onComplete public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onComplete>
		<onProgress public="1" expr="new Event&lt;Int -&gt; Int&gt;()">
			<c path="lime.app._Event_Int_Int_Void"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> Int>()]]></e></m></meta>
		</onProgress>
		<bytesLoaded>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</bytesLoaded>
		<bytesLoadedCache expr="new Map&lt;AssetLibrary,Int&gt;()">
			<x path="haxe.ds.Map">
				<c path="lime.utils.AssetLibrary"/>
				<x path="Int"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<AssetLibrary,Int>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</bytesLoadedCache>
		<bytesLoadedCache2 expr="new Map&lt;String,Int&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Int>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</bytesLoadedCache2>
		<bytesTotal>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</bytesTotal>
		<bytesTotalCache expr="new Map&lt;String,Int&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Int>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</bytesTotalCache>
		<initLibraryNames>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</initLibraryNames>
		<libraries>
			<c path="Array"><c path="lime.utils.AssetLibrary"/></c>
			<meta><m n=":noCompletion"/></meta>
		</libraries>
		<libraryNames>
			<c path="Array"><c path="String"/></c>
			<meta><m n=":noCompletion"/></meta>
		</libraryNames>
		<loadedLibraries>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</loadedLibraries>
		<loadedStage>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</loadedStage>
		<preloadComplete>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</preloadComplete>
		<preloadStarted>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</preloadStarted>
		<simulateProgress>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</simulateProgress>
		<addLibrary public="1" set="method" line="119"><f a="library">
	<c path="lime.utils.AssetLibrary"/>
	<x path="Void"/>
</f></addLibrary>
		<addLibraryName public="1" set="method" line="126"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></addLibraryName>
		<load public="1" set="method" line="137"><f a=""><x path="Void"/></f></load>
		<loadedAssetLibrary set="method" line="209">
			<f a="?name" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ name : null }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</loadedAssetLibrary>
		<start set="method" line="233">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</start>
		<update set="method" line="252">
			<f a="loaded:total">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</update>
		<updateProgress set="method" line="259">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</updateProgress>
		<current_onEnter set="method" line="358">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</current_onEnter>
		<loaderInfo_onComplete set="method" line="390">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loaderInfo_onComplete>
		<loaderInfo_onInit set="method" line="407">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loaderInfo_onInit>
		<loaderInfo_onProgress set="method" line="425">
			<f a="event">
				<c path="flash.events.ProgressEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loaderInfo_onProgress>
		<new public="1" set="method" line="58"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.utils.AssetLibrary</e></m>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.utils.Resource" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Resource.hx">
		<from>
			<icast><c path="haxe.io.Bytes"/></icast>
			<icast field="__fromString"><c path="String"/></icast>
		</from>
		<this><c path="haxe.io.Bytes"/></this>
		<to>
			<icast><c path="haxe.io.Bytes"/></icast>
			<icast field="__toString"><c path="String"/></icast>
		</to>
		<impl><class path="lime.utils._Resource.Resource_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Resource.hx" private="1" module="lime.utils.Resource">
	<_new public="1" set="method" line="10" static="1">
		<f a="?size" v="0">
			<x path="Int"/>
			<x path="lime.utils.Resource"/>
		</f>
		<meta>
			<m n=":value"><e>{ size : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<__fromString get="inline" set="null" line="17" static="1">
		<f a="value">
			<c path="String"/>
			<x path="lime.utils.Resource"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromString>
	<__toString get="inline" set="null" line="24" static="1">
		<f a="value">
			<x path="lime.utils.Resource"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</__toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._Resource.Resource_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/Resource.hx" private="1" module="lime.utils.Resource">
		<_new public="1" set="method" line="10" static="1">
			<f a="?size" v="0">
				<x path="Int"/>
				<x path="lime.utils.Resource"/>
			</f>
			<meta>
				<m n=":value"><e>{ size : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<__fromString get="inline" set="null" line="17" static="1">
			<f a="value">
				<c path="String"/>
				<x path="lime.utils.Resource"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromString>
		<__toString get="inline" set="null" line="24" static="1">
			<f a="value">
				<x path="lime.utils.Resource"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</__toString>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.UInt16Array" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/UInt16Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._UInt16Array.UInt16Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/UInt16Array.hx" private="1" module="lime.utils.UInt16Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="65" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>2</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="70" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="95" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="99" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="114" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Null"><x path="UInt"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="120" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="125" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt16Array.UInt16Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/UInt16Array.hx" private="1" module="lime.utils.UInt16Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="95" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="99" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="114" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="120" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="125" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.UInt32Array" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/UInt32Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._UInt32Array.UInt32Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/UInt32Array.hx" private="1" module="lime.utils.UInt32Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="65" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="70" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="95" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="99" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="114" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Null"><x path="UInt"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="120" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="125" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt32Array.UInt32Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/UInt32Array.hx" private="1" module="lime.utils.UInt32Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="95" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="99" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="114" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="120" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="125" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.UInt8Array" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/UInt8Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._UInt8Array.UInt8Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/UInt8Array.hx" private="1" module="lime.utils.UInt8Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="65" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="70" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="95" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="99" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<toString get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<get_length get="inline" set="null" line="111" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="116" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Null"><x path="UInt"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="122" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt8Array.UInt8Array_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/UInt8Array.hx" private="1" module="lime.utils.UInt8Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="95" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="99" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<toString get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<get_length get="inline" set="null" line="111" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="116" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="122" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.UInt8ClampedArray" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/UInt8ClampedArray.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta>
			<m n=":forward"/>
			<m n=":arrayAccess"/>
		</meta>
		<impl><class path="lime.utils._UInt8ClampedArray.UInt8ClampedArray_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/UInt8ClampedArray.hx" private="1" module="lime.utils.UInt8ClampedArray">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="74" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="79" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="104" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="108" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="112" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="118" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="123" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Null"><x path="UInt"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="129" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="134" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt8ClampedArray.UInt8ClampedArray_Impl_" params="" file="/Users/joshua/Development/Haxe/lime/src/lime/utils/UInt8ClampedArray.hx" private="1" module="lime.utils.UInt8ClampedArray">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="74" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="79" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="104" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="108" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="112" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="118" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="123" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="129" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="134" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
</haxe>